
class Error <let msg: string, let fatal: i1 = false>
class Warning <let msg: string>
class Note <let msg: string>

/* ANY */
def err_generic_error : Error<"$0">
def warn_generic_warn : Warning<"$0">
def note_generic_note : Note<"$0">

// frontend errors
def err_invalid_opt_level : Error<"optimization levels higher than $0 are unsupported">
def err_unsupported_opt_level : Error<"unsupported optimization level '$0'">
def err_expected_filename_after : Error<"expected filename after '$0'">
def err_unsupported_argument : Error<"unsupported argument '$0'">
def err_no_source_file : Error<"no source file specified">

def fatal_too_many_errors : Error<"too many errors emmitted, stopping now", true>
def err_internal_compiler_error : Error<"an internal compiler error occured">

/* PARSING */
def err_unexpected_eof : Error<"unexpected end of file${ 0 | if(, expecting $1) }">
def err_unexpected_token : Error<"unexpected token $0${ 1 | if(, expecting $2) }">
def err_expecting_decl : Error<"unexpected token $0, expecting ${ 1 | if(top level ) }declaration">

def err_extraneous_paren : Error<"extraneous closing ${ 0 | select(')', '}', ']', '>') }">

def warn_inexact_fp : Warning<"floating point value cannot be represented exactly">
def note_to_match_this : Note<"to match this">

def err_invalid_traits : Error<"invalid '__traits' directive '$0'">
def err_duplicate_access_spec : Error<"duplicate access specifier">

def err_vararg_must_be_last : Error<"vararg arguments must come last in a function signature">
def note_previous_vararg_here : Note<"previous varargs here">

def err_vararg_default_value : Error<"varargs may not define a default value">
def err_expected_default_value : Error<"expecting default value">

def err_covar_convar_already_specified : Error<"${ 0 | select(covariance, contravariance) } already specified">

def err_inferred_arr_size_not_allowed : Error<"array type with inferred size is only allowed with variable declarations">

def err_mutating_non_method : Error<"expected method declaration after 'mutating'">
def err_cannot_be_static : Error<"$0 cannot be static">
def err_duplicate_decl_kind : Error<"unexpected declaration keyword">

def err_multiple_inheritance : Error<"only one inheritance clause is allowed">
def err_deinit_args : Error<"deinitializers cannot have arguments">
def err_prop_must_have_type : Error<"property must have a defined type">
def err_prop_must_have_get_or_set : Error<"property must have a getter or a setter">

def err_duplicate_getter_setter : Error<"${ 0 | select(getter, setter) } already declared">

def err_last_match_case_empty : Error<"last case in a match statement may not be empty">
def err_expected_declaration : Error<"expected declaration after '$0'">
def err_declared_with_definition : Error<"'declare'd statements may not have a definition">

def err_bad_extern_kind : Error<"unknown extern kind '$0'">
def err_import_not_at_begin : Error<"'import' statements may only appear at the beginning of a file">

def err_labeled_args_last : Error<"labeled arguments must come last in a function call">

// Attribute Errors
def err_attribute_no_args : Error<"attribute @$0 does not take any arguments">
def err_attribute_arg_count : Error<"attribute @$0 expects ${ 1 | select(at least, at most) } $2 ${ 2 | plural_s(argument) }, $3 given">
def err_attribute_bad_arg : Error<"attribute @$0 expects ${ 1 | select(integer literal, floating point literal, string literal, expression, type, one of '$3') } as ${ 2 | ordinal } argument">

def err_attribute_applicability : Error<"attribute @$0 is not applicable to ${ 1 | select(declarations, statements, expressions, types) }">
def err_attribute_not_valid_here : Error<"attribute @$0 is not allowed here">

def err_implicit_attr_not_valid : Error<"@implicit can only be used on operator function or initializer declarations">

// @align
def err_attr_align_bad_arg : Error<"1st argument to @align must be ${ 0 | select(integral, a power of two, greater than or equal to zero) }">
def err_attr_align_lower_than_natural : Error<"alignment value cannot be lower than the natural alignment of a type ($0 < $1)">
def err_attr_align_too_high : Error<"alignment must be 268435456 bytes or smaller">

/* PREPROCESSING*/
def err_max_macro_recursion_depth : Error<"maximum macro recursion depth reached ($0) in expansion of macro $1">

/* TYPE ERRORS */
def warn_implicit_cast : Warning<"implicit cast from $0 to $1">
def err_type_mismatch : Error<"incompatible types $0 and $1">
def err_no_implicit_conv : Error<"no implicit conversion from $0 to $1">
def err_unexpected_value : Error<"expected $0">

def err_no_explicit_cast : Error<"no known explicit conversion from $0 to $1">

def err_return_type_mismatch : Error<"returned value of type $0 is not compatible with declared return type $1">
def err_cond_not_boolean : Error<"${ 0 | select(if,while,for,ternay operator '?:') } condition must be boolean">
def err_range_not_iterable : Error<"range expression of for-in statement must conform to 'Iterable'">
def err_dict_key_not_hashable : Error<"dictionary keys must conform to 'Hashable'">
def err_requires_contextual_type : Error<"$0 requires a contextual type">
def err_not_string_representable : Error<"value must conform to 'StringRepresentable'">
def err_illegal_subscript : Error<"subscript operator cannot be applied to value of type $0">
def err_subscript_index_not_integral : Error<"subscript indices have to be integral">
def err_cannot_assign_void : Error<"cannot assign value of type void">
def err_reserved_identifier : Error<"$0 is a reserved identifier">
def err_value_not_a_pointer : Error<"value is not a pointer">
def err_type_not_callable : Error<"given type $0 is not callable">
def err_assign_non_mutating_self : Error<"cannot reassign 'self' in a non-mutating method">
def err_assign_to_rvalue : Error<"cannot assign to rvalue of type $0">

def err_type_not_found : Error<"type '$0' not found">

def err_uninitialized_local : Error<"'$0' may be uninitialized when used here">
def err_initialized_more_than_once : Error<"'$0' may be initialized more than once">
def note_previous_init_here : Note<"previous initialization was here">
def note_uninitialized_declared_here : Note<"was declared here">

def err_reassign_constant : Error<"cannot reassign 'let' constant">
def note_declared_const_here : Note<"'$0' declared as constant here">

def err_assign_type_mismatch : Error<"cannot assign value of type '$0' to type '$1'">
def err_cast_requires_op : Error<"cast between '$0' and '$1' requires '${ 2 | select(as, as?, as!) }' operator">

def err_access_member_on_type : Error<"cannot access member on value of type $0">
def err_access_member_on_pointer : Error<"cannot access member on pointer, did you mean to use '->'?">
def err_member_access_non_pointer : Error<"cannot apply member access operator '->' to non-pointer type $0">

def err_not_tuple : Error<"cannot access indexed member on type $0">
def err_tuple_arity : Error<"cannot access index $0 on tuple with arity $1">

def err_must_be_integral_constant : Error<"${ 0 | ordinal } argument to ${ 1 | select(function,primitive initializer) } must be an integral constant">
def err_must_be_floating_constant : Error<"${ 0 | ordinal } argument to ${ 1 | select(function,primitive initializer) } must be a floating point constant">

def err_circular_global_value : Error<"type inferred global values $0 and $1 are circularly dependent on each others value">
def note_dependent_global_here : Note<"dependent global here">

def err_value_is_not_enum : Error<"type $0 is not an enumeration">
def err_record_is_not_enum : Error<"${ 0 | select(class,struct,enum,union,protocol) } $1 is not an enumeration">

def err_subscript_too_many_indices : Error<"too many indices for subscript operator">

def err_iterator_must_return_option : Error<"'next' function used in for-in must return an 'Option' type">
def err_could_not_infer_arr_element_type : Error<"could not infer array literal element type">

def err_no_builtin_decl : Error<"${ 0 | select(none, optional type, array literal, dictionary literal, string literal) } cannot be used because the declaration for '${ 0 | select(Option, Option, Array, Dictionary, String) }' was not found">

def warn_expr_result_unused : Warning<"expression result unused">

// (Re-)Declaration
def err_redeclared_symbol : Error<"redeclaration of '$0'${ 1 | if(  as a different kind of symbol) }">
def note_previous_decl : Note<"previous declaration here">

def err_decl_requires_init : Error<"declaration of ${ 0 | select(local, global) } variable with inferred type requires an initializer">

def err_bad_destructure_type : Error<"type $0 cannot be destructured into type $1">
def err_bad_destructure_count : Error<"type $0 cannot be destructured into $1 values">
def err_ambiguous_destructure : Error<"reference to destructuring operator is ambiguous">

/* FUNCTION / METHOD CALL ERRORS */
def err_func_not_found : Error<"${ 0 | select(function, method) } $1 not found">
def err_no_matching_call : Error<"no matching call for ${ 0 | select(function,method) } $1 found">

def err_cannot_call : Error<"cannot call ${ 0 | select(typedef,namespace) }">
def err_cannot_call_method_on : Error<"cannot call method on value of type $0">
def err_cannot_call_type : Error<"cannot call type $0${ 1 | if(  statically) }">

def note_cand_no_implicit_conv : Note<"candidate function not viable: no implicit conversion from $0 to $1 for ${ 2 | ordinal } argument${ 3 | if( (builtin operator candidate)) }">
def note_cand_no_implicit_conv_inferred : Note<"candidate function not viable: no implicit conversion from $0 to $1 for ${ 2 | ordinal } argument (with template arguments inferred as [$3])">
def note_cand_failed_constraint : Note<"candidate function not viable because of failed constraint: $0">
def note_cand_failed_constraint_inferred : Note<"candidate function not viable because of failed constraint: $0 (with template arguments inferred as [$1])">
def note_cand_invalid_self : Note<"candidate function note viable: 'self' argument has type '$0', '$1' given">

def note_too_few_arguments : Note<"candidate function not viable: requires at least $0 ${ 0 | plural_s(argument) }, $1 given${ 2 | if( (builtin operator candidate)) }">
def note_too_many_arguments : Note<"candidate function not viable: requires at most $0 ${ 0 | plural_s(argument) }, $1 given${ 2 | if( (builtin operator candidate)) }">
def note_too_few_arguments_inferred : Note<"candidate function not viable: requires at least $0 ${ 0 | plural_s(argument) }, $1 given (with template arguments inferred as [$2])">
def note_too_many_arguments_inferred : Note<"candidate function not viable: requires at most $0 ${ 0 | plural_s(argument) }, $1 given (with template arguments inferred as [$2])">

def note_could_not_infer_template_arg : Note<"candidate function not viable: could not infer template argument $0">
def note_inferred_template_arg_conflict : Note<"candidate function not viable: conflicting ${ 0 | select(types,values) } $1 and $2 deduced for template argument $3">
def note_template_arg_kind_mismatch : Note<"candidate function not viable: expected ${ 0 | select(typename, value, variadic typename, variadic value) } but found ${ 1 | select(typename, value, variadic typename, variadic value) } for ${ 2 | ordinal } argument">
def note_template_arg_type_mismatch : Note<"candidate function not viable: expected $0 as ${ 1 | ordinal } argument but found $2">
def note_template_parameter_here : Note<"template parameter declared here">
def note_too_many_template_args : Note<"expected at most $0 ${ 0 | plural_s(template argument) }, $1 given">

def note_method_must_be_static : Note<"candidate method not viable: not declared 'static'">
def note_candidate_is_mutating : Note<"candidate method not viable: is 'mutating', but self parameter is ${ 0 | select(`let` constant, not an lvalue) }">

def err_ambiguous_call : Error<"call to ${ 0 | select(function, method) } '$1' is ambiguous">
def note_candidate_here : Note<"candidate declared here">
def note_builtin_candidate : Note<"builtin ${ 0 | if(operator ) }candidate">

def err_ambiguous_reference : Error<"reference to ${ 0 | select(function, method, alias) } $1 is ambiguous">

def err_prop_does_not_have : Error<"property '$0' does not have a ${ 1 | select(getter, setter) }">

def err_incompatible_template_args : Error<"incompatible template arguments for ${ 0 | select(class,struct,enum,union,protocol,alias) } $1">

// anonymous calls
def err_too_few_args_for_call : Error<"too few arguments for function call, expected $0 but found $1">
def err_too_many_args_for_call : Error<"too many arguments for function call, expected $0 but found $1">

// sizeof...
def err_variadic_sizeof_expects : Error<"expected variadic template parameter as argument to 'sizeof...'">
def err_does_not_name_template_parm : Error<"$0 does not name a ${ 1 | if(variadic ) }template parameter">

/* TEMPLATES */
def err_non_type_param_used_as_type : Error<"non-type template parameter $0 cannot be used as a type">

def note_instantiation_of : Note<"in instantiation of ${ 0 | select(class,struct,enum,union,protocol,function,method,alias,namespace) } '$1'${ 2 | if(  with template arguments [$3]) }">

def err_protocol_template_params : Error<"protocols may not be templated, use associated types instead">
def err_invalid_pack_expansion : Error<"cannot apply pack expansion operator '...' to expression that does not contain a variadic template parameter or argument">
def err_unexpanded_pack : Error<"expression contains unexpanded parameter pack">

def err_template_param_shadow : Error<"template parameter '$0' shadows a template paramater in an enclosing scope">

// CTFE errors
def err_ctfe_circular_dependence : Error<"functions '$0' and '$1' are circularly dependent on each others definition and cannot be statically evaluated">
def note_dependency_chain : Note<"chain of dependency: $0">
def note_called_here : Note<"called from here">
def err_maximum_recursion_depth : Error<"maximum recursion depth of $0 exceeded while evaluating function '$1'">
def err_maximum_branch_depth : Error<"maximum branching depth of $0 exceeded while evaluating function '$1'">
def err_no_definition : Error<"declared function '$0' cannot be evaluated at compile time">
def note_call_chain : Note<"call chain: $0">
def err_fn_called_during_ctfe : Error<"'$0' ${ 1 | select(was called, cannot be called) } during compile time function evaluation">
def err_unreachable_during_ctfe : Error<"'unreachable' instruction encountered during compile time function evaluation">

def note_printf_ctfe : Note<"'printf' encountered during ctfe: $0">

def err_size_not_known : Error<"size of ${ 0 | select(class,struct,enum,union,protocol) } '$1' is not known when requested here">

/* NAMESPACE ERRORS */
def err_namespace_not_found : Error<"namespace $0 does not exist">
def err_namespace_does_not_have_member : Error<"namespace $0 does not define member $1">
def err_import_multiple_with_wildcard : Error<"cannot import multiple items when a wildcard ('*') import is present">

/* CLASS / STRUCT ERRORS */
def err_class_not_accessible : Error<"${ 0 | select(class,struct,enum,union,protocol) } $1 is not accessible">
def err_class_not_found : Error<"class $0 not found">
def err_instantiate_abstract_class : Error<"cannot instantiate abstract class $0">
def err_member_not_found : Error<"${ 0 | select(class,struct,enum,union,protocol,function,method,alias,namespace) } '$1' does not have a member named '$2'">
def err_not_found : Error<"$0 not found">
def err_member_needs_initializing : Error<"member $0 must be initialized in every constructor">
def err_generic_type_not_found : Error<"${ 0 | select(class,struct,enum,union,protocol) } does not have a generic type $1">
def err_generic_type_count : Error<"expected $0 generic type ${ 0 | plural_s(argument) }, $1 given">
def err_generic_type_incompatible : Error<"generic type parameter $0 is not compatible with given type $1">
def err_struct_member_of_self : Error<"structs cannot have members of their own type (use a pointer instead)">
def err_constant_field_setter : Error<"constant fields cannot have a setter">
def err_self_outside_method : Error<"${ 0 | select(self, super, Self) } can only be used in instance methods">
def err_super_without_base : Error<"cannot reference 'super' because class $0 does not have a base class">

def err_no_template_method : Error<"${ 0 | select(class,struct,enum,union,protocol) } $1 does not have a templated method '$2'">

def err_overload_generic_params : Error<"${ 0 | select(function, method) } overloads must have the same template arguments">
def note_overload_generic_params : Note<"previous template argument list declared here">

def err_duplicate_method : Error<"duplicate declaration of ${ 0 | select(function, method) } $1">
def note_duplicate_method : Note<"previous declaration here">

def err_union_initializer_type : Error<"union initializer argument must be convertible to one of the unions types">

def err_enum_initializer : Error<"enums can only be constructed through one of their cases">
def err_protocol_initializer : Error<"protocols cannot be initialized">

def err_circular_data_members : Error<"circular dependency beetween fields of structs $0 and $1">
def note_other_field_here : Error<"dependent field here">

def err_non_static_member_accessed_statically : Error<"static ${ 0 | select(data member, property) } $1 of ${ 2 | select(class,struct,enum,union,protocol) } $3 cannot be accessed statically">

def err_implicit_conformance_cannot_be_declared : Error<"'${ 0 | select(Equatable,Hashable,StringRepresentable) }' conformance cannot be implicitly declared: data member '$1' is not ${ 0 | select(equatable,hashable,string representable) }">

/* PROTOCOL ERRORS */
def err_protocol_not_found : Error<"protocol $0 does not exist">
def err_conforming_to_non_protocol : Error<"$0 is not a protocol">
def err_protocol_property_get_set : Error<"property in protocol must require a getter or setter">
def err_does_not_conform : Error<"${ 0 | select(class, struct, enum, union, protocol) } $1 does not conform to protocol $2">

def err_incorrect_protocol_impl : Error<"${ 0 | select(class, struct, enum, union, protocol) } $1 does not correctly implement protocol $2">
def note_incorrect_protocol_impl_prop : Note<"required property $0 ${ 1 | select(is missing, requires a getter, requires a setter, requires a getter and a setter) }">
def note_incorrect_protocol_impl_method : Note<"required method $0 ${ 1 | select(is missing, has incompatible signature, has incompatible return type) }">
def err_circular_conformance : Error<"circular protocol conformance between $0 and $1">

def note_incorrect_protocol_impl_prop_type : Note<"property '$0' has incompatible type, expected $1 but found $2">

def note_associated_type_missing : Note<"associated type '$0' must be defined">
def err_no_such_associated_type : Error<"${ 0 | select(class, struct, enum, union, protocol) } $1 does not conform to a protocol with an associated type named '$2'">
def err_associated_type_ambiguous : Error<"reference to associated type $0 is ambiguous">

def err_associated_type_no_default : Error<"must specify a type for associated type $0 because it does not have a default type">

def err_constraint_not_satisfied : Error<"unsatisified constraint${ 0 | if(: ) }$1">
def note_constraint_here : Note<"constraint declared here">

/* ENUM ERRORS */
def err_enum_case_not_found : Error<"enum $0 does not define case $1 ${ 2 | if(with the given arguments) }">
def err_enum_case_wrong_no_args : Error<"case $0 requires $1 arguments, $2 given">

/* TUPLE ERRORS */
def err_indexed_prop_on_nun_tuple : Error<"cannot access indexed property on non-tuple type $0">
def err_index_higher_than_arity : Error<"cannot access index $0 on tuple with arity $1">

/* ATTRIBUTE ERRORS */
def err_attr_not_applicable : Error<"attribute $0 is not valid here">

/* INITIALIZATION ERRORS */
def err_not_initialized : Error<"value with no default constructor must be explicitly initialized">
def err_var_redeclaration : Error<"redeclaration of variable $0">
def note_var_redeclaration : Note<"previous declaration is here">
def err_undeclared_identifer : Error<"reference to undeclared identifier $0">

/* ACCESS ERRORS */
def err_private_access : Error<"private ${ 0 | select(variable, function) } $1 is not accessible">
def err_private_member_access : Error<"private member $0 of ${ 1 | select(class, struct, enum,union,protocol) } $2 is not accessible">
def err_protected_member_access : Error<"protected member $0 of ${ 1 | select(class, struct, enum, union,protocol) } $2 is not accessible">

/* KEYWORD ERRORS */
def err_return_outside_func : Error<"keyword 'return' is only allowed in function bodies">
def err_loop_keyword_outside_loop : Error<"keyword '${ 0 | select(continue, break) }' is only valid in loop bodies">

def err_no_type_after_as : Error<"expected type after 'as'">
def err_duplicate_label : Error<"duplicate label '$0'">
def note_duplicate_label : Note<"previous label here">
def err_label_not_found : Error<"no label $0 to go to">
def err_goto_skips_decl : Error<"goto statement cannot jump over variable declaration">
def note_goto_skipped_decl : Note<"skipped declaration of variable $0 here">

def err_static_assert_failed : Error<"static assertion failed${ 0 | if(: ) }$1">
def err_cant_print_expr : Error<"cannot static_print expression of type $0">
def note_static_print : Note<"$0">

/* __traits */
def err_traits_expects_tuple : Error<"__traits(${ 0 | select(arity) }) expects a tuple as its only argument">
def err_traits_expects_int : Error<"__traits(${ 0 | select(bitwidth_of) }) expects an integral type or value">
def err_traits_expects_fp : Error<"__traits(${ 0 | select(fp_precision) }) expects a floating point type or value">

/* OPERATORS */
def err_incompatible_binop_types : Error<"${ 0 | select(left, right) } hand side of binary operator '$1' must be ${ 2 | select(integral, floating point, boolean) }">
def err_binop_not_applicable : Error<"cannot apply binary operator '$0' to values of type $1 and $2">
def err_different_operand_types : Error<"both operands to binary operator '$0' must be of the same type, $1 and $2 given">

def err_unary_op_not_applicable : Error<"cannot apply ${ 0 | select(prefix, postfix) } unary operator '$1' to ${ 2 | select(value, rvalue) } of type $3">
def err_const_unary_op : Error<"mutating unary operator '$0' cannot be applied to a constant value">
def err_dereference_non_pointer : Error<"cannot dereference non-pointer type $0">
def err_reference_non_lvalue : Error<"cannot take address of rvalue of type $0">

def err_unexpected_expression : Error<"unexpected expression; expecting binary operator">

/* MATCH STMT */
def err_match_value_not_equatable : Error<"matched value must be enum or conform to equatable">
def err_invalid_match : Error<"cannot match values of types $0 and $1">

def err_duplicate_case : Error<"duplicate case '$0' in match statement">
def note_duplicate_case : Note<"previous case ${ 0 | select(is here, binds all associated values) }">

def err_continue_from_last_case : Error<"cannot continue from last case in a match statement">
def err_continue_case_with_bound_vals : Error<"cannot continue to case with bound values">

def err_match_not_exhaustive : Error<"match statements must be exhaustive">
def note_missing_case : Error<"case '$0' is either missing or contains expression checks">

/* FUNCTION RETURNS */
def warn_main_return_type : Warning<"return type of 'main' will always be set to i64">
def err_main_invalid_signature : Error<"invalid signature for 'main'">
def err_returning_incomp_type : Error<"returning value of type $0 from function with declared return type $1">
def err_not_all_code_paths_return : Error<"not all code paths return a value">
def err_return_in_noreturn_func : Error<"function that returns an unpopulated type may not return normally">
def err_control_reaches_end_noreturn : Error<"control reaches the end of a noreturn function">
def err_func_redeclaration : Error<"redeclaration of ${ 0 | select(function,method) } $1 with the same signature as a previous declaration">
def note_func_redeclaration_memberwise_init : Note<"previous declaration is the memberwise initializer">
def note_func_redeclaration : Note<"previous declaration is here">

/* LAMBDA EXPRESSIONS */
def err_incomp_arg_counts : Error<"incompatible argument count: expected $0 but got $1">
def err_lambda_arg_default_val : Error<"lambda expression arguments cannot have default values">

def err_lambda_could_not_infer_type_name : Error<"could not infer type of argument '$0'">
def err_lambda_could_not_infer_type : Error<"could not infer type of ${ 0 | ordinal } argument of lambda expression">

/* TYPEDEF */
def err_typedef_generic_not_provided : Error<"generic type $0 not provided for typedef">

/* EXCEPTIONS */
def err_not_throwable : Error<"${ 0 | select(thrown,caught) } value must conform to 'Throwable'">
def err_duplicate_catch : Error<"duplicate type in catch statement">

// mixins
def err_invalid_mixin_kind : Error<"mixin in ${ 0 | select(expression,declaration,statement) } position must form a valid ${ 0 | select(expression,declaration,statement) }">

// backend
def err_llvm_backend : Error<"an error occured in the LLVM backend: '$0'">
