#ifdef CDOT_MSG
#   define CDOT_ERROR(name, msg, fatal) CDOT_MSG(name, msg)
#   define CDOT_WARN(name, msg) CDOT_MSG(name, msg)
#   define CDOT_NOTE(name, msg) CDOT_MSG(name, msg)
#endif

#ifdef CDOT_ERROR
   CDOT_ERROR(_first_err, "", false)
   CDOT_ERROR(err_generic_error, "$0", false)
   CDOT_ERROR(err_invalid_opt_level, "optimization levels higher than $0 are unsupported", false)
   CDOT_ERROR(err_unsupported_opt_level, "unsupported optimization level '$0'", false)
   CDOT_ERROR(err_expected_filename_after, "expected filename after '$0'", false)
   CDOT_ERROR(err_unsupported_argument, "unsupported argument '$0'", false)
   CDOT_ERROR(err_no_source_file, "no source file specified", false)
   CDOT_ERROR(fatal_too_many_errors, "too many errors emmitted, stopping now", true)
   CDOT_ERROR(err_internal_compiler_error, "an internal compiler error occured", false)
   CDOT_ERROR(err_unexpected_eof, "unexpected end of file${ 0 | if(, expecting $1) }", false)
   CDOT_ERROR(err_unexpected_token, "unexpected token $0${ 1 | if(, expecting $2) }", false)
   CDOT_ERROR(err_expecting_decl, "unexpected token $0, expecting ${ 1 | if(top level ) }declaration", false)
   CDOT_ERROR(err_extraneous_paren, "extraneous closing ${ 0 | select(')', '}', ']', '>') }", false)
   CDOT_ERROR(err_invalid_traits, "invalid '__traits' directive '$0'", false)
   CDOT_ERROR(err_duplicate_access_spec, "duplicate access specifier", false)
   CDOT_ERROR(err_vararg_must_be_last, "vararg arguments must come last in a function signature", false)
   CDOT_ERROR(err_vararg_default_value, "varargs may not define a default value", false)
   CDOT_ERROR(err_expected_default_value, "expecting default value", false)
   CDOT_ERROR(err_covar_convar_already_specified, "${ 0 | select(covariance, contravariance) } already specified", false)
   CDOT_ERROR(err_mutating_non_method, "expected method declaration after 'mutating'", false)
   CDOT_ERROR(err_cannot_be_static, "$0 cannot be static", false)
   CDOT_ERROR(err_duplicate_decl_kind, "unexpected declaration keyword", false)
   CDOT_ERROR(err_multiple_inheritance, "only one inheritance clause is allowed", false)
   CDOT_ERROR(err_deinit_args, "deinitializers cannot have arguments", false)
   CDOT_ERROR(err_prop_must_have_type, "property must have a defined type", false)
   CDOT_ERROR(err_prop_must_have_get_or_set, "property must have a getter or a setter", false)
   CDOT_ERROR(err_duplicate_getter_setter, "${ 0 | select(getter, setter) } already declared", false)
   CDOT_ERROR(err_last_match_case_empty, "last case in a match statement may not be empty", false)
   CDOT_ERROR(err_expected_declaration, "expected declaration after '$0'", false)
   CDOT_ERROR(err_declared_with_definition, "'declare'd statements may not have a definition", false)
   CDOT_ERROR(err_bad_extern_kind, "unknown extern kind '$0'", false)
   CDOT_ERROR(err_import_not_at_begin, "'import' statements may only appear at the beginning of a file", false)
   CDOT_ERROR(err_labeled_args_last, "labeled arguments must come last in a function call", false)
   CDOT_ERROR(err_attribute_no_args, "attribute @$0 does not take any arguments", false)
   CDOT_ERROR(err_attribute_arg_count, "attribute @$0 expects ${ 1 | select(at least, at most) } $2 ${ 2 | plural_s(argument) }, $3 given", false)
   CDOT_ERROR(err_attribute_bad_arg, "attribute @$0 expects ${ 1 | select(integer literal, floating point literal, string literal, expression, type, one of '$3') } as ${ 2 | ordinal } argument", false)
   CDOT_ERROR(err_attribute_applicability, "attribute @$0 is not applicable to ${ 1 | select(declarations, statements, expressions, types) }", false)
   CDOT_ERROR(err_attribute_not_valid_here, "attribute @$0 is not allowed here", false)
   CDOT_ERROR(err_implicit_attr_not_valid, "@implicit can only be used on operator function or initializer declarations", false)
   CDOT_ERROR(err_attr_align_bad_arg, "1st argument to @align must be ${ 0 | select(integral, a power of two, greater than or equal to zero) }", false)
   CDOT_ERROR(err_attr_align_lower_than_natural, "alignment value cannot be lower than the natural alignment of a type ($0 < $1)", false)
   CDOT_ERROR(err_attr_align_too_high, "alignment must be 268435456 bytes or smaller", false)
   CDOT_ERROR(err_max_macro_recursion_depth, "maximum macro recursion depth reached ($0) in expansion of macro $1", false)
   CDOT_ERROR(err_type_mismatch, "incompatible types $0 and $1", false)
   CDOT_ERROR(err_no_implicit_conv, "no implicit conversion from $0 to $1", false)
   CDOT_ERROR(err_unexpected_value, "expected $0", false)
   CDOT_ERROR(err_no_explicit_cast, "no known explicit conversion from $0 to $1", false)
   CDOT_ERROR(err_return_type_mismatch, "returned value of type $0 is not compatible with declared return type $1", false)
   CDOT_ERROR(err_cond_not_boolean, "${ 0 | select(if,while,for,ternay operator '?:') } condition must be boolean", false)
   CDOT_ERROR(err_range_not_iterable, "range expression of for-in statement must conform to 'Iterable'", false)
   CDOT_ERROR(err_dict_key_not_hashable, "dictionary keys must conform to 'Hashable'", false)
   CDOT_ERROR(err_requires_contextual_type, "$0 requires a contextual type", false)
   CDOT_ERROR(err_not_string_representable, "value must conform to 'StringRepresentable'", false)
   CDOT_ERROR(err_illegal_subscript, "subscript operator cannot be applied to value of type $0", false)
   CDOT_ERROR(err_subscript_index_not_integral, "subscript indices have to be integral", false)
   CDOT_ERROR(err_cannot_assign_void, "cannot assign value of type void", false)
   CDOT_ERROR(err_reserved_identifier, "$0 is a reserved identifier", false)
   CDOT_ERROR(err_value_not_a_pointer, "value is not a pointer", false)
   CDOT_ERROR(err_type_not_callable, "given type $0 is not callable", false)
   CDOT_ERROR(err_assign_non_mutating_self, "cannot reassign 'self' in a non-mutating method", false)
   CDOT_ERROR(err_assign_to_rvalue, "cannot assign to rvalue of type $0", false)
   CDOT_ERROR(err_type_not_found, "type '$0' not found", false)
   CDOT_ERROR(err_uninitialized_local, "'$0' may be uninitialized when used here", false)
   CDOT_ERROR(err_initialized_more_than_once, "'$0' may be initialized more than once", false)
   CDOT_ERROR(err_reassign_constant, "cannot reassign 'let' constant", false)
   CDOT_ERROR(err_assign_type_mismatch, "cannot assign value of type '$0' to type '$1'", false)
   CDOT_ERROR(err_cast_requires_op, "cast between '$0' and '$1' requires '${ 2 | select(as, as?, as!) }' operator", false)
   CDOT_ERROR(err_access_member_on_type, "cannot access member on value of type $0", false)
   CDOT_ERROR(err_access_member_on_pointer, "cannot access member on pointer, did you mean to use '->'?", false)
   CDOT_ERROR(err_member_access_non_pointer, "cannot apply member access operator '->' to non-pointer type $0", false)
   CDOT_ERROR(err_not_tuple, "cannot access indexed member on type $0", false)
   CDOT_ERROR(err_tuple_arity, "cannot access index $0 on tuple with arity $1", false)
   CDOT_ERROR(err_must_be_integral_constant, "${ 0 | ordinal } argument to ${ 1 | select(function,primitive initializer) } must be an integral constant", false)
   CDOT_ERROR(err_must_be_floating_constant, "${ 0 | ordinal } argument to ${ 1 | select(function,primitive initializer) } must be a floating point constant", false)
   CDOT_ERROR(err_circular_global_value, "type inferred global values $0 and $1 are circularly dependent on each others value", false)
   CDOT_ERROR(err_value_is_not_enum, "type $0 is not an enumeration", false)
   CDOT_ERROR(err_record_is_not_enum, "${ 0 | select(class,struct,enum,union,protocol) } $1 is not an enumeration", false)
   CDOT_ERROR(err_subscript_too_many_indices, "too many indices for subscript operator", false)
   CDOT_ERROR(err_iterator_must_return_option, "'next' function used in for-in must return an 'Option' type", false)
   CDOT_ERROR(err_could_not_infer_arr_element_type, "could not infer array literal element type", false)
   CDOT_ERROR(err_no_builtin_decl, "${ 0 | select(none, optional type, array literal, dictionary literal, string literal) } cannot be used because the declaration for '${ 0 | select(Option, Option, Array, Dictionary, String) }' was not found", false)
   CDOT_ERROR(err_redeclared_symbol, "redeclaration of '$0'${ 1 | if(  as a different kind of symbol) }", false)
   CDOT_ERROR(err_decl_requires_init, "declaration of ${ 0 | select(local, global) } variable with inferred type requires an initializer", false)
   CDOT_ERROR(err_bad_destructure_type, "type $0 cannot be destructured into type $1", false)
   CDOT_ERROR(err_bad_destructure_count, "type $0 cannot be destructured into $1 values", false)
   CDOT_ERROR(err_ambiguous_destructure, "reference to destructuring operator is ambiguous", false)
   CDOT_ERROR(err_func_not_found, "${ 0 | select(function, method) } $1 not found", false)
   CDOT_ERROR(err_no_matching_call, "no matching call for ${ 0 | select(function,method) } $1 found", false)
   CDOT_ERROR(err_cannot_call, "cannot call ${ 0 | select(typedef,namespace) }", false)
   CDOT_ERROR(err_cannot_call_method_on, "cannot call method on value of type $0", false)
   CDOT_ERROR(err_cannot_call_type, "cannot call type $0${ 1 | if(  statically) }", false)
   CDOT_ERROR(err_ambiguous_call, "call to ${ 0 | select(function, method) } '$1' is ambiguous", false)
   CDOT_ERROR(err_ambiguous_reference, "reference to ${ 0 | select(function, method, alias) } $1 is ambiguous", false)
   CDOT_ERROR(err_prop_does_not_have, "property '$0' does not have a ${ 1 | select(getter, setter) }", false)
   CDOT_ERROR(err_incompatible_template_args, "incompatible template arguments for ${ 0 | select(class,struct,enum,union,protocol,alias) } $1", false)
   CDOT_ERROR(err_too_few_args_for_call, "too few arguments for function call, expected $0 but found $1", false)
   CDOT_ERROR(err_too_many_args_for_call, "too many arguments for function call, expected $0 but found $1", false)
   CDOT_ERROR(err_variadic_sizeof_expects, "expected variadic template parameter as argument to 'sizeof...'", false)
   CDOT_ERROR(err_does_not_name_template_parm, "$0 does not name a ${ 1 | if(variadic ) }template parameter", false)
   CDOT_ERROR(err_non_type_param_used_as_type, "non-type template parameter $0 cannot be used as a type", false)
   CDOT_ERROR(err_protocol_template_params, "protocols may not be templated, use associated types instead", false)
   CDOT_ERROR(err_invalid_pack_expansion, "cannot apply pack expansion operator '...' to expression that does not contain a variadic template parameter or argument", false)
   CDOT_ERROR(err_unexpanded_pack, "expression contains unexpanded parameter pack", false)
   CDOT_ERROR(err_template_param_shadow, "template parameter '$0' shadows a template paramater in an enclosing scope", false)
   CDOT_ERROR(err_ctfe_circular_dependence, "functions '$0' and '$1' are circularly dependent on each others definition and cannot be statically evaluated", false)
   CDOT_ERROR(err_maximum_recursion_depth, "maximum recursion depth of $0 exceeded while evaluating function '$1'", false)
   CDOT_ERROR(err_maximum_branch_depth, "maximum branching depth of $0 exceeded while evaluating function '$1'", false)
   CDOT_ERROR(err_no_definition, "declared function '$0' cannot be evaluated at compile time", false)
   CDOT_ERROR(err_fn_called_during_ctfe, "'$0' ${ 1 | select(was called, cannot be called) } during compile time function evaluation", false)
   CDOT_ERROR(err_size_not_known, "size of ${ 0 | select(class,struct,enum,union,protocol) } '$1' is not known when requested here", false)
   CDOT_ERROR(err_namespace_not_found, "namespace $0 does not exist", false)
   CDOT_ERROR(err_namespace_does_not_have_member, "namespace $0 does not define member $1", false)
   CDOT_ERROR(err_import_multiple_with_wildcard, "cannot import multiple items when a wildcard ('*') import is present", false)
   CDOT_ERROR(err_class_not_accessible, "${ 0 | select(class,struct,enum,union,protocol) } $1 is not accessible", false)
   CDOT_ERROR(err_class_not_found, "class $0 not found", false)
   CDOT_ERROR(err_instantiate_abstract_class, "cannot instantiate abstract class $0", false)
   CDOT_ERROR(err_member_not_found, "${ 0 | select(class,struct,enum,union,protocol,function,method,alias,namespace) } '$1' does not have a member named '$2'", false)
   CDOT_ERROR(err_not_found, "$0 not found", false)
   CDOT_ERROR(err_member_needs_initializing, "member $0 must be initialized in every constructor", false)
   CDOT_ERROR(err_generic_type_not_found, "${ 0 | select(class,struct,enum,union,protocol) } does not have a generic type $1", false)
   CDOT_ERROR(err_generic_type_count, "expected $0 generic type ${ 0 | plural_s(argument) }, $1 given", false)
   CDOT_ERROR(err_generic_type_incompatible, "generic type parameter $0 is not compatible with given type $1", false)
   CDOT_ERROR(err_struct_member_of_self, "structs cannot have members of their own type (use a pointer instead)", false)
   CDOT_ERROR(err_constant_field_setter, "constant fields cannot have a setter", false)
   CDOT_ERROR(err_self_outside_method, "${ 0 | select(self, super, Self) } can only be used in instance methods", false)
   CDOT_ERROR(err_super_without_base, "cannot reference 'super' because class $0 does not have a base class", false)
   CDOT_ERROR(err_no_template_method, "${ 0 | select(class,struct,enum,union,protocol) } $1 does not have a templated method '$2'", false)
   CDOT_ERROR(err_overload_generic_params, "${ 0 | select(function, method) } overloads must have the same template arguments", false)
   CDOT_ERROR(err_duplicate_method, "duplicate declaration of ${ 0 | select(function, method) } $1", false)
   CDOT_ERROR(err_union_initializer_type, "union initializer argument must be convertible to one of the unions types", false)
   CDOT_ERROR(err_enum_initializer, "enums can only be constructed through one of their cases", false)
   CDOT_ERROR(err_protocol_initializer, "protocols cannot be initialized", false)
   CDOT_ERROR(err_circular_data_members, "circular dependency beetween fields of structs $0 and $1", false)
   CDOT_ERROR(note_other_field_here, "dependent field here", false)
   CDOT_ERROR(err_non_static_member_accessed_statically, "static ${ 0 | select(data member, property) } $1 of ${ 2 | select(class,struct,enum,union,protocol) } $3 cannot be accessed statically", false)
   CDOT_ERROR(err_implicit_conformance_cannot_be_declared, "'${ 0 | select(Equatable,Hashable,StringRepresentable) }' conformance cannot be implicitly declared: data member '$1' is not ${ 0 | select(equatable,hashable,string representable) }", false)
   CDOT_ERROR(err_protocol_not_found, "protocol $0 does not exist", false)
   CDOT_ERROR(err_conforming_to_non_protocol, "$0 is not a protocol", false)
   CDOT_ERROR(err_protocol_property_get_set, "property in protocol must require a getter or setter", false)
   CDOT_ERROR(err_does_not_conform, "${ 0 | select(class, struct, enum, union, protocol) } $1 does not conform to protocol $2", false)
   CDOT_ERROR(err_incorrect_protocol_impl, "${ 0 | select(class, struct, enum, union, protocol) } $1 does not correctly implement protocol $2", false)
   CDOT_ERROR(err_circular_conformance, "circular protocol conformance between $0 and $1", false)
   CDOT_ERROR(err_no_such_associated_type, "${ 0 | select(class, struct, enum, union, protocol) } $1 does not conform to a protocol with an associated type named '$2'", false)
   CDOT_ERROR(err_associated_type_ambiguous, "reference to associated type $0 is ambiguous", false)
   CDOT_ERROR(err_associated_type_no_default, "must specify a type for associated type $0 because it does not have a default type", false)
   CDOT_ERROR(err_constraint_not_satisfied, "unsatisified constraint${ 0 | if(: ) }$1", false)
   CDOT_ERROR(err_enum_case_not_found, "enum $0 does not define case $1 ${ 2 | if(with the given arguments) }", false)
   CDOT_ERROR(err_enum_case_wrong_no_args, "case $0 requires $1 arguments, $2 given", false)
   CDOT_ERROR(err_indexed_prop_on_nun_tuple, "cannot access indexed property on non-tuple type $0", false)
   CDOT_ERROR(err_index_higher_than_arity, "cannot access index $0 on tuple with arity $1", false)
   CDOT_ERROR(err_attr_not_applicable, "attribute $0 is not valid here", false)
   CDOT_ERROR(err_not_initialized, "value with no default constructor must be explicitly initialized", false)
   CDOT_ERROR(err_var_redeclaration, "redeclaration of variable $0", false)
   CDOT_ERROR(err_undeclared_identifer, "reference to undeclared identifier $0", false)
   CDOT_ERROR(err_private_access, "private ${ 0 | select(variable, function) } $1 is not accessible", false)
   CDOT_ERROR(err_private_member_access, "private member $0 of ${ 1 | select(class, struct, enum,union,protocol) } $2 is not accessible", false)
   CDOT_ERROR(err_protected_member_access, "protected member $0 of ${ 1 | select(class, struct, enum, union,protocol) } $2 is not accessible", false)
   CDOT_ERROR(err_return_outside_func, "keyword 'return' is only allowed in function bodies", false)
   CDOT_ERROR(err_loop_keyword_outside_loop, "keyword '${ 0 | select(continue, break) }' is only valid in loop bodies", false)
   CDOT_ERROR(err_no_type_after_as, "expected type after 'as'", false)
   CDOT_ERROR(err_duplicate_label, "duplicate label '$0'", false)
   CDOT_ERROR(err_label_not_found, "no label $0 to go to", false)
   CDOT_ERROR(err_goto_skips_decl, "goto statement cannot jump over variable declaration", false)
   CDOT_ERROR(err_static_assert_failed, "static assertion failed${ 0 | if(: ) }$1", false)
   CDOT_ERROR(err_cant_print_expr, "cannot static_print expression of type $0", false)
   CDOT_ERROR(err_traits_expects_tuple, "__traits(${ 0 | select(arity) }) expects a tuple as its only argument", false)
   CDOT_ERROR(err_traits_expects_int, "__traits(${ 0 | select(bitwidth_of) }) expects an integral type or value", false)
   CDOT_ERROR(err_traits_expects_fp, "__traits(${ 0 | select(fp_precision) }) expects a floating point type or value", false)
   CDOT_ERROR(err_incompatible_binop_types, "${ 0 | select(left, right) } hand side of binary operator '$1' must be ${ 2 | select(integral, floating point, boolean) }", false)
   CDOT_ERROR(err_binop_not_applicable, "cannot apply binary operator '$0' to values of type $1 and $2", false)
   CDOT_ERROR(err_different_operand_types, "both operands to binary operator '$0' must be of the same type, $1 and $2 given", false)
   CDOT_ERROR(err_unary_op_not_applicable, "cannot apply ${ 0 | select(prefix, postfix) } unary operator '$1' to ${ 2 | select(value, rvalue) } of type $3", false)
   CDOT_ERROR(err_const_unary_op, "mutating unary operator '$0' cannot be applied to a constant value", false)
   CDOT_ERROR(err_dereference_non_pointer, "cannot dereference non-pointer type $0", false)
   CDOT_ERROR(err_reference_non_lvalue, "cannot take address of rvalue of type $0", false)
   CDOT_ERROR(err_unexpected_expression, "unexpected expression; expecting binary operator", false)
   CDOT_ERROR(err_match_value_not_equatable, "matched value must be enum or conform to equatable", false)
   CDOT_ERROR(err_invalid_match, "cannot match values of types $0 and $1", false)
   CDOT_ERROR(err_duplicate_case, "duplicate case '$0' in match statement", false)
   CDOT_ERROR(err_continue_from_last_case, "cannot continue from last case in a match statement", false)
   CDOT_ERROR(err_continue_case_with_bound_vals, "cannot continue to case with bound values", false)
   CDOT_ERROR(err_match_not_exhaustive, "match statements must be exhaustive", false)
   CDOT_ERROR(note_missing_case, "case '$0' is either missing or contains expression checks", false)
   CDOT_ERROR(err_main_invalid_signature, "invalid signature for 'main'", false)
   CDOT_ERROR(err_returning_incomp_type, "returning value of type $0 from function with declared return type $1", false)
   CDOT_ERROR(err_not_all_code_paths_return, "not all code paths return a value", false)
   CDOT_ERROR(err_func_redeclaration, "redeclaration of ${ 0 | select(function,method) } $1 with the same signature as a previous declaration", false)
   CDOT_ERROR(err_incomp_arg_counts, "incompatible argument count: expected $0 but got $1", false)
   CDOT_ERROR(err_lambda_arg_default_val, "lambda expression arguments cannot have default values", false)
   CDOT_ERROR(err_lambda_could_not_infer_type_name, "could not infer type of argument '$0'", false)
   CDOT_ERROR(err_lambda_could_not_infer_type, "could not infer type of ${ 0 | ordinal } argument of lambda expression", false)
   CDOT_ERROR(err_typedef_generic_not_provided, "generic type $0 not provided for typedef", false)
   CDOT_ERROR(err_not_throwable, "${ 0 | select(thrown,caught) } value must conform to 'Throwable'", false)
   CDOT_ERROR(err_duplicate_catch, "duplicate type in catch statement", false)
   CDOT_ERROR(err_invalid_mixin_kind, "mixin in ${ 0 | select(expression,declaration,statement) } position must form a valid ${ 0 | select(expression,declaration,statement) }", false)
   CDOT_ERROR(err_llvm_backend, "an error occured in the LLVM backend: '$0'", false)
   CDOT_ERROR(_last_err, "", false)
#endif
#undef CDOT_ERROR

#ifdef CDOT_WARN
   CDOT_WARN(_first_warn, "")
   CDOT_WARN(warn_generic_warn, "$0")
   CDOT_WARN(warn_inexact_fp, "floating point value cannot be represented exactly")
   CDOT_WARN(warn_implicit_cast, "implicit cast from $0 to $1")
   CDOT_WARN(warn_main_return_type, "return type of 'main' will always be set to i64")
   CDOT_WARN(_last_warn, "")
#endif
#undef CDOT_WARN

#ifdef CDOT_NOTE
   CDOT_NOTE(_first_note, "")
   CDOT_NOTE(note_generic_note, "$0")
   CDOT_NOTE(note_to_match_this, "to match this")
   CDOT_NOTE(note_previous_vararg_here, "previous varargs here")
   CDOT_NOTE(note_previous_init_here, "previous initialization was here")
   CDOT_NOTE(note_uninitialized_declared_here, "was declared here")
   CDOT_NOTE(note_declared_const_here, "'$0' declared as constant here")
   CDOT_NOTE(note_dependent_global_here, "dependent global here")
   CDOT_NOTE(note_previous_decl, "previous declaration here")
   CDOT_NOTE(note_cand_no_implicit_conv, "candidate function not viable: no implicit conversion from $0 to $1 for ${ 2 | ordinal } argument${ 3 | if( (builtin operator candidate)) }")
   CDOT_NOTE(note_cand_no_implicit_conv_inferred, "candidate function not viable: no implicit conversion from $0 to $1 for ${ 2 | ordinal } argument (with template arguments inferred as [$3])")
   CDOT_NOTE(note_cand_failed_constraint, "candidate function not viable because of failed constraint: $0")
   CDOT_NOTE(note_cand_failed_constraint_inferred, "candidate function not viable because of failed constraint: $0 (with template arguments inferred as [$1])")
   CDOT_NOTE(note_cand_invalid_self, "candidate function note viable: 'self' argument has type '$0', '$1' given")
   CDOT_NOTE(note_too_few_arguments, "candidate function not viable: requires at least $0 ${ 0 | plural_s(argument) }, $1 given${ 2 | if( (builtin operator candidate)) }")
   CDOT_NOTE(note_too_many_arguments, "candidate function not viable: requires at most $0 ${ 0 | plural_s(argument) }, $1 given${ 2 | if( (builtin operator candidate)) }")
   CDOT_NOTE(note_too_few_arguments_inferred, "candidate function not viable: requires at least $0 ${ 0 | plural_s(argument) }, $1 given (with template arguments inferred as [$2])")
   CDOT_NOTE(note_too_many_arguments_inferred, "candidate function not viable: requires at most $0 ${ 0 | plural_s(argument) }, $1 given (with template arguments inferred as [$2])")
   CDOT_NOTE(note_could_not_infer_template_arg, "candidate function not viable: could not infer template argument $0")
   CDOT_NOTE(note_inferred_template_arg_conflict, "candidate function not viable: conflicting ${ 0 | select(types,values) } $1 and $2 deduced for template argument $3")
   CDOT_NOTE(note_template_arg_kind_mismatch, "candidate function not viable: expected ${ 0 | select(typename, value, variadic typename, variadic value) } but found ${ 1 | select(typename, value, variadic typename, variadic value) } for ${ 2 | ordinal } argument")
   CDOT_NOTE(note_template_arg_type_mismatch, "candidate function not viable: expected $0 as ${ 1 | ordinal } argument but found $2")
   CDOT_NOTE(note_template_parameter_here, "template parameter declared here")
   CDOT_NOTE(note_too_many_template_args, "expected at most $0 ${ 0 | plural_s(template argument) }, $1 given")
   CDOT_NOTE(note_method_must_be_static, "candidate method not viable: not declared 'static'")
   CDOT_NOTE(note_candidate_is_mutating, "candidate method not viable: is 'mutating', but self parameter is ${ 0 | select(`let` constant, not an lvalue) }")
   CDOT_NOTE(note_candidate_here, "candidate declared here")
   CDOT_NOTE(note_builtin_candidate, "builtin ${ 0 | if(operator ) }candidate")
   CDOT_NOTE(note_instantiation_of, "in instantiation of ${ 0 | select(class,struct,enum,union,protocol,function,method,alias,namespace) } '$1'${ 2 | if(  with template arguments [$3]) }")
   CDOT_NOTE(note_dependency_chain, "chain of dependency: $0")
   CDOT_NOTE(note_called_here, "called from here")
   CDOT_NOTE(note_call_chain, "call chain: $0")
   CDOT_NOTE(note_printf_ctfe, "'printf' encountered during ctfe: $0")
   CDOT_NOTE(note_overload_generic_params, "previous template argument list declared here")
   CDOT_NOTE(note_duplicate_method, "previous declaration here")
   CDOT_NOTE(note_incorrect_protocol_impl_prop, "required property $0 ${ 1 | select(is missing, requires a getter, requires a setter, requires a getter and a setter) }")
   CDOT_NOTE(note_incorrect_protocol_impl_method, "required method $0 ${ 1 | select(is missing, has incompatible signature, has incompatible return type) }")
   CDOT_NOTE(note_incorrect_protocol_impl_prop_type, "property '$0' has incompatible type, expected $1 but found $2")
   CDOT_NOTE(note_associated_type_missing, "associated type '$0' must be defined")
   CDOT_NOTE(note_constraint_here, "constraint declared here")
   CDOT_NOTE(note_var_redeclaration, "previous declaration is here")
   CDOT_NOTE(note_duplicate_label, "previous label here")
   CDOT_NOTE(note_goto_skipped_decl, "skipped declaration of variable $0 here")
   CDOT_NOTE(note_static_print, "$0")
   CDOT_NOTE(note_duplicate_case, "previous case ${ 0 | select(is here, binds all associated values) }")
   CDOT_NOTE(note_func_redeclaration_memberwise_init, "previous declaration is the memberwise initializer")
   CDOT_NOTE(note_func_redeclaration, "previous declaration is here")
   CDOT_NOTE(_last_note, "")
#endif
#undef CDOT_NOTE

#undef CDOT_MSG