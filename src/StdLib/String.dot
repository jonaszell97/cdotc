
using Builtin.Primitive.{ int8, int32, uword, word }
using Extern.C.{ malloc, free }
using Char.ASCII

class String {
    static let DEFAULT_CAPACITY: UInt = 8

    var length: UInt { get }
    var capacity: UInt { get }
    var charArray: int8* { get }

    init {
        length = 0
        capacity = 8
        charArray = malloc(capacity)
    }

    @_builtin(StringInit)
    init (str: int8*, len: UInt) {
        let cap = Math.max(len + 1, DEFAULT_CAPACITY)
        charArray = malloc(cap)
        __builtin_memcpy(charArray, str, len, alignof<uint8* >())

        length = len
        capacity = cap
        zeroTerminate()
    }

    init (len: UInt) {
        let cap = Math.max(len + 1, DEFAULT_CAPACITY)
        charArray = malloc(cap)
        charArray[len] = '\0'
        length = len
        capacity = cap
    }

    init (len: Int) {
        self.init(UInt(len as! uword))
    }

    // must be null terminated
    @_builtin(StringInitCString)
    init (cstring: int8*) {
        let i = 0u
        while cstring[i] != '\0' {
            ++i
        }

        let cap = Math.max(i, DEFAULT_CAPACITY)

        length = i
        capacity = cap
        charArray = malloc(cap)
        __builtin_memcpy(charArray, cstring, i as! uword, alignof<int8>())
    }

    init (c: Char) {
        capacity = DEFAULT_CAPACITY
        charArray = malloc(capacity)
        charArray[0] = c.val
        charArray[capacity - 1] = '\0'
        length = 1
    }

    init (s: String) {
        length = s.length
        capacity = s.capacity
        charArray = malloc(s.capacity + 1)
        __builtin_memcpy(charArray, s.charArray, capacity as! uword, alignof<int8>())
    }

    init (chr: Char, repeat: UInt) {
        let cap = Math.max(repeat + 1, DEFAULT_CAPACITY)

        charArray = malloc(cap)
        for let i in 0u..repeat {
            charArray[i] = chr
        }

        length = repeat
        capacity = cap
        zeroTerminate()
    }

    deinit {
        Extern.C.printf("freeing string '%s'\n", charArray)
        free(charArray)
    }

    private def resize {
        let newStr = malloc(capacity + 1)
        __builtin_memcpy(newStr, charArray, (length + 1) as! uword, alignof<int8>())

        free(charArray)
        charArray = newStr
    }

    private def zeroTerminate() {
        charArray[length] = '\0'
    }

    def postfix [] (index: UInt) -> ref int8 {
        if index >= length {
            throw OutOfBoundsException()
        }
        
        return charArray[index]
    }

    def postfix [] (index: Int) -> ref int8 {
        return self[UInt(index.val as! uword)]
    }

    @_builtin(StringPlusString)
    def infix + (s: String) -> String {
        var copy = String(self)
        copy += s

        return copy
    }

    @_builtin(StringPlusEqualsString)
    def infix += (s: String) {
        let newLen = length + s.length
        if newLen > capacity {
            while newLen > capacity {
                capacity *= 2
            }

            resize()
        }

        __builtin_memcpy(&charArray[length], s.charArray, s.length as! uword, alignof<int8>())
        length = newLen

        zeroTerminate()
    }

    @_builtin(StringPlusStringRepr)
    def infix + (p: StringRepresentable) -> String {
        return "" // self + (p as String)
    }

    @_builtin(StringPlusEqualsStringRepr)
    def mutating infix += (p: StringRepresentable) {
        // self += (p as String)
    }

    def append (c: int8) {
        if length == capacity {
            capacity *= 2
            resize()
        }

        ++length
        charArray[length - 1] = c
        charArray[length] = '\0'
    }

    def substr(begin: UInt, var len: UInt = length) -> String {
        if begin + len > length {
            len = length - begin
        }

        return String(&charArray[begin], len)
    }
}

class StringIterator with Iterator {
    let str: String
    var curr: UInt

    init (str: String) {
        self.str = str
        self.curr = 0
    }

    associatedType Element = Char

    def next -> Char? {
        if curr >= str.length {
            return none
        }
        
        return .Some(Char(str[curr++]))
    }
}

extend String with Iterable {
    associatedType Element = Char
    associatedType It = StringIterator

    def getIterator() -> StringIterator {
        return StringIterator(self)
    }
}

extend String with StringRepresentable {
    def infix as String {
        return String(self)
    }
}

extend String with Hashable {
    /// djb2 hash - see http://www.cse.yorku.ca/~oz/hash.html
    def hashCode -> UInt64 {
        var hash: UInt64 = 5381
        for var i = UInt(); i < length; ++i {
            hash = ((hash << 5) + hash) + UInt(charArray[i] as! uword)
        }

        return hash
    }
}

extend String with Equatable {
    def infix == (s: String) -> Bool {
        if length != s.length {
            return false
        }

        for let i = UInt(); i < length; ++i {
            if charArray[i] != s.charArray[i] {
                return false
            }
        }

        return true
    }
}

extend String with Comparable {
    def infix > (s: String) -> Bool {
        let maxLen = length > s.length ? length : s.length
        for let i = UInt(); i < maxLen; ++i {
            if length <= i {
                return false
            }
            if s.length <= i {
                return true
            }
            if self[i] == s[i] {
                continue
            }
            
            return Bool(self[i] > s[i])
        }

        return false
    }

    def infix < (s: String) -> Bool {
        return !(self > s) && self != s
    }

    def infix >= (s: String) -> Bool {
        return self == s || self > s
    }

    def infix <= (s: String) -> Bool {
        return self == s || self < s
    }
}

extend String with Randomizable {
    enum RandomStringKind {
        case AlphaNumeric
    }

    static def random (length: UInt, kind: RandomStringKind) -> String {
        let str = String(length)
        match kind {
            case .AlphaNumeric:
                for let i in 0u..length {
                    var c: int8 = ASCII.nul
                    while c == ASCII.nul {
                        let next = 48 + (Int.random() % (122 - 48))
                        if !(next > 57 && next < 65) && !(next > 90 && next < 97) {
                            c = next.val as int8
                        }
                    }

                    str[i] = c
                }
        }

        return str
    }

    static def random -> String {
        return random(10, .AlphaNumeric)
    }
}

extend String with Throwable {
    prop description: String { 
        get {
            return self
        }
    }
}

namespace std {
    def toString <T> (t: ref T) -> String {
        static_if T: StringRepresentable {
            return t as String
        } else static_if T: * {
            return UInt(t as! uword) as String
        } else static_if isTuple<T> {
            return tupleToString(t)
        } else static_if __traits(is_integer, T) {
            static_if __traits(is_unsigned, T) {
                return UInt(t as! uword) as String
            } else {
                return Int(t as! word) as String
            }
        } else static_if __traits(is_fp, T) {
            return Double(t as! double) as String
        } else {
            return T.Type.name
        }
    }

    def tupleToString <...Tys> (tup: (Tys...)) -> String {
        var s = "("
        var i = 0u
        
        for let el in tup {
            if i != 0 { s += ", " }
            s += std.toString(el)

            ++i
        }

        s += ")"
        return s
    }
}