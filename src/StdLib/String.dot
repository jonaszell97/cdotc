
using Builtin.Primitive

class String {
    let length: Int { get }
    let charArray: int8* { get }

    public init {
        length = 0
        charArray = null
    }

    public init (str: int8*, len: Int) {
        charArray = str
        length = len
    }

    public def postfix [] (index: Int) -> ref int8 unsafe {
        if (index > length) {
            print("no can do bby doll")
            return '\0'
        }
        
        return &charArray[index]
    }

    public def infix + (s: String) -> String unsafe {
        let newStr = Extern.C.malloc(length + s.length) as int8*

        for (let i = 0; i < length; ++i) {
            newStr[i] = charArray[i]
        }

        for (let i = 0; i < s.length; ++i) {
            newStr[i + length] = s.charArray[i]
        }
        
        return String(newStr, length + s.length)
    }

    public def substr(begin: Int, len: Int = length) -> String unsafe {
        if (begin + len > length) {
            print("Nice try, sucker")
            Extern.C.exit(69.val as Int32)
        }

        let newStr = Extern.C.malloc(len) as int8*
        for (let i = 0; i < len; ++i) {
            newStr[i] = charArray[i + begin]
        }

        return String(newStr, len)
    }
}

class StringIterator with Iterator<Char> {
    let str: String
    var curr: Int

    public init (str: String) {
        self.str = str
        self.curr = 0
    }

    public def next -> Char? {
        if (curr >= str.length) {
            return null
        }

        return Char(str[curr++])
    }
}

extend String with Iterable<Char> {
    public def getIterator -> StringIterator {
        return StringIterator(self)
    }
}