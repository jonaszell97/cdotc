
using Builtin.Primitive.{ int8, int32, uword }
using Extern.C.{ malloc, free }
using Char.ASCII

class String {
    var length: Int { get }
    var charArray: int8* { get }

    init {
        charArray = __nullptr(int8)
        length = 0
    }

    init (str: int8*, len: Int) {
        charArray = str
        length = len
    }

    @_builtin(StringInit)
    init (str: int8*, len: uword) {
        charArray = str
        length = Int(len)
    }

    init (len: Int) {
        charArray = malloc(len + 1)
        charArray[len] = '\0'
        length = len
    }

    // must be null terminated
    init (cstring: int8*) {
        let i = 0
        while cstring[i] != '\0' {
            ++i
        }

        length = i
        charArray = malloc(i)
        __builtin_memcpy(charArray, cstring, i, alignof(int8))
    }

    init (c: Char) {
        charArray = malloc(2)
        charArray[0] = c.val
        charArray[1] = '\0'
        length = 1
    }

    init (s: String) {
        length = s.length
        charArray = malloc(s.length + 1)
        __builtin_memcpy(charArray, s.charArray, length, alignof(int8))
    }

    init (chr: Char, repeat: Int) {
        charArray = malloc(repeat + 1)
        for var i = 0; i < repeat; ++i {
            charArray[i] = chr.val
        }

        charArray[repeat] = '\0'
        length = repeat
    }

    deinit {
        printf("Freeing %s\n", charArray)
        free(charArray)
    }

    def postfix [] (index: Int) -> ref int8 {
        if (index >= length) {
            throw OutOfBoundsException()
        }
        
        return charArray[index]
    }

    def infix + (s: String) -> String {
        var copy = String(self)
        copy += s

        return copy
    }

    def infix += (s: String) {
        let newStr = malloc(length + s.length + 1)

        __builtin_memcpy(newStr, charArray, length, alignof(int8))
        __builtin_memcpy(&newStr[length], s.charArray, s.length, alignof(int8))

        charArray = newStr
        length = length + s.length
    }

    @_builtin(StringConcat)
    def infix + (p: StringRepresentable) -> String {
        return self + (p as String)
    }

    @_builtin(StringConcatEquals)
    def mutating infix += (p: StringRepresentable) {
        self += (p as String)
    }

    def substr(begin: Int, len: Int = length) -> String {
        var copyLen = len
        if (begin + len > length) {
            copyLen = length - begin
        }

        let newStr = malloc(len)
        __builtin_memcpy(newStr, &charArray[begin], copyLen, alignof(int8))

        return String(newStr, len)
    }
}

class StringIterator with Iterator<Char> {
    let str: String
    var curr: Int

    init (str: String) {
        self.str = str
        self.curr = 0
    }

    def next -> Char? {
        if curr >= str.length {
            return none
        }
        
        return .Some(Char(str[curr++]))
    }
}

extend String with Iterable<Char> {
    def getIterator -> StringIterator {
        return StringIterator(self)
    }
}

extend String with StringRepresentable {
    def infix as String {
        return self
    }
}

extend String with Hashable {
    /// djb2 hash - see http://www.cse.yorku.ca/~oz/hash.html
    def hashCode -> UInt64 {
        var hash: UInt64 = 5381
        for var i = 0; i < length; ++i {
            hash = ((hash << 5) + hash) + charArray[i]
        }

        return hash
    }
}

extend String with Equatable {
    def infix == (s: String) -> Bool {
        if length != s.length {
            return false
        }

        for let i = 0; i < length; ++i {
            if charArray[i] != s.charArray[i] {
                return false
            }
        }

        return true
    }

    def infix != (s: String) -> Bool {
        return !(self == s)
    }
}

extend String with Comparable {
    def infix > (s: String) -> Bool {
        let maxLen = length > s.length ? length : s.length
        for let i = 0; i < maxLen; ++i {
            if length <= i {
                return false
            }
            if s.length <= i {
                return true
            }
            if self[i] == s[i] {
                continue
            }
            
            return Bool(self[i] > s[i])
        }

        return false
    }

    def infix < (s: String) -> Bool {
        return !(self > s) && self != s
    }

    def infix >= (s: String) -> Bool {
        return self == s || self > s
    }

    def infix <= (s: String) -> Bool {
        return self == s || self < s
    }
}

extend String with Randomizable {
    enum RandomStringKind {
        case AlphaNumeric
    }

    static def random (length: Int, kind: RandomStringKind) -> String {
        let charArray = malloc(length + 1)
        match kind {
            case .AlphaNumeric:
                for let i in 0..length {
                    var c: int8 = ASCII.nul
                    while c == ASCII.nul {
                        let next = 48 + (Int.random() % (122 - 48))
                        if !(next > 57 && next < 65) && !(next > 90 && next < 97) {
                            c = next.val as int8
                        }
                    }

                    charArray[i] = c
                }
        }

        charArray[length] = '\0'
        return String(charArray, length)
    }

    static def random () -> String {
        return random(10, RandomStringKind.AlphaNumeric)
    }
}

extend String with Throwable {
    prop description: String { 
        get {
            return self
        }
    }
}