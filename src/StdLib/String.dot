
using Builtin.Primitive
using Extern.C

class String {
    var length: Int { get }
    var charArray: int8* { get }

    init() unsafe {
        charArray = 0x0 as int8*
        length = 0
    }

    init (str: int8*, len: Int) {
        charArray = str
        length = len
    }

    init (len: Int) unsafe {
        charArray = malloc(len + 1) as int8*
        charArray[len] = '\0'
        length = len
    }

    init (c: Char) unsafe {
        charArray = malloc(2) as int8*
        charArray[0] = c.val
        charArray[1] = '\0'
        length = 1
    }

    init (chr: Char, repeat: Int) unsafe {
        charArray = Extern.C.malloc(repeat + 1) as int8*
        for var i = 0; i < repeat; ++i {
            charArray[i] = chr.val
        }

        charArray[repeat] = '\0'
        length = repeat
    }

    deinit {
        Extern.C.printf("Deinitializing...\n")
        // Extern.C.free(charArray) FIXME
    }

    def postfix [] (index: Int) -> ref int8 unsafe {
        if (index > length) {
            print("no can do bby doll")
            Extern.C.exit(11 as int32)
            __unreachable
        }
        
        return charArray[index]
    }

    def infix + (p: StringRepresentable) -> String unsafe {
        var copy = String(charArray, length)
        copy += p

        return copy
    }

    def infix += (p: StringRepresentable) unsafe {
        let s = p as String
        let newStr = Extern.C.malloc(length + s.length + 1) as int8*

        for var i = 0; i < length; ++i {
            newStr[i] = charArray[i]
        }

        for var i = 0; i < s.length; ++i {
            newStr[i + length] = s.charArray[i]
        }

        charArray = newStr
        length = length + s.length
        newStr[length] = '\0'
    }

    def substr(begin: Int, len: Int = length) -> String unsafe {
        if (begin + len > length) {
            print("Nice try, sucker")
            Extern.C.exit(69.val as int32)
        }

        let newStr = Extern.C.malloc(len) as int8*
        for var i = 0; i < len; ++i {
            newStr[i] = charArray[i + begin]
        }

        return String(newStr, len)
    }

    def _raw -> int8* {
        return charArray
    }
}

class StringIterator with Iterator<Char> {
    let str: String
    var curr: Int

    init (str: String) {
        self.str = str
        self.curr = 0
    }

    def next -> Char? {
        if curr >= str.length {
            return none
        }
        
        return .Some(Char(str[curr++]))
    }
}

extend String with Iterable<Char> {
    def getIterator -> StringIterator {
        return StringIterator(self)
    }
}

extend String with StringRepresentable {
    def infix as String {
        return self
    }
}

extend String with Hashable {
    /// djb2 hash - see http://www.cse.yorku.ca/~oz/hash.html
    def hashCode -> UInt64 {
        var hash: UInt64 = 5381
        for var i = 0; i < length; ++i {
            hash = ((hash << 5) + hash) + charArray[i]
        }

        return hash
    }
}

extend String with Equatable {
    def infix == (s: String) -> Bool {
        if length != s.length {
            return false
        }

        for let i = 0; i < length; ++i {
            if charArray[i] != s.charArray[i] {
                return false
            }
        }

        return true
    }

    def infix != (s: String) -> Bool {
        return !(self == s)
    }
}

extend String with Comparable {
    def infix > (s: String) -> Bool {
        let maxLen = length > s.length ? length : s.length
        for let i = 0; i < maxLen; ++i {
            if length <= i {
                return false
            }
            if s.length <= i {
                return true
            }
            if self[i] == s[i] {
                continue
            }
            
            return Bool(self[i] > s[i])
        }

        return false
    }

    def infix < (s: String) -> Bool {
        return !(self > s) && self != s
    }

    def infix >= (s: String) -> Bool {
        return self == s || self > s
    }

    def infix <= (s: String) -> Bool {
        return self == s || self < s
    }
}

extend String with Randomizable {
    enum RandomStringKind {
        case AlphaNumeric
    }

    static def random(length: Int, kind: RandomStringKind) -> String {
        srand(time(__nullptr(int64)) as int32)

        let charArray = malloc(length + 1) as int8*
        match kind {
        case .AlphaNumeric:
            for let i in 0..length {
                var c: int8 = '\0'
                while c == '\0' {
                    let next = 48 + (Int.random() % (122 - 48))
                    if !(next > 57 && next < 65) && !(next > 90 && next < 97) {
                        c = next.val as int8
                    }
                }

                charArray[i] = c
            }
        }

        charArray[length] = '\0'
        return String(charArray, length)
    }

    static def random() -> String {
        return String.random(10, RandomStringKind.AlphaNumeric)
    }
}