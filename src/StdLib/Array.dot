
using Builtin.Primitive.*
using Extern.C.{ malloc, free, printf }
using System.Functional.{ Predicate }

class Array<T> {
    static let INITIAL_CAPACITY = 8u

    var raw: T*       { get } = __nullptr
    var capacity: UInt { get } = INITIAL_CAPACITY
    var size: UInt     { get } = 0

    private init (arr: T*, len: UInt) {
        raw = arr
        size = len
        capacity = len
    }

    init (cap: UInt) {
        capacity = cap
        raw = malloc(sizeof<word* >() * capacity) as! T*
    }

    init {
        raw = malloc(sizeof<word* >() * capacity) as! T*
    }

    @inline(always)
    private def copyTo(lhs: T*) {
        for let i in 0u..size {
            lhs[i] = raw[i]
        }
    }

    private def resize (cap: UInt) {
        let newArr = malloc(sizeof<word* >() * cap) as! T*
        copyTo(newArr)
        
        free(raw as! int8*)
        raw = newArr
        capacity = cap
    }

    def push(t: T) {
        if size + 1 > capacity {
            resize(capacity << 1)
        }
        
        raw[size] = t
        ++size
    }

    def push <U, V, ...Ws> (u: U, v: V, ws: Ws...) {
        push(u)
        push(v, ws...)
    }

    def pop -> T {
        let back = raw[size - 1]
        --size
        
        return back
    }

    def reserve (cap: UInt) {
        if capacity > cap {
            return
        }

        resize(cap)
    }

    def first () -> T {
        return raw[0]
    }

    def last () -> T {
        return raw[size - 1]
    }

    def at (i: Int) -> T {
        return self[i]
    }

    def postfix [] (index: UInt) -> ref T {
        if index >= size {
            throw 3
        }

        return raw[index]
    }

    def postfix [] (index: Int) -> ref T {
        return self[index as! UInt]
    }

    def infix + (rhs: Array<T>) -> Array<T> {
        var newArr = Array(raw, size)
        newArr += rhs
        
        return newArr
    }

    def infix += (rhs: Array<T>) {
        var newArr = malloc(size + rhs.size) as! T*

        copyTo(newArr)
        for let i in 0u..rhs.size {
            newArr[i + size] = rhs.raw[i]
        }
        
        free(raw as! int8*)
        raw = newArr
        size = rhs.size + size
        capacity = size
    }
}

extend Array <T> with Iterable {
    class Iterator with Global.Iterator {
        var arr: [T]
        var index: UInt = 0

        associatedType Element = T

        init (_arr: [T]) {
            arr = _arr
        }

        def next -> T? {
            if index >= arr.size {
                return none
            }
            
            return .Some(arr[index++])
        }
    }
    
    associatedType Element = T
    associatedType It = Iterator

    def getIterator () -> Iterator {
        return Iterator(self)
    }
}

extend Array <T> with StringRepresentable where T: StringRepresentable {
    def infix as String {
        return join()
    }

    def join <value Separator: String = ", ",
              value Begin: String = "[",
              value End: String = "]"> () -> String {
        var str = Begin
        var i = 0u

        for let el in self {
            if i++ != 0 { str += Separator }
            str += el as String
        }
        
        return str + End
    }
}

extend Array <T> {
    def forEach <U> (func: (T) -> U) {
        for let el in self {
            func(el)
        }
    }

    def filter (pred: Predicate<T>) -> [T] {
        let arr = Array<T>()
        for let el in self {
            if pred(el) {
                arr.push(el)
            }
        }
    
        return arr
    }

    def map <U> (mapping: (T) -> U) -> [U] {
        let arr = Array<U>()
        for let el in self {
            arr.push(mapping(el))
        }

        return arr
    }

    def flatMap <U> (mapping: (T) -> U) -> [U] where T: class || T: * {
        let arr = Array<U>()
        for let el in self {
            if !__builtin_isnull(el) {
                arr.push(mapping(el))
            }
        }

        return arr
    }
}