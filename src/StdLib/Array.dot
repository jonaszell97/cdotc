
using Builtin.Primitive.{ int8, word, int32 }
using Extern.C.{ malloc, free }

class Array<T> with Iterable<T> {
    static let INITIAL_CAPACITY = 8

    var raw: T*       { get } = __nullptr(T)
    var capacity: Int { get } = INITIAL_CAPACITY
    var size: Int     { get } = 0

    private init (arr: T*, len: Int) {
        raw = arr
        size = len
        capacity = len
    }

    init (cap: Int) {
        capacity = cap
        raw = malloc(sizeof(word*) * capacity) as T*
    }

    init {
        raw = malloc(sizeof(word*) * capacity) as T*
    }

    @inline(always)
    private def copyTo(lhs: T*) {
        for let i in 0..size {
            lhs[i] = raw[i]
        }
    }

    private def resize (cap: Int) {
        let newArr = malloc(sizeof(word*) * cap) as T*
        copyTo(newArr)

        free(raw as int8*)
        raw = newArr
        capacity = cap
    }

    def push(t: T) unsafe {
        if (size + 1 > capacity) {
            resize(capacity << 1)
        }
        
        raw[size] = t
        ++size
    }

    def pop -> T {
        let back = raw[size - 1]
        --size
        
        return back
    }

    def reserve (cap: Int) {
        if capacity > cap {
            return
        }

        resize(cap)
    }

    def first () -> T {
        return raw[0]
    }

    def last () -> T {
        return raw[size - 1]
    }

    def at (i: Int) -> T {
        return self[i]
    }

    def postfix [] (index: Int) -> ref T {
        if (index >= size) {
            print("No can do baby doll")
            System.exit(1)
        }

        return raw[index]
    }

    def infix + (rhs: Array<T>) -> Array<T> {
        var newArr = Array(raw, size)
        newArr += rhs
        
        return newArr
    }

    def infix += (rhs: Array<T>) {
        var newArr = malloc(size + rhs.size) as T*

        copyTo(newArr)
        for let i in 0..rhs.size {
            newArr[i + size] = rhs.raw[i]
        }
        
        free(raw as int8*)
        raw = newArr
        size = rhs.size + size
        capacity = size
    }
}

extend Array with Iterable<T> {
    class Iterator<T> with Global.Iterator<T> {
        let arr: [T]
        var index = 0

        init (_arr: [T]) {
            arr = _arr
        }

        def next -> T? {
            if index >= arr.size {
                return none
            }
            
            return .Some(arr[index++])
        }
    }

    def getIterator() -> Iterator<T> {
        return Iterator<T>(self)
    }
}

//FIXME
// extend Array with StringRepresentable where T: StringRepresentable {
//     def infix as String {
//         var str = "["
//         var i = 0
//         for let el in self {
//             print("hi")
//             str += el as String
//             print("bye")
//             if i < size - 1 {
//                 str += ", "
//             }

//             ++i
//         }
        
//         return str + "]"
//     }
// }

extend Array {
    def forEach (func: (T) -> Void) {
        for let el in self {
            func(el)
        }
    }

    def filter (pred: (T) -> Bool) -> Array<T> {
        let arr = Array<T>()
        for let el in self {
            if !pred(el) {
                arr.push(el)
            }
        }

        return arr
    }
}
