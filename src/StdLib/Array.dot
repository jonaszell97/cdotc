
class Array<T> with Iterable<T> {
    var raw: T* { get }
    var size: Int { get }
    var capacity: Int { get } = 0

    private static def initRaw(arr: ref T*, len: Int) unsafe {
        let newArr: T[len]
        arr = newArr
    }

    init (arr: T*, len: Int) {
        raw = arr
        size = len
        capacity = len
    }

    init (i: Int) {
        capacity = i
        size = 0
        initRaw(raw, i)
    }

    init {
        capacity = 1
        size = 0
        initRaw(raw, 1)
    }

    def push(t: T) unsafe {
        if (size + 1 > capacity) {
            capacity = capacity << 1
            let newArr = Extern.C.malloc(capacity) as T*
            copyTo(newArr)
            
            Extern.C.free(raw as Int8*)
            raw = newArr
        }

        raw[size] = t
        ++size
    }

    def pop -> T {
        let back = raw[size - 1]
        --size
        
        return back
    }

    def reserve (i: Int) unsafe {
        capacity = capacity + i
        let newArr = Extern.C.malloc(capacity) as T*
        copyTo(newArr)

        Extern.C.free(raw as Int8*)
        raw = newArr
    }

    def first -> T {
        return raw[0]
    }

    def last -> T {
        return raw[size - 1]
    }

    def at(i: Int) -> T {
        return self[i]
    }

    def copyTo(lhs: T*) {
        for (let i = 0; i < size; ++i) {
            lhs[i] = raw[i]
        }
    }

    def postfix [](index: Int) -> ref T unsafe {
        if (index >= size) {
            print("No can do baby doll")
            Extern.C.exit(69.val as Int32)
        }

        return raw[index]
    }

    def infix +(rhs: Array<T>) -> Array<T> unsafe {
        var newArr = Array(raw, size)
        newArr += rhs
        
        return newArr
    }

    def infix +=(rhs: Array<T>) unsafe {
        var newArr = Extern.C.malloc(size + rhs.size) as T*
        var i = 0

        copyTo(newArr)
        for (; i < rhs.size; ++i) {
            newArr[i + size] = rhs.raw[i]
        }
        
        Extern.C.free(raw as Int8*)
        raw = newArr
        size = i + size
        capacity = size
    }
}

extend Array with Iterable<T> {
    def getIterator() -> ArrayIterator<T> {
        return ArrayIterator<T>(self)
    }
}

extend Array with StringRepresentable {
    def infix as String {
        return "[]"
    }
}
