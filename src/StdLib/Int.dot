
using Builtin.Primitive

/**
 * Wrapper class for primitive integers,
 * since it is a single element struct there is little to no 
 * runtime overhead
 */
@inline(always)
struct Int with IntegerProtocol {
    var val: int64

    /**
     * Default initializer, usually implicitly called by the compiler
     */
    init (val: int64) {
        self.val = val
    }

    /**
     * This integers value
     */
    def hashCode -> UInt64 {
        return val as UInt64
    }

    /**
     * Adds two integer values
     */
    def infix + (rhs: Int) -> Int {
        return Int(val + rhs.val)
    }

    /**
     * Subtracts two integer values
     */
    def infix - (rhs: Int) -> Int {
        return Int(val - rhs.val)
    }
    
    /**
     * Multiplies two integer values
     */
    def infix * (rhs: Int) -> Int {
        return Int(val * rhs.val)
    }

    /**
     * Diviedes two integer values
     */
    def infix / (rhs: Int) -> Double {
        return val / rhs.val
    }

    /**
     * Calculates the remainder of two integers
     */
    def infix % (rhs: Int) -> Int {
        return Int(val % rhs.val)
    }

    /**
     * Returns the value itself
     */
    def prefix + -> Int {
        return Int(val)
    }

    /**
     * Returns the negated value
     */
    def prefix - -> Int {
        return Int(-val)
    }

    /**
     * Pre-Increment
     */
    def prefix ++ -> Int {
        ++val
        return self
    }

    /**
     * Pre-Decrement
     */
    def prefix -- -> Int {
        --val
        return self
    }

    /**
     * Post-Increment
     */
    def postfix ++ -> Int {
        let tmp = Int(val)
        ++val
        return tmp
    }

    /**
     * Post-Decrement
     */
    def postfix -- -> Int {
        let tmp = Int(val)
        --val
        return tmp
    }

    /**
     * True if and only if both values are equal
     */
    def infix == (rhs: Int) -> Bool { 
        return val == rhs.val
    }

    /**
     * True if and only if both values are not equal
     */
    def infix != (rhs: Int) -> Bool {
        return val != rhs.val
    }

    /**
     * @return Bool
     */
    def infix < (rhs: Int) -> Bool {
        return val < rhs.val
    }

    /**
     * @return Bool
     */
    def infix <= (rhs: Int) -> Bool {
        return val <= rhs.val
    }

    /**
     * @return Bool
     */
    def infix > (rhs: Int) -> Bool {
        return val > rhs.val
    }

    /**
     * @return Bool
     */
    def infix >= (rhs: Int) -> Bool {
        return val >= rhs.val
    }

    /**
     * Returns the primitive integer value
     */
    def infix as Int64 {
        return val
    }

    /**
     * Arithmetic shift left
     */
    def infix << (rhs: Int) -> Int {
        return Int(val << rhs.val)
    }

    /**
     * Arithmetic shift right
     */
    def infix >> (rhs: Int) -> Int {
        return Int(val >> rhs.val)
    }

    /**
     * Logical shift right
     */
    def infix >>> (rhs: Int) -> Int {
        return Int(val >>> rhs.val)
    }

    /**
     * Bitwise 'and'
     */
    def infix & (rhs: Int) -> Int {
        return Int(val & rhs.val)
    }

    /**
     * Bitwise 'or'
     */
    def infix | (rhs: Int) -> Int {
        return Int(val | rhs.val)
    }

    /**
     * Bitwise 'xor'
     */
    def infix ^ (rhs: Int) -> Int {
        return Int(val ^ rhs.val)
    }

    /**
     * Bitwise negation
     */
    def prefix ~ -> Int {
        return Int(~val)
    }

    /**
     * Quadratic root
     */
    def sqrt -> Double {
        return Extern.Llvm.`llvm.sqrt.f64`(val as Double)
    }

    def prefix √ = sqrt

    /**
     * Cubic root
     */
    def cbrt -> Double {
        return Extern.Llvm.`llvm.pow.f64`(val as Double, 1 / 3)
    }

    def prefix ∛ = cbrt
}