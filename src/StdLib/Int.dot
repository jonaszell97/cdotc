
using Builtin.Primitive
using Extern.C

/**
 * Wrapper class for native word-sized integers
 */
@inline(always)
struct Int {
    var val: int64

    def infix as Int64 {
        return val
    }

    def sqrt -> Double {
        return Extern.Llvm.`llvm.sqrt.f64`(val as double)
    }

    def prefix √ = sqrt

    def cbrt -> Double {
        return Extern.Llvm.`llvm.pow.f64`(val as double, 1 / 3)
    }

    def prefix ∛ = cbrt
}

extend Int with Comparable {
    def infix < (rhs: Int) -> Bool {
        return Bool(val < rhs.val)
    }

    def infix <= (rhs: Int) -> Bool {
        return Bool(val <= rhs.val)
    }

    def infix > (rhs: Int) -> Bool {
        return Bool(val > rhs.val)
    }

    def infix >= (rhs: Int) -> Bool {
        return Bool(val >= rhs.val)
    }
}

extend Int with Equatable {
    def infix == (rhs: Int) -> Bool {
        return Bool(val == rhs.val)
    }

    def infix != (rhs: Int) -> Bool {
        return Bool(val != rhs.val)
    }
}

extend Int with Hashable {
    def hashCode -> UInt64 {
        return val as UInt64
    }
}

extend Int with Number {
    def infix + (rhs: Int) -> Int {
        return Int(val + rhs.val)
    }

    def infix - (rhs: Int) -> Int {
        return Int(val - rhs.val)
    }
    
    def infix * (rhs: Int) -> Int {
        return Int(val * rhs.val)
    }

    def infix / (rhs: Int) -> Double {
        return Double(val / rhs.val)
    }

    def infix % (rhs: Int) -> Int {
        return Int(val % rhs.val)
    }

    def prefix + -> Int {
        return Int(val)
    }

    def prefix - -> Int {
        return Int(-val)
    }
    
    def prefix ++ -> Int {
        ++val
        return self
    }

    def prefix -- -> Int {
        --val
        return self
    }

    def postfix ++ -> Int {
        let tmp = Int(val)
        ++val
        return tmp
    }

    def postfix -- -> Int {
        let tmp = Int(val)
        --val
        return tmp
    }

    def infix ** (rhs: Int) -> Double {
        return Extern.Llvm.`llvm.powi.f64`(val as double, rhs.val as int32)
    }
}

extend Int with IntegerProtocol {
    def infix << (rhs: Int) -> Int {
        return Int(val << rhs.val)
    }

    def infix >> (rhs: Int) -> Int {
        return Int(val >> rhs.val)
    }

    def infix >>> (rhs: Int) -> Int {
        return Int(val >>> rhs.val)
    }

    def infix & (rhs: Int) -> Int {
        return Int(val & rhs.val)
    }

    def infix | (rhs: Int) -> Int {
        return Int(val | rhs.val)
    }

    def infix ^ (rhs: Int) -> Int {
        return Int(val ^ rhs.val)
    }

    def prefix ~ -> Int {
        return Int(~val)
    }
}

extend Int with Ordered {
    def next -> Int {
        return advanced(by: 1)
    }

    def prev -> Int {
        return advanced(by: -1)
    }

    def advanced(by: Int) -> Int {
        return self + by
    }
}

extend Int with StringRepresentable {
    def infix as String {
        if val == 0 {
            return "0"
        }

        let negative = val < 0
        var num = val
        if negative {
            num = -num
        }

        var powerOfTen = Math.floor(Math.log10(num as double))
        var strLen = powerOfTen + 1
        if negative {
            strLen = strLen + 1
        }
        
        let str = String(strLen)
        var i = 0
        if negative {
            str[0] = '-'
            ++i
        }

        while powerOfTen > 0 {
            var fits = Math.floor(num / (10 ** powerOfTen).val)
            str[i] = (fits.val + 48) as int8

            num = (num - (fits.val as double) * (10 ** powerOfTen).val) as int64
            --powerOfTen
            ++i
        }

        str[i] = (num + 48) as int8
        return str
    }
}
