
using Builtin.Primitive.*
using Extern.C

struct Float {
    var val: float
}

struct Double {
    static let QNAN = __f64_q_nan
    static let SNAN = __f64_sig_nan

    var val: double

    init (f: float) {
        val = f as double
    }

    #let types = ["Int", "UInt"]
    #let bitwidths = [8, 32, 64]

    #for Ty in types
    #for Width in bitwidths

        init (i: #{Ty + Width}) {
            val = i.val as! double
        }

    #endfor
    #endfor

    #let Ops = [+, -, *, /, **]
    #for Op in Ops

        def infix #{Op} (s: Self) -> Self {
            return Double(val #{Op} s.val)
        }

    #endfor
}

extend Double with Equatable {
    def infix == (rhs: Double) -> Bool {
        return Bool(val == rhs.val)
    }
}

extend Double with Comparable {
    def infix > (rhs: Double) -> Bool {
        return Bool(val > rhs.val)
    }

    def infix >= (rhs: Double) -> Bool {
        return (self > rhs) || self == rhs
    }

    def infix < (rhs: Double) -> Bool {
        return !(self >= rhs)
    }

    def infix <= (rhs: Double) -> Bool {
        return !(self > rhs)
    }
}

extend Double with Ordered {
    def next -> Double {
        return advanced(by: 1)
    }

    def prev -> Double {
        return advanced(by: -1)
    }

    def advanced(by: Int) -> Double {
        return self + Double(by)
    }
}

extend Double with StringRepresentable {
    def toString (precision: UInt) -> String {
        let negative = val < 0.0
        var num = Math.round(self * (10u ** precision))

        if num == 0 {
            return "0." + String(chr: '0', repeat: precision)
        }
        
        if negative {
            num = -num
        }

        var powerOfTen = Math.floor(Math.log10(Double(num.val as double)))
        var strLen = UInt((powerOfTen + 2) as! uword)
        if negative {
            strLen = strLen + 1
        }
        
        let str = String(strLen)
        var i = UInt()
        if negative {
            str[0] = '-'
            ++i
        }
        
        while powerOfTen > 0 {
            if i == strLen - precision - 1 {
                ++i
            }

            var fits = Math.floor((num / (10 ** powerOfTen)) as Double)
            str[i] = (fits + 48) as int8

            num = num - fits * (10 ** powerOfTen)
            --powerOfTen
            ++i
        }

        str[i] = (num + 48) as int8
        str[strLen - precision - 1] = '.'
        
        return str
    }

    def infix as String {
        return toString(2)
    }
}

extend Double with Randomizable {
    static def random(min: Int, max: Int) -> Double {
        let rand = Int.random()
        let range = max - min
        let div = (2 ** 32) / range

        return Double(min + rand / div)
    }

    static def random() -> Double {
        return random(0, 1)
    }
}