
class QueryParam<let name: string,
                 let type: string,
                 let defaultVal: string = "",
                 let exclude: i1 = false,
                 let nullable: i1 = true> {
    let isInnerType: i1 = false
}

class InnerTypeQueryParam<name: string, type: string, defaultVal: string = ""> :
        QueryParam<name, type, defaultVal> {
    override isInnerType = true
}

class IntParam<name: string, defaultVal: string = "", exclude: i1 = false> :
    QueryParam<name, "int", defaultVal, exclude>
class UIntParam<name: string, defaultVal: string = "", exclude: i1 = false> :
    QueryParam<name, "unsigned", defaultVal, exclude>
class BoolParam<name: string, defaultVal: string = "", exclude: i1 = false> :
    QueryParam<name, "bool", defaultVal, exclude>
class TypeParam<name: string, defaultVal: string = "", exclude: i1 = false> :
    QueryParam<name, "QualType", defaultVal, exclude>
class CanTypeParam<name: string, defaultVal: string = "", exclude: i1 = false> :
    QueryParam<name, "CanType", defaultVal, exclude>
class SourceTypeParam<name: string, exclude: i1 = false> :
    QueryParam<name, "ast::SourceType", "", exclude>
class StringParam<name: string, defaultVal: string = "", exclude: i1 = false> :
    QueryParam<name, "StringRef", defaultVal, exclude>
class DeclParam<name: string, exclude: i1 = false, nullable: i1 = false> :
    QueryParam<name, "ast::Decl*", "", exclude, nullable>
class NamedDeclParam<name: string, exclude: i1 = false, nullable: i1 = false> :
    QueryParam<name, "ast::NamedDecl*", "", exclude, nullable>
class RecordDeclParam<name: string, defaultVal: string = "", exclude: i1 = false, nullable: i1 = false> : QueryParam<name, "ast::RecordDecl*", defaultVal, exclude, nullable>
class ProtocolDeclParam<name: string, exclude: i1 = false, nullable: i1 = false> :
    QueryParam<name, "ast::ProtocolDecl*", "", exclude, nullable>
class AliasDeclParam<name: string, exclude: i1 = false, nullable: i1 = false> :
    QueryParam<name, "ast::AliasDecl*", "", exclude, nullable>
class FunctionDeclParam<name: string, exclude: i1 = false, nullable: i1 = false> :
    QueryParam<name, "ast::FunctionDecl*", "", exclude, nullable>
class MethodDeclParam<name: string, exclude: i1 = false, nullable: i1 = false> :
    QueryParam<name, "ast::MethodDecl*", "", exclude, nullable>
class CallableDeclParam<name: string, exclude: i1 = false, nullable: i1 = false> :
    QueryParam<name, "ast::CallableDecl*", "", exclude, nullable>
class DeclContextParam<name: string, defaultVal: string = "",
                       exclude: i1 = false, nullable: i1 = false> :
    QueryParam<name, "ast::DeclContext*", defaultVal, exclude, nullable>
class StreamParam<name: string, exclude: i1 = false> :
    QueryParam<name, "llvm::raw_ostream&", "", exclude>
class ArrayParam<name: string, type: string, exclude: i1 = false> :
    QueryParam<name, type, "", exclude>
class MutableArrayParam<name: string, type: string, exclude: i1 = false> :
    QueryParam<name, type, "", exclude>
class OptionalParam<name: string, type: string, exclude: i1 = false> :
    QueryParam<name, type, "", exclude>
class DeclNameParam<name: string, exclude: i1 = false> :
    QueryParam<name, "DeclarationName", "", exclude>
class OtherQueryParam<name: string, exclude: i1 = false, nullable: i1 = false> :
    QueryParam<name, "Query*", "", exclude, nullable>
class TemplateArgsParam<name: string, defaultVal: string = "", exclude: i1 = false> :
    QueryParam<name, "sema::FinalTemplateArgumentList*", defaultVal, exclude>
class MultiLevelTemplateArgsParam<name: string, exclude: i1 = false> :
    QueryParam<name, "sema::MultiLevelFinalTemplateArgList", "", exclude>

class FunctionRefParam<name: string, type: string, defaultVal: string = "", exclude: i1 = false> : QueryParam<name, type, defaultVal, exclude>

class ILConstantParam<name: string, exclude: i1 = false> :
    QueryParam<name, "il::Constant*", "", exclude>

class NameSpecWithLocParam<name: string, exclude: i1 = false> :
    QueryParam<name, "NestedNameSpecifierWithLoc*", "", exclude>

class SourceRangeParam<name: string, defaultVal: string = "", exclude: i1 = false> :
    QueryParam<name, "SourceRange", defaultVal, exclude>

class SourceLocParam<name: string, defaultVal: string = "", exclude: i1 = false> :
    QueryParam<name, "SourceLocation", defaultVal, exclude>

class Query<let type: string> {
    /// Parameters that this query takes.
    let parameters: list<QueryParam> = []

    /// True if this is query should be implemented with a function instead of a class.
    let simpleQuery: i1 = false

    /// True iff the result of this query can be cached for later use.
    let canBeCached: i1 = true

    /// True iff the result of this query can be serialized for use in incremental compilation.
    let canBeSerialized: i1 = false

    /// True iff this query never has any dependencies.
    let pure: i1 = false

    /// True iff this query can never fail.
    let infallible: i1 = false

    /// True iff the result value should be moved.
    let shouldMoveResult: i1 = false

    /// If true, ignore circular dependencies for queries of this kind.
    let ignoreCircularDependency: i1 = false

    /// The return type of the `get` method of this query, defaults to the normal type.
    let getReturnType: string = type

    /// Type to use as a key for the DenseMap, if the query takes a single parameter.
    let customKeyType: string = ""

    /// If not empty, code for a custom get method.
    let customGet: code = {}

    /// If not empty, code for custom assigning from the cached value.
    let customAssign: code = {}

    /// Custom code to insert into the 'finish' method.
    let customFinish: code = {}

    /// Custom code to be inserted at the beginning of the class declaration.
    let customHeaderCode: code = {}

    /// Custom code to run in the class constructor.
    let constructorCode: code = {}

    /// Custom code to be inserted with the class implementation.
    let customImplCode: code = {}

    /// Custom code to be inserted before the result of the query is returned.
    let customPreReturnCode: code = {}

    /// Custom code to be inserted at the start of the 'run' function.
    let earlyExitCode: code = {}

    /// Brief description of the nature of this query.
    let description: string = "running $NAME"

    /// If true, this query can only be constructed within other queries.
    let private: i1 = false

    /// True iff this query can be type or value dependent.
    let canBeDependent: i1 = false

    /// Persistent declarations to be inserted into the QueryContext.
    let persistentState: code = {}

    /// A condition that indicates whether or not a query should be refreshed.
    let refreshCondition: code = {}

    /// Code that is run when the query is refreshed.
    let onRefresh: code = {}

    /// The trailing object types that this query inherits from.
    let trailingObjects: list<string> = []
}

class VoidQuery : Query<"void">
class BoolQuery : Query<"bool">
class IntQuery : Query<"uint64_t">
class StringQuery : Query<"llvm::StringRef">

/// *** Top level compilation queries. ***

/// Compile all source files and create a module file.
def CompileModule : VoidQuery {
    // All parameters are taken from CompilerOptions.
    parameters = []
    description = "compiling module ${QC.CI.getCompilationModule()->getName()->getIdentifier()}"
}

/// Parse the module file.
def ParseModuleFile : Query<"Module*"> {
    parameters = [
        StringParam<"FileName">
    ]
}

/// Create a default module for a compilation without a module file.
def CreateDefaultModule : Query<"Module*"> {
    parameters = []
}

/// Parse a source file into a SourceFileDecl.
def ParseSourceFile : Query<"ast::SourceFileDecl*"> {
    parameters = [
        // The base module of the compilation.
        QueryParam<"Mod", "Module*">,

        // Filename of the source file to parse.
        StringParam<"FileName">
    ]

    description = "parsing source file $FileName"
}

/// Parse the main source file into a SourceFileDecl.
def ParseMainSourceFile : Query<"ast::SourceFileDecl*"> {
    parameters = [
        // The base module of the compilation.
        QueryParam<"Mod", "Module*">,

        // Filename of the source file to parse.
        StringParam<"FileName">
    ]

    description = "parsing source file $FileName"
}

/// Parse the source files contained in this module.
def ParseSourceFiles : VoidQuery {
    parameters = [
        // The base module of the compilation.
        QueryParam<"Mod", "Module*">
    ]
}

/// Create an IL Module from a typechecked AST.
def CreateILModule : Query<"il::Module*"> {
    parameters = [
        // The base module of the compilation.
        QueryParam<"Mod", "Module*">
    ]

    description = "creating IL module"
}

/// Setup the IRGen class.
def SetupIRGen : Query<"std::unique_ptr<il::IRGen>"> {
    shouldMoveResult = true
    getReturnType="il::IRGen*"
    customGet = {
        return Result.getValue().get();
    }

    description = "setting up IRGen"
}

/// Create an LLVM module from an IL module.
def CreateLLVMModule : Query<"llvm::Module*"> {
    parameters = [
        // The base module of the compilation.
        QueryParam<"Mod", "Module*">
    ]

    description = "creating LLVM module"
}

/// Create an object file from an LLVM module.
def CreateObject : VoidQuery {
    parameters = [
        // Stream that the object should be written to.
        StreamParam<"OS">
    ]

    canBeCached = false
    description = "creating object file"
}

/// Create a static library from one or more object files.
def CreateStaticLib : VoidQuery {
    parameters = [
        // File of the output static library.
        StringParam<"OutFile">
    ]

    canBeCached = false
    description = "creating static library '$OutFile'"
}

/// Create a dynamic library from one or more object files.
def CreateDynamicLib : VoidQuery {
    parameters = [
        // File of the output dynamic library.
        StringParam<"OutFile">
    ]

    canBeCached = false
    description = "creating dynamic library '$OutFile'"
}

/// Create an executable file from an LLVM module.
def CreateExecutable : VoidQuery {
    parameters = [
        // File of the output executable.
        StringParam<"OutFile">
    ]

    canBeCached = false
    description = "creating executable '$OutFile'"
}

/// Emit an IL module containing the passed source file.
def EmitIL : VoidQuery {
    parameters = [
        // Stream to write the module to.
        StreamParam<"OS">
    ]

    canBeCached = false
    description = "emitting IL module"
}

/// Emit an IR module containing the passed source file.
def EmitIR : VoidQuery {
    parameters = [
        // Stream to write the module to.
        StreamParam<"OS">
    ]

    canBeCached = false
    description = "emitting IR module"
}

/// Print the memory that is currently allocated in global arenas.
def PrintUsedMemory : VoidQuery {
    canBeCached = false
    description = "printing used memory"
}

/// Execute another query and time the result.
def MeasureExecutionTime : Query<"long long"> {
    parameters = [
        // The query to time.
        OtherQueryParam<"Q">
    ]

    description = "measuring execution time of query '${Q->description()}'"
}

/// *** Type related queries. ***

/// Helper class for trivial type related queries.
class TypeMetaQuery : BoolQuery {
    override parameters = [
        // The type to calculate meta info about.
        CanTypeParam<"T">
    ]

    override description = "checking $NAME on ${T.toDiagString()}"
    override canBeDependent = true
}

def IsPersistable : TypeMetaQuery
def IsEquatable : TypeMetaQuery
def IsCopyable : TypeMetaQuery
def IsMoveOnly : TypeMetaQuery
def IsUnpopulated : TypeMetaQuery
def IsImplicitlyCopyable : TypeMetaQuery
def IsTriviallyCopyable : TypeMetaQuery
def NeedsRetainOrRelease : TypeMetaQuery
def NeedsDeinitilization : TypeMetaQuery
def NeedsStructReturn : TypeMetaQuery
def PassByValue : TypeMetaQuery
def ContainsProtocolWithAssociatedTypes : TypeMetaQuery
def ContainsTemplate : TypeMetaQuery
def ContainsAssociatedTypeConstraint : TypeMetaQuery

def IsImplicitlyConvertible : Query<"IsImplicitlyConvertibleQuery::ResultType"> {
    parameters = [
        TypeParam<"From">,
        TypeParam<"To">
    ]

    simpleQuery = true
    canBeDependent = true

    customHeaderCode = {
    public:
        struct ResultType {
            /// Whether or not the types are implicitly convertible.
            bool implicitlyConvertible;

            /// The conversion penalty.
            unsigned conversionPenalty;
        };
    }
}

def IsValidParameterValue : Query<"IsValidParameterValueQuery::ResultType"> {
    parameters = [
        TypeParam<"givenType">,
        TypeParam<"paramType">,
        BoolParam<"isSelf", "false">
    ]

    simpleQuery = true
    canBeDependent = true

    customHeaderCode = {
    public:
        struct ResultType {
            /// Whether or not the types are implicitly convertible.
            bool isValid;

            /// The conversion penalty.
            unsigned conversionPenalty;
        };
    }
}

def GetConversionSequence : Query<"ConversionSequence*"> {
    parameters = [
        TypeParam<"From">,
        TypeParam<"To">
    ]

    simpleQuery = true
    canBeDependent = true
}

/// Substitute all type variable types within a type.
def SubstTypeVariables : Query<"QualType"> {
    parameters = [
        // The type potentially containing type variables.
        TypeParam<"T">,

        // The map of concrete type assignments.
        QueryParam<"ReplacementMap", "const llvm::DenseMap<TypeVariableType*, QualType>&", "", true>,

        // The location where the substitution was requested.
        QueryParam<"SR", "SourceRange", "", /*exclude=*/true>
    ]

    simpleQuery = true
    canBeCached = false
}

/// Substitute all protocol associated types within a type to concrete ones.
def SubstAssociatedTypes : Query<"QualType"> {
    parameters = [
        // The type containing protocol associated types.
        TypeParam<"T">,

        // The 'Self' type.
        TypeParam<"Self">,

        // The location where the substitution was requested.
        QueryParam<"SR", "SourceRange", "", /*exclude=*/true>
    ]

    description = "substituting ${T.toDiagString()} with Self = ${Self.toDiagString()}"
    refreshCondition = {
        Self && Self->isRecordType() && QC.Sema->IsBeingResolved(Self->getRecord())
    }
}

/// Substitute all generic types within a type.
def SubstTemplateParamTypes : Query<"QualType"> {
    parameters = [
        // The type containing protocol associated types.
        TypeParam<"T">,

        // The template argument list.
        MultiLevelTemplateArgsParam<"TemplateArgs">,

        // The location where the substitution was requested.
        QueryParam<"SR", "SourceRange", "", /*exclude=*/true>
    ]

    description = "substituting ${T.toDiagString()} with TemplateArgs = ${TemplateArgs.toString()}"
}

/// Substitute all generic types within a type.
def SubstTemplateParamTypesNonFinal : Query<"QualType"> {
    parameters = [
        // The type containing protocol associated types.
        TypeParam<"T">,

        // The template argument list.
        QueryParam<"TemplateArgs", "const sema::MultiLevelTemplateArgList&">,

        // The location where the substitution was requested.
        QueryParam<"SR", "SourceRange", "", /*exclude=*/true>
    ]

    description = "substituting ${T.toDiagString()} with TemplateArgs = ${TemplateArgs.toString()}"

    // Caching this is usually not worth it.
    canBeCached = false
    simpleQuery = true
}

/// Check the capabilities of a context that are added via constraints.
def CheckTypeCapabilities : Query<"std::vector<TypeCapability>"> {
    parameters = [
        // The context to check.
        NamedDeclParam<"ND">
    ]

    getReturnType = "ArrayRef<TypeCapability>"
    shouldMoveResult = true
}

/// *** Builtin declaration lookup queries. ****

def GetBuiltinModule : Query<"Module*"> {
    customHeaderCode = {
    public:
        enum ModuleKind : char {
            Std,
            Prelude,
            Builtin,
            Reflect,
            Sys,
            Runtime,
            Async,
            Test,
            Policy,
            Atomic,
        };

    private:
        llvm::DenseMap<char, Module*> Cache;
    }

    parameters = [
        // The module to lookup.
        InnerTypeQueryParam<"Mod", "ModuleKind">
    ]

    customKeyType = "char"
}

def GetBuiltinFunc : Query<"ast::CallableDecl*"> {
    customHeaderCode = {
    public:
        enum FunctionKind : char {
            PureVirtual,
            CopyClass,
            AtomicRelease,
        };

    private:
        llvm::DenseMap<char, ast::CallableDecl*> Cache;
    }

    parameters = [
        // The function to lookup.
        InnerTypeQueryParam<"Fn", "FunctionKind">
    ]

    customKeyType = "char"
}

def GetBuiltinAlias : Query<"ast::AliasDecl*"> {
    customHeaderCode = {
    public:
        enum AliasKind: uint8_t {
            /// The default type for signed integer literals.
            DefaultSignedIntegerLiteralType,

            /// The default type for unsigned integer literals.
            DefaultUnsignedIntegerLiteralType,

            /// The default type for floating point literals.
            DefaultFloatingPointLiteralType,

            /// The default type for boolean literals.
            DefaultBooleanLiteralType,

            /// The default type for character literals.
            DefaultCharacterLiteralType,

            /// The default type for string literals.
            DefaultStringLiteralType,

            /// The default type for array literals.
            DefaultArrayLiteralType,

            /// The default type for dictionary literals.
            DefaultDictionaryLiteralType,
        };
    }

    parameters = [
        // The function to lookup.
        InnerTypeQueryParam<"K", "AliasKind">,

        // The context to look up in.
        DeclContextParam<"DC", "nullptr", false, true>
    ]

    customKeyType = "uint8_t"
}

def GetBuiltinRecord : Query<"ast::RecordDecl*"> {
    customHeaderCode = {
    public:
        enum RecordKind: uint32_t {
            Bool,
            Character,
            Int8, UInt8,
            Int16, UInt16,
            Int32, UInt32,
            Int64, UInt64,
            Int128, UInt128,
            Float, Double,

            UnsafePtr, UnsafeMutablePtr,
            UnsafeRawPtr, UnsafeMutableRawPtr,
            UnsafeBufferPtr, UnsafeMutableBufferPtr,

            Array,
            Dictionary,
            Atomic,
            String, StringBuffer, StringStorage,
            Option,
            Box,
            Promise,
            Future,
            CoroHandle,

            TypeInfo,
            ValueWitnessTable,
            ProtocolConformance,
            ExistentialContainer,
        };
    }

    parameters = [
        // The record to lookup.
        InnerTypeQueryParam<"R", "RecordKind">
    ]

    customKeyType = "uint32_t"
}

def GetBuiltinProtocol : Query<"ast::ProtocolDecl*"> {
    customHeaderCode = {
    public:
        enum ProtocolKind : char {
            Any,
            Equatable,
            Hashable,
            Copyable,
            MoveOnly,
            ImplicitlyCopyable,
            StringRepresentable,
            Persistable,
            Awaiter,
            Awaitable,
            TruthValue,
            RawRepresentable,
            Dereferenceable,
            Unwrappable,
        };
    }

    parameters = [
        // The record to lookup.
        InnerTypeQueryParam<"P", "ProtocolKind">
    ]

    customKeyType = "char"
}

/// *** Sema queries. ***

/// Find a precedence group with the given name.
def FindPrecedenceGroup : Query<"ast::PrecedenceGroupDecl*"> {
    parameters = [
        // Name of the precedence group.
        DeclNameParam<"Name">,

        // If true, a diagnostic will be issued if the precedence group was not found.
        BoolParam<"DiagOnError", "true">,
        SourceRangeParam<"Loc", "SourceRange()", true>
    ]

    // This *can* be cached, since precedence groups are always visible at the top level.
    canBeCached = true

    description = "looking up precedence group '${Name.toString()}'"
}

/// Find an operator declaration with the given name and fix.
def FindOperator : Query<"ast::OperatorDecl*"> {
    parameters = [
        // Name of the operator.
        DeclNameParam<"Name">,

        // If true, a diagnostic will be issued if the operator was not found.
        BoolParam<"DiagOnError", "true">,
        SourceRangeParam<"Loc", "SourceRange()", true>
    ]

    description = "looking up operator '${Name.toString()}'"
}

/// Resolve an `import` declaration.
def ResolveImport : VoidQuery {
    parameters = [
        // The import declaration to resolve.
        QueryParam<"I", "ast::ImportDecl*">,

        // If not null, used declarations are added to this vector.
        QueryParam<"FoundDecls", "llvm::SmallVectorImpl<ast::NamedDecl*>*", "nullptr", true>
    ]

    ignoreCircularDependency = true
}

/// Resolve a `using` declaration.
def ResolveUsing : VoidQuery {
    parameters = [
        // The using declaration to resolve.
        QueryParam<"U", "ast::UsingDecl*">,

        // If not null, used declarations are added to this vector.
        QueryParam<"FoundDecls", "llvm::SmallVectorImpl<ast::NamedDecl*>*", "nullptr", true>
    ]

    ignoreCircularDependency = true
}

/// Resolve a `static if` declaration.
def ResolveStaticIf : Query<"ast::Decl*"> {
    parameters = [
        // The declaration to resolve.
        QueryParam<"Decl", "ast::StaticIfDecl*">
    ]

    ignoreCircularDependency = true
}

/// Resolve a `static for` declaration.
def ResolveStaticFor : Query<"ast::Decl*"> {
    parameters = [
        // The declaration to resolve.
        QueryParam<"Decl", "ast::StaticForDecl*">
    ]

    ignoreCircularDependency = true
}

/// Resolve a `static assert` declaration.
def ResolveStaticAssert : VoidQuery {
    parameters = [
        // The declaration to resolve.
        QueryParam<"Decl", "ast::StaticAssertDecl*">
    ]

    ignoreCircularDependency = true
}

/// Resolve a `static print` declaration.
def ResolveStaticPrint : VoidQuery {
    parameters = [
        // The declaration to resolve.
        QueryParam<"Decl", "ast::StaticPrintDecl*">
    ]

    ignoreCircularDependency = true
}

/// Resolve a static expression to a value.
def ResolveStaticExpr : Query<"il::Constant*"> {
    parameters = [
        // The expression to resolve.
        QueryParam<"Expr", "ast::StaticExpr*">
    ]
}

/// Resolve a static expression to a boolean value.
def ResolveStaticExprToBool : BoolQuery {
    parameters = [
        // The expression to resolve.
        QueryParam<"Expr", "ast::StaticExpr*">,

        // Whether or not a diagnostic should be issued if the value is not boolean.
        BoolParam<"DiagOnError">
    ]
}

/// Expand a single macro.
def ExpandMacro : Query<"StmtOrDecl"> {
    parameters = [
        /// The dependent StmtOrDecl.
        QueryParam<"SOD", "StmtOrDecl">,

        /// Name of the macro.
        DeclNameParam<"Name">,

        /// The context to lookup in.
        DeclContextParam<"DC">,

        /// The macro delimiter.
        UIntParam<"Delim">,

        /// The expansion tokens.
        ArrayParam<"Tokens", "lex::Token">,

        /// The expected AST node kind.
        UIntParam<"ExpectedKind">
    ]

    description = "expanding macro '${Name.toString()}'"
}

/// Expand a single macro declaration.
def ExpandMacroDecl : Query<"ast::Decl*"> {
    parameters = [
        QueryParam<"Decl", "ast::MacroExpansionDecl*">
    ]

    ignoreCircularDependency = true
}

/// Expand the top level macros in a source file.
def ExpandMacros : VoidQuery {
    parameters = [
        StringParam<"SourceFile">
    ]
}

/// Import an external header.
def ImportExternalSourceFile : VoidQuery {
    parameters = [
        /// The file name of the header.
        StringParam<"FileName">,

        /// The header kind.
        QueryParam<"Kind", "ImportExternalSourceFileQuery::HeaderKind">,

        /// The context to import the declarations into.
        DeclContextParam<"DC">,

        /// The location where the header was imported.
        SourceLocParam<"Loc">

        /// Whether or not the file is optional.
        BoolParam<"Optional", "false">
    ]

    customHeaderCode = {
    public:
        enum HeaderKind {
            /// A C header.
            C,

            /// A C++ header.
            CXX,

            /// A C system header.
            CSystem,
        };
    }
}

/// Assign all extensions to the type they extend.
def FindExtensions : VoidQuery {
    parameters = [
        /// The type whose extensions we are looking for.
        TypeParam<"T">
    ]
}

/// Get the 'Kind' of type that an extension extends.
def GetExtensionTypeKind : Query<"GetExtensionTypeKindQuery::ResultKind"> {
    parameters = [
        /// The extension declaration.
        SourceTypeParam<"T">
    ]

    customHeaderCode = {
    public:
        enum ResultKind {
            /// Extends a nominal type.
            Nominal,

            /// Extends a builtin type.
            Builtin,

            /// Extends a pointer type.
            Pointer,

            /// Extends a tuple type.
            Tuple,

            /// Extends a function type.
            Function,

            /// Extends an array type.
            Array,
        };
    }
}

/// Match a given type against a source type.
def MatchExtensionType : Query<"MatchExtensionTypeQuery::ResultKind"> {
    parameters = [
        /// The given type.
        TypeParam<"T">,

        /// The source type to match it against.
        SourceTypeParam<"PatternTy">
    ]

    customHeaderCode = {
    public:
        enum ResultKind {
            /// The extension applies only to this declaration.
            AppliesDirectly,

            /// The extension applies to this and possibly other declarations.
            Applies,

            /// The extension might apply, but we can't tell for sure.
            MightApply,

            /// The extension can't possibly apply.
            DoesNotApply
        };
    }
}

/// Check if an extension applies (or could possibly apply) to a type.
def ExtensionApplies : Query<"MatchExtensionTypeQuery::ResultKind"> {
    parameters = [
        /// The extension declaration.
        QueryParam<"Ext", "ast::ExtensionDecl*">,

        /// The type to check.
        TypeParam<"T">
    ]
}

/// Get the declaration (alias or record) extended by an extension, if it exists.
def GetExtendedDecl : Query<"ast::NamedDecl*"> {
    parameters = [
        /// The source type of the extension.
        SourceTypeParam<"ExtendedTy">
    ]
}

/// Resolve a single extension.
def ResolveExtension : VoidQuery {
    parameters = [
        // The extension to resolve.
        QueryParam<"Ext", "ast::ExtensionDecl*">
    ]
}

/// Get the 'capabilities' that a constrained extension adds to associated types.
// def GetExtensionCapabilities : Query<"ArrayRef<GetExtensionCapabilitiesQuery::Capability>"> {
//     customHeaderCode = {
//     public:
//         struct Capability {
//             /// The nested name specifier that this capability applies to.
//             NestedNameSpecifier *NameSpec;

//             /// The constraint that describes the added capability.
//             DeclConstraint *C;

//             Capability(NestedNameSpecifier *NameSpec, DeclConstraint *C);
//         };
//     }
// }

/// Resolve a declared conformance to a protocol declaration.
def ResolveConformanceToProtocol : Query<"ast::ProtocolDecl*"> {
    parameters = [
        // The type that the conformance was declared on.
        TypeParam<"T">,

        // The type of the conformance as it appeared in the source.
        QueryParam<"Conf", "const ast::SourceType&">
    ]

    description = "resolving conformance of '${T.toDiagString()}'"
}

def ResolveExplicitConformances : VoidQuery {
    parameters = [
        // The type that the conformance was declared on.
        TypeParam<"T">
    ]

    ignoreCircularDependency = true
}

def ResolveConformancesToProtocols : Query<"llvm::SmallVector<ast::ProtocolDecl*, 2>"> {
    parameters = [
        // The type that the conformance was declared on.
        TypeParam<"T">,

        // The declaration that declares the conformances.
        MutableArrayParam<"Conformances", "ast::SourceType">,
    ]

    shouldMoveResult = true
    getReturnType = "ArrayRef<ast::ProtocolDecl*>"
}

/// Resolve all declared conformances of a declaration.
def ResolveDeclaredConformances : VoidQuery {
    parameters = [
        // The type that the conformance was declared on.
        TypeParam<"T">,

        // The conformance types as they appeared in the source.
        MutableArrayParam<"Conformances", "ast::SourceType">,

        // The kind of conformance to add.
        QueryParam<"Kind", "ConformanceKind">,

        // The extension that this conformance was introduced by.
        QueryParam<"CS", "ast::ConstraintSet*", "nullptr">,
    ]

    description = "resolving declared conformances of '${T.toDiagString()}'"
}

/// Add a single conformance and all of its conformances recursively.
def AddSingleConformance : VoidQuery {
    parameters = [
        // The type that the conformance was declared on.
        TypeParam<"T">,

        // The inherited protocol conformance.
        QueryParam<"Proto", "ast::ProtocolDecl*">,

        // The kind of conformance to add.
        QueryParam<"Kind", "ConformanceKind">,

        // The extension that this conformance was introduced by.
        QueryParam<"CS", "ast::ConstraintSet*", "nullptr">,

        // If true, recursively add conformances of this conformance.
        BoolParam<"AddRecursiveConformances", "true">,
    ]

    canBeDependent = true
}

/// Declare the 'Self' associated type for a record.
def DeclareSelfAlias : VoidQuery {
    parameters = [
        RecordDeclParam<"R">
    ]

    simpleQuery = true
}

/// Check whether or not all associated types that are referenced in 
/// a set of constraints are ready.
def ReferencedAssociatedTypesReady : Query<"ReferencedAssociatedTypesReadyQuery::ResultKind"> {
    parameters = [
        // The type to check.
        TypeParam<"T">,

        // The declaration whose constraints we should check.
        QueryParam<"CS", "ast::ConstraintSet*">,
    ]

    earlyExitCode = {
        if (!CS) {
            Result = ReferencedAssociatedTypesReadyQuery::ResultKind::Ready;
            return QueryResult(QueryResult::Success);
        }
    }

    customHeaderCode = {
    public:
        enum ResultKind : uint8_t {
            /// All referenced associated types are ready.
            Ready,

            /// Some associated types are not ready.
            NotReady,

            /// The type directly references 'Self'.
            ReferencesSelf,
        };
    }

    canBeCached = false
}

/// Check whether or not a protocol extension applies to a type.
def CheckProtocolExtensionApplicability
        : Query<"CheckProtocolExtensionApplicabilityQuery::ResultKind"> {
    parameters = [
        // The type to check.
        TypeParam<"T">,

        // The extension to check.
        QueryParam<"Ext", "ast::ExtensionDecl*">
    ]

    customHeaderCode = {
    public:
        enum ResultKind : uint8_t {
            /// We can't tell yet whether or not this extension applies.
            CantTell,

            /// This extension doesn't apply.
            DoesNotApply,

            /// This extension does apply.
            DoesApply,
        };
    }
}

/// Check whether or not a declaration constraint is valid.
def VerifyConstraint : Query<"ast::DeclConstraint*"> {
    parameters = [
        /// The constraint to verify.
        QueryParam<"C", "const ast::ParsedConstraint*">,

        /// The constrained declaration.
        NamedDeclParam<"ConstrainedDecl">,
    ]
}

/// Check whether or not a declaration constraint is valid.
def VerifyConstraints : Query<"ast::ConstraintSet*"> {
    parameters = [
        /// The constrained declaration.
        NamedDeclParam<"ConstrainedDecl">,
    ]
}

/// Check whether or not a declaration constraint is satisfied.
def IsConstraintSatisfied : BoolQuery {
    parameters = [
        /// The constraint to verify.
        QueryParam<"C", "const ast::DeclConstraint*">,

        /// The concrete decl on which to check the constraints.
        NamedDeclParam<"ConcreteDecl">,

        /// The original declaration the constraint was defined on.
        NamedDeclParam<"OriginalDecl">,

        /// The template parameters to check.
        TemplateArgsParam<"TemplateArgs", "nullptr">,
    ]

    canBeDependent = true
}

/// Get the type that is constrained by a decl constraint.
def GetConstrainedType : Query<"QualType"> {
    parameters = [
        /// The constraint to verify.
        QueryParam<"C", "const ast::DeclConstraint*">,

        /// The concrete decl on which to check the constraints.
        NamedDeclParam<"ConcreteDecl">,

        /// The original declaration the constraint was defined on.
        NamedDeclParam<"OriginalDecl">

        /// The template parameters to check.
        TemplateArgsParam<"TemplateArgs", "nullptr">,
    ]

    canBeDependent = true
}

/// Whether or not a constraint set is a superset of another constraint set.
def IsSupersetOf : BoolQuery {
    parameters = [
        QueryParam<"C1", "ast::ConstraintSet*">,
        QueryParam<"C2", "ast::ConstraintSet*">,
    ]

    earlyExitCode = {
        if (!C2 || C2->empty()) {
            return true;
        }
        if (!C1 || C1->empty()) {
            return C2->empty();
        }
        if (C1 == C2) {
            return true;
        }
    }

    simpleQuery = true
    infallible = true
}

/// Returns all associated types referenced in a constraint set.
def GetReferencedAssociatedTypes : Query<"std::vector<ast::AssociatedTypeDecl*>"> {
    parameters = [
        QueryParam<"CS", "ast::ConstraintSet*">,
    ]

    shouldMoveResult = true
    getReturnType = "llvm::ArrayRef<ast::AssociatedTypeDecl*>"
}

/// Returns all associated types that a record needs to implement.
def GetNeededAssociatedTypes : Query<"llvm::SmallVector<ast::AssociatedTypeDecl*, 4>"> {
    parameters = [
        RecordDeclParam<"R">
    ]

    shouldMoveResult = true
    getReturnType = "llvm::ArrayRef<ast::AssociatedTypeDecl*>"
}

/// Check all conformances of a type.
def CheckConformances : VoidQuery {
    parameters = [
        // The type to check.
        TypeParam<"T">,

        // Optional vector of extension decls to be filled.
        QueryParam<"ExtensionDecls", "std::vector<ast::NamedDecl*> *", "nullptr">,
    ]

    description = "checking conformances of '${T.toDiagString()}'"
}

/// Check a single protocol conformance.
def CheckSingleConformance : VoidQuery {
    parameters = [
        // The type to check.
        TypeParam<"T">,

        /// The protocol to check the conformance to.
        QueryParam<"P", "ast::ProtocolDecl*">
    ]

    description = "checking conformance of '${T.toDiagString()}' to '${P->getFullName()}'"
}

/// Check associated type constraints.
def CheckAssociatedTypeConstraints : VoidQuery {
    parameters = [
        RecordDeclParam<"R">
    ]
}

/// Typecheck the constraints of a declaration.
def TypecheckConstraints : VoidQuery {
    parameters = [
        NamedDeclParam<"ND">
    ]
}

/// Check whether or not a type conforms to a protocol.
def ConformsTo : BoolQuery {
    parameters = [
        // The type whose conformance should be checked.
        CanTypeParam<"T">

        // The protocol that is checked.
        ProtocolDeclParam<"P">
    ]

    description = "checking if ${T.toDiagString()} conforms to ${P->getFullName()}"
    canBeDependent = true

    refreshCondition = {
        T->isRecordType() && QC.Sema->IsBeingResolved(T->getRecord())
    }
}

/// Check whether or not a type is covariant wrt another type.
def IsCovariant : BoolQuery {
    parameters = [
        // The type that should be checked.
        TypeParam<"T">

        // The covariance type.
        TypeParam<"Covar">
    ]

    canBeDependent = true

    refreshCondition = {
        T->isRecordType() && QC.Sema->IsBeingResolved(T->getRecord())
    }
}

/// Check whether or not a type is contravariant wrt another type.
def IsContravariant : BoolQuery {
    parameters = [
        // The type that should be checked.
        TypeParam<"T">

        // The covariance type.
        TypeParam<"Contravar">
    ]

    canBeDependent = true

    refreshCondition = {
        T->isRecordType() && QC.Sema->IsBeingResolved(T->getRecord())
    }
}

/// Get or compute the size of a type.
def GetTypeSize : Query<"unsigned"> {
    parameters = [
        // The type to get the size of.
        CanTypeParam<"T">
    ]

    description = "computing size of type ${T.toDiagString()}"
    canBeDependent = true
}

/// Get or compute the alignment of a type.
def GetTypeAlignment : Query<"unsigned short"> {
    parameters = [
        // The type to get the alignment of.
        CanTypeParam<"T">
    ]

    description = "computing alignment of type ${T.toDiagString()}"
    canBeDependent = true
}

/// Get or compute the stride of a type.
def GetTypeStride : Query<"unsigned"> {
    parameters = [
        // The type to get the stride of.
        CanTypeParam<"T">
    ]

    description = "computing stride of type ${T.toDiagString()}"
    canBeDependent = true
}

/// Calculate the size of a record.
def CalculateRecordSize : Query<"unsigned"> {
    parameters = [
        // The record whose size should be calculated.
        RecordDeclParam<"R">
    ]

    description = "calculating size of record ${R->getFullName()}"
    canBeDependent = true
    canBeSerialized = true

    persistentState = {
    public:
        /// Map from records to their computed meta info.
        llvm::DenseMap<ast::RecordDecl*, RecordMetaInfo> RecordMeta;
    }
}

/// Get the full meta info for a record. This calls PrepareDeclInterface on the record if Initialize is true.
def GetRecordMeta : Query<"const RecordMetaInfo*"> {
    parameters = [
        RecordDeclParam<"R">,
        BoolParam<"Initialize", "true">
    ]

    simpleQuery = true
    canBeCached = false
}

/// Helper class for trivial record related queries.
class RecordMetaQuery : BoolQuery {
    override parameters = [
        RecordDeclParam<"R">
    ]

    override simpleQuery = true
    override infallible = true
}

def IsBuiltinIntegerType : RecordMetaQuery
def IsBuiltinFloatingPointType : RecordMetaQuery
def IsBuiltinBoolType : RecordMetaQuery

/// Register an implicit conformance for a record.
def AddImplicitConformance : Query<"ast::MethodDecl*"> {
    parameters = [
        RecordDeclParam<"R">,
        QueryParam<"K", "ast::ImplicitConformanceKind">

        // If this is a manual implementation, provide it as this parameter.
        QueryParam<"Impl", "ast::MethodDecl*", "nullptr">
    ]

    simpleQuery = true
}

/// Return an implicit conformance method, or null if it does not exist.
def GetImplicitConformance : Query<"ast::MethodDecl*"> {
    parameters = [
        RecordDeclParam<"R">,
        QueryParam<"K", "ast::ImplicitConformanceKind">
    ]

    simpleQuery = true
    canBeCached = false
}

/// Check whether builtin conformances apply to a record (Equatable, Copyable, etc.)
def CheckBuiltinConformances : VoidQuery {
    parameters = [
        // The record whose size should be calculated.
        RecordDeclParam<"R">
    ]

    canBeDependent = true
}

/// Check whether or not a declaration is accessible within the given context.
def IsAccessible : BoolQuery {
    parameters = [
        // The context.
        DeclContextParam<"DC">,

        // The declaration whose accessibility should be checked.
        NamedDeclParam<"ND">
    ]

    description = "checking if '${ND->getFullName()}' is accessible"
}

/// Verify and diagnose the accessibility of a declaration.
def CheckAccessibility : VoidQuery {
    parameters = [
        // The context.
        DeclContextParam<"DC">,

        // The declaration whose accessibility should be checked.
        NamedDeclParam<"ND">,

        // The location for which the diagnostic should be emitted.
        SourceLocParam<"Loc">
    ]

    description = "checking if '${ND->getFullName()}' is accessible"
}

/// Resolve a nested name specifier to a type.
def ResolveNestedNameSpecToType : Query<"QualType"> {
    parameters = [
        /// The name specifier.
        NameSpecWithLocParam<"Name">,

        /// The context in which to start lookup.
        DeclContextParam<"DC", "nullptr", false, true>,

        /// Whether or not to issue a diagnostic if name resolution fails.
        BoolParam<"IssueDiag", "true">
    ]
}

/// Resolve a nested name specifier to a declaration.
def ResolveNestedNameSpecToDecl : Query<"ast::NamedDecl*"> {
    parameters = [
        /// The name specifier.
        NameSpecWithLocParam<"Name">,

        /// The context in which to start lookup.
        DeclContextParam<"DC", "nullptr", false, true>,

        /// Whether or not to issue a diagnostic if name resolution fails.
        BoolParam<"IssueDiag", "true">
    ]
}

/// Typecheck all declarations contained within a DeclContext.
def TypeCheckDeclContext : VoidQuery {
    parameters = [
        /// The context to typecheck.
        DeclContextParam<"DC">
    ]

    description = "typechecking '${DC->getNameAsString()}'"
}

/// *** Declaration typechecking queries. ***

/// Prepare the interface of a declaration.
def PrepareDeclInterface : VoidQuery {
    parameters = [
        /// The declaration to prepare.
        DeclParam<"D">
    ]

    simpleQuery = true
}

/// Typecheck a declaration.
def TypecheckDecl : VoidQuery {
    parameters = [
        /// The declaration to typecheck.
        DeclParam<"D">
    ]

    simpleQuery = true
}

foreach decl in ["PrecedenceGroup", "Operator", "GlobalVar",
                 "Callable", "Function", "Method", "Init", "Deinit",
                 "FuncArg", "TemplateParam", "AssociatedType", "Alias",
                 "Record", "Struct", "Class", "Enum", "Protocol", "Extension",
                 "Field", "Prop", "Subscript", "EnumCase",
                 "Namespace", "Compound", "Module"] {
    /// Prepare the interface of a function, i.e. its argument types, return type etc.
    def !str_concat("Prepare", $(decl), "Interface") : VoidQuery {
        parameters = [
            /// The function to prepare.
            QueryParam<"D", !str_concat("ast::", $(decl), "Decl*")>
        ]

        if !eq("Callable", $(decl)) {
            persistentState = {
            private:
                /// Function declarations marked extern(C) with a particular name.
                llvm::DenseMap<IdentifierInfo*, ast::CallableDecl*> ExternCFuncs;
            }
        }

        private = true
        description = "preparing interface of '${D->Decl::getNameAsString()}'"
    }

    /// Typecheck a function body.
    def !str_concat("Typecheck", $(decl)) : VoidQuery {
        parameters = [
            /// The function to typecheck.
            QueryParam<"D", !str_concat("ast::", $(decl), "Decl*")>
        ]

        private = true
        description = "typechecking '${D->Decl::getNameAsString()}'"
    }
}

/// Prepare the template parameters of a declaration.
def PrepareTemplateParameters : VoidQuery {
    parameters = [
        NamedDeclParam<"Decl">
    ]
}

/// Prepare the implicit (de-)initializers of a record.
def DeclareImplicitInitializers : VoidQuery {
    parameters = [
        RecordDeclParam<"R">
    ]
}

/// Declares the implicit default initializer of a record.
def DeclareImplicitDefaultInit : VoidQuery {
    parameters = [
        QueryParam<"S", "ast::StructDecl*">
    ]
}

/// Declares the (implicit) memberwise initializer of a record.
def DeclareMemberwiseInit : VoidQuery {
    parameters = [
        QueryParam<"S", "ast::StructDecl*">
    ]
}

/// Declares the implicit default deinitializer of a record.
def DeclareImplicitDefaultDeinit : VoidQuery {
    parameters = [
        QueryParam<"S", "ast::RecordDecl*">
    ]
}

/// Resolve the raw type of an enum.
def ResolveRawType : VoidQuery {
    parameters = [
        QueryParam<"E", "ast::EnumDecl*">
    ]
}

/// Assign an initializer name to prepare name lookup.
def AssignInitName : VoidQuery {
    parameters = [
        QueryParam<"Init", "ast::InitDecl*">
    ]
}

/// Create the equivalent base initializer for a complete one.
def CreateBaseInit : VoidQuery {
    parameters = [
        QueryParam<"D", "ast::InitDecl*">
    ]

    simpleQuery = true
}

/// *** Lookup queries. ***

/// Perform a find-first lookup.
def LookupFirst : Query<"SingleLevelLookupResult"> {
    parameters = [
        // The context to lookup in.
        DeclContextParam<"DC">,

        // The name to lookup.
        DeclNameParam<"Name">,

        // The lookup options.
        QueryParam<"Opts", "LookupOpts", "DefaultLookupOpts">
    ]

    shouldMoveResult = true
    getReturnType = "const SingleLevelLookupResult*"
    customGet = {
        return &Result.getValue();
    }

    description = "looking up first occurence of '${Name.toString()}' in '${DC->getNameAsString()}'"

    // Refresh when declarations are added or removed.
    customHeaderCode = {
    private:
        /// Revision ID of the last lookup.
        int32_t RevisionID = -1;
    }

    constructorCode = {
        RevisionID = DC->getRevisionID();
    }

    refreshCondition = {
        RevisionID < DC->getRevisionID()
    }

    onRefresh = {
        RevisionID = DC->getRevisionID();
    }

    ignoreCircularDependency = true
}

/// Perform a find-first lookup for a single declaration.
def LookupSingle : Query<"ast::NamedDecl*"> {
    parameters = [
        // The context to lookup in.
        DeclContextParam<"DC">,

        // The name to lookup.
        DeclNameParam<"Name">,

        // The lookup options.
        QueryParam<"Opts", "LookupOpts", "DefaultLookupOpts | LookupOpts::IssueDiag">
    ]

    description = "looking up single occurence of '${Name.toString()}' in '${DC->getNameAsString()}'"

    // Refresh when declarations are added or removed.
    customHeaderCode = {
    private:
        /// Revision ID of the last lookup.
        int32_t RevisionID = -1;
    }

    constructorCode = {
        RevisionID = DC->getRevisionID();
    }

    refreshCondition = {
        RevisionID < DC->getRevisionID()
    }

    onRefresh = {
        RevisionID = DC->getRevisionID();
    }

    // Allow looking up a specific type of declaration only.
    persistentState = {
    public:
        template<class T>
        T *LookupSingleAs(ast::DeclContext *DC, DeclarationName Name,
                          LookupOpts Opts = DefaultLookupOpts) {
            ast::NamedDecl *Result;
            if (LookupSingle(Result, DC, Name, Opts)) {
                return nullptr;
            }

            return support::dyn_cast_or_null<T>(Result);
        }
    }

    ignoreCircularDependency = true
}

/// Perform a multi-level lookup.
def MultiLevelLookup : Query<"MultiLevelLookupResult"> {
    parameters = [
        // The context to lookup in.
        DeclContextParam<"DC">,

        // The name to lookup.
        DeclNameParam<"Name">,

        // The lookup options.
        QueryParam<"Opts", "LookupOpts", "DefaultLookupOpts">
    ]

    shouldMoveResult = true
    getReturnType = "const MultiLevelLookupResult*"
    customGet = {
        return &Result.getValue();
    }

    description = "looking up '${Name.toString()}' in '${DC->getNameAsString()}'"

    // Refresh when declarations are added or removed.
    customHeaderCode = {
    private:
        /// Revision ID of the last lookup.
        int32_t RevisionID = -1;
    }

    constructorCode = {
        RevisionID = DC->getRevisionID();
    }

    refreshCondition = {
        RevisionID < DC->getRevisionID()
    }

    onRefresh = {
        RevisionID = DC->getRevisionID();
    }
}

/// Perform a multi-level lookup into a type.
def MultiLevelTypeLookup : Query<"MultiLevelLookupResult"> {
    parameters = [
        // The type to lookup in.
        CanTypeParam<"T">,

        // The name to lookup.
        DeclNameParam<"Name">,

        // The lookup options.
        QueryParam<"Opts", "LookupOpts", "DefaultLookupOpts">
    ]

    shouldMoveResult = true
    getReturnType = "const MultiLevelLookupResult*"
    customGet = {
        return &Result.getValue();
    }

    // Refresh when declarations are added or removed.
    customHeaderCode = {
    private:
        /// Revision ID of the last lookup.
        int32_t RevisionID = -1;
    }

    constructorCode = {
        if (auto *RT = T->removeMetaType()->asRecordType())
            RevisionID = RT->getRecord()->getRevisionID();
    }

    refreshCondition = {
        !T->removeMetaType()->isRecordType() || RevisionID < T->removeMetaType()->getRecord()->getRevisionID()
    }

    onRefresh = {
        if (auto *RT = T->removeMetaType()->asRecordType())
           RevisionID = RT->getRecord()->getRevisionID();
    }
}

/// Perform a restricted lookup, i.e. one that does not look into extensions, conformances,
/// etc. This is mainly used to find macros and protocols, which can only appear at the top
/// level or in namespaces.
def RestrictedLookup : Query<"MultiLevelLookupResult"> {
    parameters = [
        // The context to lookup in.
        DeclContextParam<"DC">,

        // The name to lookup.
        DeclNameParam<"Name">,

        // The lookup options.
        QueryParam<"Opts", "LookupOpts", "DefaultLookupOpts">,
    ]

    pure = true
    shouldMoveResult = true
    ignoreCircularDependency = true

    getReturnType = "const MultiLevelLookupResult*"
    customGet = {
        return &Result.getValue();
    }
}

/// Perform a direct lookup, this only looks up in the record directly as well as in extensions.
def DirectLookup : Query<"MultiLevelLookupResult"> {
    parameters = [
        // The context to lookup in.
        DeclContextParam<"DC">,

        // The name to lookup.
        DeclNameParam<"Name">,

        /// If true, lookup in extensions of \param DC as well.
        BoolParam<"LookInExtensions", "true">,

        // The lookup options.
        QueryParam<"Opts", "LookupOpts", "DefaultLookupOpts">,

        // The constraint ID of the extensions to look up in.
        QueryParam<"Constraints", "ast::ConstraintSet*", "nullptr">,
    ]

    shouldMoveResult = true
    getReturnType = "const MultiLevelLookupResult*"
    customGet = {
        return &Result.getValue();
    }

    description = "directly looking up '${Name.toString()}' in '${DC->getNameAsString()}'"

    // Refresh when declarations are added or removed.
    customHeaderCode = {
    private:
        /// Revision ID of the last lookup.
        int32_t RevisionID = -1;
    }

    constructorCode = {
        RevisionID = DC->getRevisionID();
    }

    refreshCondition = {
        RevisionID < DC->getRevisionID()
    }

    onRefresh = {
        RevisionID = DC->getRevisionID();
    }
}

/// Perform a nested name lookup.
def NestedNameLookup : Query<"MultiLevelLookupResult"> {
    parameters = [
        // The context to lookup in.
        DeclContextParam<"DC">,

        // The names to lookup.
        ArrayParam<"Names", "DeclarationName">,

        // The lookup options.
        QueryParam<"Opts", "LookupOpts", "DefaultLookupOpts | LookupOpts::IssueDiag">,

        SourceRangeParam<"Loc", "SourceRange()", true>
    ]

    shouldMoveResult = true
    getReturnType = "const MultiLevelLookupResult*"
    customGet = {
        return &Result.getValue();
    }

    description = "doing nested name lookup in '${DC->getNameAsString()}'"
    canBeCached = false
}

/* Multi-Stage Lookup Queries */

foreach kind in [
                    /// Expand all macro invocations in declaration position.
                    "Macros",

                    /// Expand static if / for declarations
                    "StaticDeclarations",

                    /// Resolve wildcard using and import statements.
                    "WildcardDeclarations"
                ] {
    def !str_concat("Resolve", $(kind)) : VoidQuery {
        parameters = [
            DeclContextParam<"DC">
        ]

        simpleQuery = true
    }
}

/// Resolve macros, mixins, static declarations and imports in a context.
def ResolveMetaDeclarations : VoidQuery {
    parameters = [
        /// The context to prepare for lookup.
        DeclContextParam<"DC">
    ]

    ignoreCircularDependency = true
}

/// Get an associated type by name.
def GetAssociatedTypeImpl : Query<"ast::AliasDecl*"> {
    parameters = [
        /// The record to lookup the associated type in.
        RecordDeclParam<"R">,

        /// The associated type name to look up.
        DeclNameParam<"Name">,

        /// The records extensions.
        ArrayParam<"Extensions", "ast::ExtensionDecl*">,

        /// The constraint ID of the current context.
        QueryParam<"Constraints", "ast::ConstraintSet*", "nullptr">,
    ]

    canBeCached = false
}

/// Get an associated type declaration by name.
def GetAssociatedTypeDecl : Query<"ast::AssociatedTypeDecl*"> {
    parameters = [
        /// The record to lookup the associated type in.
        QueryParam<"P", "ast::ProtocolDecl*">,

        /// The associated type name to look up.
        DeclNameParam<"Name">,

        /// The constraint ID of the current context.
        QueryParam<"Constraints", "ast::ConstraintSet*", "nullptr">,
    ]

    canBeCached = false
}

/// Check if two types are equivalent after substituting the second one with associated types
/// from 'Self'.
def CheckTypeEquivalence : BoolQuery {
    parameters = [
        /// The first type.
        TypeParam<"LHS">,

        /// The second type.
        TypeParam<"RHS">,

        /// The 'Self' type.
        TypeParam<"Self">,

        /// The left hand side declaration context (to replace generic parameters).
        DeclContextParam<"LHSDecl", "nullptr">,

        /// The current declaration context (used for applying capabilities).
        DeclContextParam<"DeclCtx", "nullptr">,
    ]
}

/// *** Template instantiation queries. ***

/// Check whether or not a template extension applies to a concrete instantiation.
def CheckTemplateExtensionApplicability : BoolQuery {
    parameters = [
        /// The instantiation to check.
        RecordDeclParam<"Inst">,

        /// The extension to check.
        QueryParam<"Ext", "ast::ExtensionDecl*">
    ]
}

/// *** IL generation queries. ***

/// Get the IL module that a declaration lives in.
def GetILModuleForDecl : Query<"il::Module*"> {
    parameters = [
        DeclParam<"D">
    ]
}

/// Generate the IL for a decl.
def GenerateILForDecl : VoidQuery {
    parameters = [
        DeclParam<"D">
    ]
}

/// Generate the IL for a decl context.
def GenerateILForContext : VoidQuery {
    parameters = [
        DeclContextParam<"DC">
    ]
}

/// Generate the IL for a record.
def GenerateRecordIL : VoidQuery {
    parameters = [
        RecordDeclParam<"R">
    ]

    private = true
}

/// Get the forward declaration of an IL global variable.
def GetILGlobal : Query<"il::GlobalVariable*"> {
    parameters = [
        /// The global variable or field decl.
        QueryParam<"GV", "ast::VarDecl*">
    ]

    description = "declaring IL global variable for '${GV->getFullName()}'"
}

/// Generate the IL for a global variable lazy initialization.
def GenerateLazyILGlobalDefinition : VoidQuery {
    parameters = [
        /// The function to generate IL for.
        QueryParam<"GV", "ast::VarDecl*">
    ]

    description = "generating lazy initialization IL for global variable '${GV->getFullName()}'"
    private = true
}

/// Get the forward declaration of an IL function.
def GetILFunction : Query<"il::Function*"> {
    parameters = [
        /// The function to declare.
        QueryParam<"C", "ast::CallableDecl*">
    ]

    description = "declaring IL function for '${C->getFullName()}'"
}

/// Generate the IL for a function body.
def GenerateILFunctionBody : VoidQuery {
    parameters = [
        /// The function to generate IL for.
        QueryParam<"C", "ast::CallableDecl*">
    ]

    description = "generating IL for function '${C->getFullName()}'"
    private = true
}

/// Get the IL type info object for a type.
def GetILTypeInfo : Query<"il::GlobalVariable*"> {
    parameters = [
        /// The type to retrieve the type info of.
        TypeParam<"T">
    ]
}

/// Create the IL type info object for a type.
def CreateILBasicTypeInfo : Query<"il::Constant*"> {
    parameters = [
        /// The type to create the type info of.
        TypeParam<"T">
    ]

    private = true
}

/// Create the IL type info object for a record.
def CreateILRecordTypeInfo : Query<"il::Constant*"> {
    parameters = [
        /// The record to create the type info of.
        RecordDeclParam<"R">
    ]

    private = true
}

/// *** IL boundary queries. ***

let il_query_types = ["Bool": "bool" "String": "llvm::StringRef"]
foreach type in ["Bool", "String"] {
    /// Return the boolean value of an IL constant.
    def !str_concat("Get", $(type), "Value") : Query<il_query_types[$(type)]> {
        parameters = [
            ILConstantParam<"C">,
            BoolParam<"AllowWrapperTypes", "true">
        ]

        pure = true
        simpleQuery = true
    }
}

def GetIntValue : Query<"llvm::APSInt"> {
    parameters = [
        ILConstantParam<"C">,
        BoolParam<"AllowWrapperTypes", "true">
    ]

    simpleQuery = true
    shouldMoveResult = true
}

/// *** Utility queries. ***

/// Open a file as a read-only memory buffer.
def OpenFileForRead : Query<"std::unique_ptr<llvm::MemoryBuffer>"> {
    parameters = [
        // Filename of the file to open.
        StringParam<"FileName">
    ]

    shouldMoveResult = true
    getReturnType = "llvm::MemoryBuffer*"
    customGet = {
        return Result.getValue().get();
    }

    description = "opening file $FileName"
}

/// Create and open a temporary file as an llvm::raw_fd_ostream.
def OpenTmpFile : Query<"std::unique_ptr<llvm::raw_ostream>"> {
    parameters = [
        // Extension of the temporary file, none by default.
        StringParam<"Extension", "">
    ]

    shouldMoveResult = true
    getReturnType = "llvm::raw_ostream*"
    customGet = {
        return Result.getValue().get();
    }

    canBeCached = false
    description = "opening temp file with extension .$Extension"
}

/// Create a default template argument for a template parameter.
def GetDefaultTemplateArg : Query<"sema::TemplateArgument"> {
    parameters = [
        /// The template parameter.
        QueryParam<"P", "ast::TemplateParamDecl*">
    ]

    shouldMoveResult = true
    getReturnType = "const sema::TemplateArgument*"
    customGet = {
        return &Result.getValue();
    }
}

/// Create a 'self' argument.
def CreateSelfArgument : Query<"ast::FuncArgDecl*"> {
    parameters = [
        /// The type of 'self'.
        TypeParam<"Self">,

        /// The source location of the argument.
        QueryParam<"SelfLoc", "SourceLocation">
    ]

    canBeCached = false
}

/// Look for an equivalent to a declaration in another declaration context.
def FindEquivalentDecl : Query<"ast::NamedDecl*"> {
    parameters = [
        /// The declaration to find.
        NamedDeclParam<"Decl">,

        /// The context to look in.
        DeclContextParam<"DC">,

        /// The 'Self' type to replace associated types in the *second* function with.
        TypeParam<"Self", "QualType()">,

        /// If true, lookup in extensions of \param DC as well.
        BoolParam<"LookInExtensions", "true">
    ]
}

/// Check whether or not two function signatures are equivalent.
def EquivalentSignatures : Query<"EquivalentSignaturesQuery::ResultKind"> {
    parameters = [
        /// The first function.
        QueryParam<"C1", "ast::CallableDecl*">,

        /// The second function.
        QueryParam<"C2", "ast::CallableDecl*">,

        /// The 'Self' type to replace associated types in the *second* function with.
        TypeParam<"Self">
    ]

    customHeaderCode = {
    public:
        enum ResultKind {
            /// The signatures are equivalent.
            Equivalent,

            /// There is a return type mismatch.
            ReturnTypeMismatch,

            /// Parameter count mismatch.
            ParamCountMismatch,

            /// There is a parameter type mismatch.
            ParamTypeMismatch,

            /// There is a label mismatch.
            LabelMismatch,

            /// 'throws' does not match.
            ThrowsMismatch,

            /// 'unsafe' does not match.
            UnsafeMismatch,

            /// 'async' does not match.
            AsyncMismatch,

            /// 'static' does not match.
            StaticMismatch
        };
    }
}
