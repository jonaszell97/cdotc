
@version(None)
module std.variant

import { Arity, TypeAt } from std.reflect
import { isNull, deref } from std.builtin

public alias MaxSize< ...Ts> = MaxSizeImpl<0u, Ts...>
public alias MaxSizeImpl<let CurrentMax: u64, T, ...Ts>
    = MaxSizeImpl<if (reflect.sizeOf<T>) > CurrentMax then reflect.sizeOf<T>
                  else CurrentMax, Ts...>
public alias MaxSizeImpl<let CurrentMax: u64> = CurrentMax

alias ContainsType<T, U, ...Rest> = true                     where T == U
alias ContainsType<T, U, ...Rest> = ContainsType<T, Rest...> where T != U
alias ContainsType<T>             = false

alias max<let T: u64, let U: u64> = if T > U then T else U
alias min<let T: u64, let U: u64> = if T < U then T else U

macro dispatch {
    ($body:any) => {
        static for Idx in Array<Int>() {
            if holds<TypeAt<Idx, Ts...> >() {
                $body
            }
        }

        unreachable!("bad variant type")
    }
}

public struct Variant< ...Ts> with StringRepresentable {
    alias ByteSize = max<1u, MaxSize<Ts...>>
    var storage: [u8; ByteSize]
    var typeInfo: UnsafePtr<TypeInfo>

    init<T>(_ t: T) {
        self.storage  = [u8; ByteSize]()
        self.typeInfo = (UnsafePtr<TypeInfo>)()

        setValue(t)
    }

    deinit {
        deinitValue()
    }

    private def deinitValue() {
        if !typeInfo {
            return
        }

        if holdsClass {
            _cdot_Release(asRefcounted())
        }
        else if typeInfo->deinitializer as! Bool {
            typeInfo->deinitializer(storage as! UnsafeMutablePtr<u8> as! UnsafeMutableRawPtr)
        }
    }

    private prop holdsClass: Bool {
        if typeInfo.isNull() {
            return false
        }

        dispatch!{
            return TypeAt<Idx, Ts...> is class
        }
    }

    private def asRefcounted() -> UnsafeMutablePtr<Refcounted> {
        return (storage as! UnsafeMutablePtr<u8>
                        as! UnsafeMutablePtr<UnsafeMutablePtr<Refcounted> >).deref()
    }

    private def mutating setValue<T>(_ t: T) {
        static_assert(ContainsType<T, Ts...>, "given type is not contained in Variant types")

        deinitValue()

        libc.memcpy(storage as! UnsafeMutablePtr<u8> as! UnsafeMutableRawPtr,
                    builtin.addressOf(t) as! UnsafeRawPtr,
                    reflect.sizeOf<T>)

        static if T is class {
            _cdot_Retain(asRefcounted())
        }

        self.typeInfo = builtin.addressOf(typeof t)
    }

    private def convertStorage<T>() -> T {
        return *(storage as! UnsafeMutablePtr<u8> as! UnsafeMutablePtr<T>)
    }

    def getAs<T>() -> T? {
        static_assert(ContainsType<T, Ts...>, "given type is not contained in Variant types")
        if holds<T>() {
            return .Some(convertStorage<T>())
        }

        return .None
    }

    def holds<T>() -> Bool {
        static_assert(ContainsType<T, Ts...>, "given type is not contained in Variant types")
        return self.typeInfo == builtin.addressOf(T.typeof)
    }

    def mutating infix = <T>(t: T) where ContainsType<T, Ts...> {
        setValue(t)
    }

    private def visitImpl<let Idx, let TypeIdx = Idx, Fn, ...Rest>(_ fn: Fn, _ rest: Rest...) {
        static if Idx == 0 {
            return fn(getAs<TypeAt<TypeIdx, Ts...> >()!)
        }
        else {
            return visitImpl<Idx - 1, TypeIdx, Rest...>(rest...)
        }
    }

    def visit(_ fns: (Ts) -> Void ...) {
        dispatch!{
            return visitImpl<Idx, Idx>(fns...)
        }
    }

    def toString() -> String {
        dispatch!{
            return (getAs<TypeAt<Idx, Ts...> >()!).toString()
        }
    }
}

struct Any {
    private var _storage: UnsafeRawPtr
    prop storage: UnsafeRawPtr {
        if usingInlineStorage {
            return builtin.addressOf(_storage) as! UnsafeRawPtr
        }

        return _storage
    }

    private var _typeInfo: UnsafePtr<TypeInfo>
    prop typeInfo: UnsafePtr<TypeInfo> {
        return ((_typeInfo as! UInt) & ~0x2) as! UnsafePtr<TypeInfo>
    }

    alias CanUseInlineStorage<T> = reflect.sizeOf<T> <= reflect.sizeOf<UnsafeRawPtr>

    init<T>(_ t: T) {
        self._storage  = (UnsafeRawPtr)()
        self._typeInfo = (UnsafePtr<TypeInfo>)()

        setValue(t)
    }

    init {
        self._storage  = (UnsafeRawPtr)()
        self._typeInfo = (UnsafePtr<TypeInfo>)()
    }

    deinit {
        deinitValue()
    }

    private def deinitValue() {
        if !typeInfo {
            return
        }

        if holdsClass {
            _cdot_Release(asRefcounted())
        }
        else if typeInfo->deinitializer as! Bool {
            typeInfo->deinitializer(storage as! UnsafeMutableRawPtr)
        }

        if !usingInlineStorage {
            _cdot_Free(_storage as! UnsafeMutableRawPtr)
        }
    }

    prop holdsClass: Bool {
        return ((_typeInfo as! UInt) & 0x1) != 0
    }

    prop usingInlineStorage: Bool {
        return ((_typeInfo as! UInt) & 0x2) != 0
    }

    private def asRefcounted() -> UnsafeMutablePtr<Refcounted> {
        return (storage as! UnsafeMutablePtr<UnsafeMutablePtr<Refcounted> >).deref()
    }

    private def mutating updateTypeInfo<T>() {
        self._typeInfo = builtin.addressOf(T.typeof)

        static if T is class {
            self._typeInfo = ((self._typeInfo as! UInt) | 0x1) as! UnsafePtr<TypeInfo>
        }
        static if CanUseInlineStorage<T> {
            self._typeInfo = ((self._typeInfo as! UInt) | 0x2) as! UnsafePtr<TypeInfo>
        }
    }

    private def convertStorage<T>() -> T {
        return (storage as! UnsafeMutablePtr<T>).deref()
    }

    private def mutating updateValue<T>(to t: T) {
        deinitValue()

        // if the value fits in a word, we can avoid the heap allocation
        static if !CanUseInlineStorage<T> {
            _storage = _cdot_Malloc(reflect.sizeOf<T>)
        }
        
        updateTypeInfo<T>()
        libc.memcpy(storage as! UnsafeMutableRawPtr,
                    builtin.addressOf(t) as! UnsafeRawPtr,
                    reflect.sizeOf<T>)
    }

    private def mutating setValue<T>(_ t: T) {
        // we need to release the old value if it's a class
        if holdsClass {
            _cdot_Release(asRefcounted())
        }

        updateValue(to: t)

        static if T is class {
            _cdot_Retain(asRefcounted())
        }
    }

    def holds<T>() -> Bool {
        return self.typeInfo == builtin.addressOf(T.typeof)
    }

    def mutating infix = <T>(t: T) {
        setValue(t)
    }

    def getAs<T>() -> T? {
        if holds<T>() {
            return .Some(convertStorage<T>())
        }

        return .None
    }
}

// extend Variant with StringRepresentable {
//     def toString() -> String {
//         static for Idx in Array(0..Arity<Tys...>) {
//             if holds<TypeAt<Idx, Tys...> >() {
//                 return getAs<TypeAt<Idx, Tys...> >().toString()
//             }
//         }

//         unreachable("bad variant type")
//     }
// }