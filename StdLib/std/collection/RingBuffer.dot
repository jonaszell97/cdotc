
@version(None)
module std.collection

public struct RingBuffer<T> {
    /// The buffer array.
    internal var buffer: CowBuffer<T>

    /// The 'read' index.
    internal var read: UInt

    /// The 'write' index.
    internal var write: UInt

    /// Initialize an empty ring buffer.
    init (withInitialCapacity: UInt) {
        self.buffer = CowBuffer<T>(withInitialCapacity)
        self.read = 0
        self.write = 0
    }
}

extend RingBuffer {
    /// Return the mask to map from an abstract index to a concrete one.
    internal def mask(_ idx: Index) -> Index {
        return idx & (buffer.bufferCapacity - 1)
    }

    /// Read the current value from the ring buffer.
    internal def read(at offset: Index = 0) -> T {
        return buffer.bytes[mask(read + offset as UInt)]
    }

    /// Write a new value to the buffer.
    internal def mutating write(_ val: owned T) {
        buffer.bytes[mask(write++)] = val
    }

    /// \return `true` iff this ring buffer is filled to its capacity.
    internal prop full: Bool {
        return size == capacity
    }
}

extend RingBuffer {
    /// Push a new element to the buffer.
    def mutating push(_ val: owned T) {
        write(val)
    }

    /// Pop an element from the buffer, returning its value.
    def mutating pop() -> T {
        var t = read()
        read++

        return t
    }

    /// Grow the buffer to increase capacity.
    def mutating grow() {
        buffer.grow(byAtLeast: buffer.capacity << 1)
    }
}

extend RingBuffer with Collection {
    /// \inherit
    associatedType Element = T

    /// Initialize an empty ring buffer.
    init {
        self.init(withInitialCapacity: 16)
    }

    /// \return `true` iff this ring buffer does not contain any elements.
    prop empty: Bool {
        return write == read
    }

    /// \return the number of elements currently stored in the collection.
    prop size: UInt {
        return write - read
    }

    /// \return the number of elements that can be stored in this buffer without resizing.
    prop capacity: UInt {
        return write - read
    }

    /// \return the first element in the collection, or `none` if the collection
    /// is empty.
    prop first: Element? {
        return read()
    }

    /// The type this collection is indexed by.
    associatedType Index = Int

    /// \return the first index in the collection.
    prop startIndex: Index {
        return read as Int
    }

    /// \return the element at the given index.
    subscript (idx: Index) -> Element {
        return read(idx)
    }
}
