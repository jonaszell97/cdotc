
module std.prelude

using std.collection.CowBuffer

protocol ExpressibleByArrayLiteral {
    associatedType Element
    init (s: Array<Element>)
}

public struct Array<T> {
    /// The copy-on-write buffer.
    internal var buffer: CowBuffer<T>

    /// Memberwise initializer.
    internal memberwise init

    /// Empty C'tor. Initializes an empty string.
    init {
        self.buffer = CowBuffer<T>()
    }

    /// Initialize from a static array. This is only called by the compiler
    /// when the lifetime of the array is guaranteed to exceed the lifetime of
    /// this array.
    private init (staticBuffer bytes: UnsafePtr<T>, size: Int) {
        self.buffer = CowBuffer<T>(staticBuffer: bytes, size)
    }

    /// C'tor. Initialize from an externally allocated array.
    init (rawBytes bytes: UnsafePtr<T>, size: Int = -1) {
        var size = size
        if size == -1 {
            size = libc.strlen(bytes) as Int
        }

        self.init()
        self.buffer.owned = false
        
        // FIXME
        // self.buffer.insert(bytes, size)
    }

    /// C'tor. Initialize with an initial capacity of bytes.
    public init(withInitialCapacity capacity: Int) {
        self.init()
        buffer.grow(byAtLeast: capacity)
    }

    /// \return a pointer to the beginning of this arrays buffer.
    prop unsafeBuffer: UnsafePtr<T> {
        return buffer.bytes
    }
}

extend Array with RandomAccessCollection {
    /// \inherit
    associatedType Element = T

    /// \inherit
    prop size: Int {
        return buffer.bufferSize
    }

    /// \inherit
    prop capacity: Int {
        return buffer.bufferCapacity
    }

    /// \inherit
    associatedType Index = Int

    /// \inherit
    prop startIndex: Index {
        return 0
    }

    /// \inherit
    prop endIndex: Index {
        return size as Int
    }

    /// \inherit
    subscript (idx: Index) -> Element {
        get {
            _checkIndex(idx)
            return buffer.bytes[idx]
        }
        set {
            _checkIndex(idx)
            buffer.bytes[idx] = newVal
        }
    }

    /// \inherit
    associatedType SubSequence = Self

    /// \inherit
    subscript (_ range: Range<Index>) -> SubSequence {
        // Since this is not mutating, we need this ugly conversion here.
        var SelfPtr = builtin.unsafeConstCast(builtin.addressOf(self))
        return SelfPtr->slice(from: range.startIndex, length: range.size)
    }

    /// Return a subsequence starting at \param offset with length \param length.
    def mutating slice(from offset: Index = 0,
                       length: Int = limits.max<Int>) -> Self {
        if offset >= size {
            return Self()
        }

        var len = math.min(size - offset, length)
        return Self(buffer: CowBuffer<T>(&buffer, offset, length))
    }
}

extend Array with MutableCollection {
    /// \inherit
    def mutating insert(_ el: owned T, at idx: Index) {
        buffer.insert(el, at: idx)
    }

    /// \inherit
    def mutating remove(at position: Index) -> T {
        _checkIndex(position)

        var t = self[position]
        buffer.remove(at: position)

        return t
    }

    /// \inherit
    def mutating clear() {
        buffer.clear()
    }

    /// \inherit
    def mutating reserveCapacity(_ capacity: Int) {
        if capacity < self.capacity {
            return
        }

        buffer.grow(byAtLeast: capacity - self.capacity)
    }

    /// \inherit
    def mutating reverse(fromIndex position: Index) {
        _checkIndex(position)
        buffer.reverse(fromIndex: position)
    }
}
