
@compiletime
module std.prelude

/// Half-open range formation.
postfix …

public struct Range<Bound: ?> {
    /// The first value in the range.
    var from: Bound

    /// The last value in the range.
    let to: Bound

    /// Memberwise C'tor.
    public memberwise init
}

extend Range with RandomAccessCollection {
    /// \inherit
    associatedType Element = Bound

    /// \inherit
    associatedType Index = Bound

    /// \inherit
    init {
        self.from = Bound()
        self.to = Bound()
    }

    /// \inherit
    prop startIndex: Index { return from }

    /// \inherit
    prop endIndex: Index { return to }

    /// \inherit
    subscript (idx: Index) -> Element {
        _checkIndex(idx)
        return self.from.advanced(by: idx)
    }

    /// \inherit
    associatedType SubSequence = Self

    /// \inherit
    subscript (range: Range<Index>) -> SubSequence {
        return range
    }
}

extend Range with Copyable, ImplicitlyCopyable /* where T is Copyable */ {}

public struct InclusiveRange<Bound: ?> {
    /// The first value in the range.
    var from: Bound

    /// The last value in the range.
    let to: Bound

    /// Memberwise C'tor.
    public init (from: Bound, to: Bound) {
        self.from = from
        self.to = to.advanced(by: 1)
    }
}

extend InclusiveRange with RandomAccessCollection {
    /// \inherit
    associatedType Element = Bound

    /// \inherit
    associatedType Index = Bound

    /// \inherit
    init {
        self.from = Bound()
        self.to = Bound()
    }

    /// \inherit
    prop startIndex: Index { return from }

    /// \inherit
    prop endIndex: Index { return to }

    /// \inherit
    subscript (idx: Index) -> Element {
        _checkIndex(idx)
        return self.from.advanced(by: idx)
    }

    /// \inherit
    associatedType SubSequence = Self

    /// \inherit
    subscript (range: Range<Index>) -> SubSequence {
        return range
    }
} 

extend InclusiveRange with Copyable, ImplicitlyCopyable /* where T is Copyable */ {}

public struct HalfOpenRange<Bound: ?> {
    /// The first value in the range.
    var from: Bound

    /// Memberwise C'tor.
    public memberwise init
}

extend HalfOpenRange with RandomAccessCollection {
    /// \inherit
    associatedType Element = Bound

    /// \inherit
    associatedType Index = Bound

    /// \inherit
    init {
        self.from = Bound()
    }

    /// \inherit
    prop startIndex: Index { return from }

    /// \inherit
    prop endIndex: Index { return limits.max<Bound> }

    /// \inherit
    subscript (idx: Index) -> Element {
        _checkIndex(idx)
        return self.from.advanced(by: idx)
    }

    /// \inherit
    associatedType SubSequence = Range<Bound>

    /// \inherit
    subscript (range: Range<Index>) -> SubSequence {
        return range
    }
}

extend HalfOpenRange with Copyable, ImplicitlyCopyable /* where T is Copyable */ {}

def infix ..= <T: ?>(from: T, to: T) -> InclusiveRange<T> {
    return InclusiveRange(from, to)
}

def infix .. <T: ?>(from: T, to: T) -> Range<T> {
    return Range(from, to)
}

def postfix … <T: ?>(from: T) -> HalfOpenRange<T> {
    return HalfOpenRange(from)
}
