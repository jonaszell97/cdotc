
module std.experimental

struct IndexingIterator<Base: Collection> {
    /// The collection we are iterating over.
    var base: Base

    /// The current index into the collection.
    var index: Base.Index

    /// Initialize from any collection.
    init (_ base: Base) {
        self.base = base
        self.index = self.base.startIndex
    }
}

extend IndexingIterator with IteratorProtocol {
    /// The element type of the collection.
    associatedType Element = Base.Element

    /// \return the next element in the collection.
    def next() -> Element? {
        if self.index >= base.endIndex {
            return none
        }

        var element = base[self.index]
        self.index = base.index(after: self.index)

        return .Some(element)
    }
}

struct DefaultIndices<Base: Collection> {
    /// The collection we are iterating over.
    var base: Base

    /// The start index.
    var startIndex: Base.Index

    /// The end index.
    var endIndex: Base.Index

    /// Initialize from any collection.
    internal memberwise init
}

extend DefaultIndices with Collection {
    /// \inherit
    associatedType Element = Base.Index

    /// \inherit
    associatedType Index = Base.Index

    /// \inherit
    associatedType Indices = Self

    /// \inherit
    associatedType SubSequence = Self

    /// \inherit
    subscript (position: Index) -> Element {
        return position
    }

    /// \inherit
    subscript (bounds: Range<Index>) -> SubSequence {
        return Self(base.copy(), bounds.startIndex, bounds.endIndex)
    }

    /// \inherit
    prop indices: Indices {
        return self.copy()
    }
}

protocol Collection with Iterable {
    /// The type of elements contained in the collection.
    associatedType Element

    /// The type of indices of this collection.
    associatedType Index: Comparable

    /// The type of sub-sequences of this collection.
    associatedType SubSequence: Collection
        where SubSequence.Element == Element
        where SubSequence.Index == Index
        // where SubSequence.SubSequence == SubSequence

    /// \return the position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    prop startIndex: Index { get }

    /// \return the collection's "past the end" position - that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    prop endIndex: Index { get }

    /// Accesses the element at the specified position.
    subscript (position: Index) -> Element { get }

    /// Accesses a contiguous subrange of the collection's elements.
    subscript (bounds: Range<Index>) -> SubSequence { get }

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    associatedType Indices: Collection = DefaultIndices<Self>
        where Indices.Element == Index
        where Indices.Index == Index
        where Indices.SubSequence == Indices

    /// \return the indices that are valid for subscripting the collection, in ascending
    /// order.
    prop indices: Indices { get }

    /// \return a Boolean value indicating whether the collection is empty.
    prop empty: Bool { get }

    /// \return the number of elements in the collection.
    prop size: Int { get }

    /// \return the number of elements that the collection can store without resizing.
    prop capacity: Int { get }

    /// \return the index after the given one.
    def index(after: Index) -> Index

    /// \return \param idx advanced by \param advancedBy.
    def index(_ idx: Index, advancedBy n: Int) -> Index

    /// \return \param idx advanced by \param advancedBy, but not if it exceeds `limitedBy`.
    def index(_ idx: Index, advancedBy n: Int, limitedBy: Index) -> Index?

    /// Verify that an index is in bounds.
    def _checkIndex(_ index: Index)

    /// Verify the range for a subsequence access.
    def _checkRange(_ range: Range<Index>)

    /// \return the distance between two indices.
    def distance(from start: Index, to end: Index) -> Int
}

extend Collection {
    /// \inherit
    default prop empty: Bool {
        return size == 0
    }

    /// \inherit
    default prop size: Int {
        return distance(from: startIndex, to: endIndex)
    }

    /// \inherit
    default prop underestimatedSize: Int {
        return size
    }

    /// \inherit
    default prop capacity: Int {
        return size
    }

    /// \return the first element in the collection, or `none` if the collection is empty.
    prop first: Element? {
        if empty {
            return none
        }

        return .Some(self[startIndex])
    }

    /// \inherit
    default def index(after idx: Index) -> Index {
        return index(idx, advancedBy: 1)
    }

    /// \inherit
    default def _checkIndex(_ index: Index) {
        precondition!(index < endIndex, "collection index out of bounds!")
    }

    /// \inherit
    default def _checkRange(_ range: Range<Index>) {
        precondition!(range.startIndex >= startIndex, "Range start index out of bounds")
        precondition!(range.endIndex < endIndex, "Range end index out of bounds")
    }

    /// \inherit
    default def distance(from start: Index, to end: Index) -> Int {
        var distance = 0
        var start = start

        while start != end {
            distance += 1
            start = index(after: start)
        }

        return distance
    }
}

extend Collection {
    /// Provide a default iterator using the collection's indices.
    default associatedType It = IndexingIterator<Self>
}

extend Collection where It == IndexingIterator<Self> {
    /// \inherit
    default def getIterator() -> It {
        return IndexingIterator(self.copy())
    }
}

extend Collection {
    /// \return the first `n` elements of the collection, or all elements if 
    /// it contains less than `n` elements.
    def prefix(_ n: Int) -> SubSequence {
        precondition!(n >= 0, "Cannot take a negative amount of elements")
        var end = if n <= size then n else size
        return self[0..end]
    }

    /// \return the last `n` elements of the collection, or all elements if 
    /// it contains less than `n` elements.
    def suffix(_ n: Int) -> SubSequence {
        precondition!(n >= 0, "Cannot take a negative amount of elements")
        let amount = math.max(0, size - n)
        let start = index(startIndex, advancedBy: amount, limitedBy: endIndex) ?? endIndex
        return self[start..endIndex]
    }

    /// \return a subsequence that does not contain the first `n` elements.
    def dropFirst(_ n: Int = 1) -> SubSequence {
        precondition!(n >= 0, "Cannot drop a negative amount of elements")
        let start = index(startIndex, advancedBy: n, limitedBy: endIndex) ?? endIndex
        return self[start..endIndex]
    }

    /// \return a subsequence that does not contain the last `n` elements.
    def dropLast(_ n: Int = 1) -> SubSequence {
        precondition!(n >= 0, "Cannot drop a negative amount of elements")
        let amount = math.max(0, size - n)
        let end = index(startIndex, advancedBy: amount, limitedBy: endIndex) ?? endIndex
        return self[startIndex..end]
    }

    /// \return a subsequence from the start of the collection up to, but not
    /// including, the specified position.
    def prefix(upTo end: Index) -> SubSequence {
        return self[startIndex..end]
    }

    /// \return a subsequence from the specified position to the end of the
    /// collection.
    def suffix(from start: Index) -> SubSequence {
        return self[start..endIndex]
    }

    /// \return a subsequence from the start of the collection up to and
    /// including the specified position.
    def prefix(through end: Index) -> SubSequence {
        return prefix(upTo: index(after: end))
    }
}