
module std.prelude

public class Dictionary<K, V> {
    struct Entry with Copyable, ImplicitlyCopyable {
        var key: K
        var value: V
        fileprivate var hash: u64 = 0

        fileprivate prop empty: Bool {
            return hash == 0
        }
    }

    /// A linear array of buckets, each one has space for one entry.
    var buckets: UnsafeMutablePtr<Entry>

    /// The current number of occupied buckets.
    var size: u64

    /// The capacity of the bucket array.
    var capacity: u64

    /// The size we will grow our buffer when reached.
    var resizeTreshold: u64

    /// Return the mask to turn a hash into a valid index into the buffer.
    prop mask: u64 {
        return capacity - 1
    }

    /// The maximum acceptable load factor before we resize.
    private alias MaxLoadFactorInPercent = 90u

    /// The number of initially allocated buckets.
    private alias InitialCapacity        = 64u

    /// The index type.
    alias Index = u64

    /// Value used to indicate an invalid index.
    private alias SentinelIndex = -1 as! Index

    /// Initialize an empty dictionary with a capacity of \ref InitialCapacity
    init {
        buckets = 0 as! UnsafeMutablePtr<Entry>
        size = 0
        capacity = InitialCapacity
        resizeTreshold = 0

        reallocate()
    }

    /// Deinitialize the storage and all entries in the dictionary.
    deinit {
        for var i = 0u; i < capacity; ++i {
            if !buckets[i].empty {
                builtin.deinit(builtin.loadFromPointer(buckets + i))
            }
        }

        freeBuffer(buckets)
    }

    /// Get the hash value for a key.
    private def getHashFor(_ key: K) -> u64 {
        var hashVal = key.hashValue()

        // Never return 0 as a hash value because we use it to mark empty slots.
        hashVal |= ((hashVal == 0) as u64)

        return hashVal
    }

    /// \return the index into the bucket array for a calculated hash.
    private def getIndexForPosition(_ hash: u64) -> Index {
        return getIndexForPosition(hash, capacity)
    }

    /// \return the distance that an entry is away from its desired spot.
    private def getProbeDistanceFor(_ hash: u64, _ slotIndex: u64) -> u64 {
        return getProbeDistanceFor(hash, slotIndex, capacity)
    }

    /// \return the index into the bucket array for a calculated hash.
    private static def getIndexForPosition(_ hash: u64, _ capacity: u64) -> Index {
        return hash & (capacity - 1)
    }

    /// \return the distance that an entry is away from its desired spot.
    private static def getProbeDistanceFor(_ hash: u64, _ slotIndex: u64,
                                           _ capacity: u64) -> u64 {
        return getIndexForPosition(
            slotIndex + capacity - getIndexForPosition(hash, capacity), capacity)
    }

    /// Insert a new entry with the key \param key and value \param val into the dictionary.
    private def insertAtIndex(_ idx: u64, _ hash: owned u64,
                              _ key: owned K, _ val: owned V) {
        var bucket = &buckets[idx]
        if bucket.empty {
            // If this bucket is uninitialized, we can't simply store the new values 
            // as that would try to deinitialize the old (non-existant) values.
            mem.replace(&bucket.hash, with: hash)
            mem.replace(&bucket.key, with: key)
            mem.replace(&bucket.value, with: val)

            builtin.retainIfNecessary(&key)
            builtin.retainIfNecessary(&val)
        }
        else {
            bucket.hash  = hash
            bucket.key   = key
            bucket.value = val
        }
    }

    /// Grow the capacity of the bucket array.
    private def reallocate() {
        buckets = mem.reallocate(pointer: buckets, newAmount: capacity)

        // mark all buckets as unoccupied
        for var i = 0u; i < capacity; ++i {
            buckets[i].hash = 0
        }

        resizeTreshold = (capacity * MaxLoadFactorInPercent) / 100
    }

    /// Free our bucket array.
    private def freeBuffer(_ buckets: UnsafeMutablePtr<Entry>) {
        mem.deallocate(buckets)
    }

    /// Increase the capacity by a factor of two.
    private def increaseCapacity() {
        capacity <<= 1u
    }

    /// Grow the capacity of the bucket array.
    private def grow() {
        var oldBuckets = buckets
        var oldCapacity = capacity

        increaseCapacity()
        reallocate()

        // copy over previous elements
        for var i = 0u; i < oldCapacity; ++i {
            unsafe {
                var oldEntry = &oldBuckets[i]
                if !oldEntry.empty {
                    insertInternal(oldEntry.hash, oldEntry.key, oldEntry.value)
                }
            }
        }

        freeBuffer(oldBuckets)
    }

    /// Internal insertion routine.
    @discardableResult
    private def insertInternal(_ hash: u64, _ key: owned K, _ val: owned V) -> Index {
        var insertPos = getIndexForPosition(hash)
        var dist = 0u
        var hash = hash

        loop {
            // If we found an empty bucket, fill it.
            if buckets[insertPos].empty {
                insertAtIndex(insertPos, hash, key, val)
                return insertPos
            }

            // Robin hood hashing - if we are further from the desired distance 
            // than the existing element, swap them and reinsert the existing element instead
            let existingElementDist = getProbeDistanceFor(buckets[dist].hash, insertPos)
            if dist > existingElementDist {
                mem.swap(&hash, &buckets[dist].hash)
                mem.swap(&key, &buckets[dist].key)
                mem.swap(&val, &buckets[dist].value)

                dist = existingElementDist
            }

            insertPos = getIndexForPosition(insertPos + 1)
            ++dist
        }

        unreachable!("bad dictionary layout!")
    }

    /// Lookup a key in the dictionary.
    /// \return the index of the key if found, \ref endIndex otherwise.
    private def lookupKey(_ key: K) -> Index {
        let hash = getHashFor(key)
        var desiredPos = getIndexForPosition(hash)
        var dist = 0u

        loop {
            var cap = capacity
            let entry = &buckets[desiredPos]

            if entry.empty {
                return -1 as! Index
            }
            if dist > getProbeDistanceFor(hash, desiredPos, cap) {
                return -1 as! Index
            }
            if entry.key == key {
                return desiredPos
            }

            desiredPos = getIndexForPosition(desiredPos + 1, cap)
            ++dist
        }

        unreachable!("bad dictionary layout!")
    }

    /// Lookup a key in the dictionary.
    /// \return the index of the key if found, `none` otherwise.
    def find(key: K) -> Index? {
        let idx = lookupKey(key)
        if idx == SentinelIndex {
            return none
        }

        return .Some(idx)
    }

    /// Insert \param value into the dictionary with the key \param key.
    /// \return a tuple of the index where the value is located, and whether or not
    ///         it was newly inserted or already existed in the dictionary. 
    @discardableResult
    def insert(key: owned K, value: owned V) -> (Index, Bool) {
        var Idx = lookupKey(key)
        if Idx != SentinelIndex {
            return (Idx, false)
        }

        size += 1
        if size > resizeTreshold {
            grow()
        }

        let hash = getHashFor(key)
        return (insertInternal(hash, key, value), true)
    }

    @discardableResult
    def erase(withKey key: K) -> Bool {
        let pos = lookupKey(key)
        if pos == SentinelIndex {
            return false
        }

        // deinitialize bucket value
        unsafe {
            builtin.deinit(buckets[pos])
        }

        // move forward until we find an empty bucket, or one with a DIB of 0
        var stopPos = pos
        while stopPos < capacity {
            var bucket = &buckets[stopPos + 1]
            if bucket.empty {
                break
            }
            if getProbeDistanceFor(bucket.hash, stopPos + 1, capacity) == 0 {
                break
            }

            ++stopPos
        }

        if stopPos != pos {
            // shift buckets from stop bucket backwards over the deleted one
            libc.memmove((buckets + pos) as! UnsafeMutableRawPtr,
                        (buckets + stopPos) as! UnsafeMutableRawPtr,
                        (stopPos - pos) * reflect.sizeOf<Entry>)
        }

        // mark last shifted bucket as empty
        buckets[stopPos].hash = 0

        return true
    }

    subscript (key: K) -> V? {
        get {
            let found = lookupKey(key)
            if found != SentinelIndex {
                return .Some(buckets[found].value)
            }

            return none
        }
    }

    subscript (key: K) -> V {
        set {
            self.insert(key, value: newVal)
        }
    }
}

extend Dictionary with Iterable {
    struct DictionaryIterator with IteratorProtocol {
        private let dict: Dictionary
        private var idx: Index = 0

        associatedType Element = Entry

        def mutating next() -> Entry? {
            if idx == dict.capacity {
                return none
            }

            if dict.buckets[idx].empty {
                ++idx
                return next()
            }

            return .Some(dict.buckets[idx++])
        }
    }

    associatedType Element = Entry
    associatedType It = DictionaryIterator

    def getIterator() -> It {
        return DictionaryIterator(dict: self)
    }
}

extend Dictionary with StringRepresentable {
    def toString() -> String {
        var s = "["

        var i = 0u
        for let keyValuePair in self {
            if i++ != 0 {
                s += ", "
            }

            s += String(keyValuePair.key)
            s += ": "
            s += String(keyValuePair.value)
        }

        s += "]"
        return s
    }
}
