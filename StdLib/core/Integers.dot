
import builtin

/// Internal protocol intended for marking integer
/// types that are known to the compiler.
internal protocol BuiltinIntegerType {}

/// A type that is representable by a builtin integer literal.
/// Used by the compiler to create values from integer literals.
public protocol ExpressibleByIntegerLiteral {
    associatedType IntegerType: BuiltinIntegerType = UInt
    init (integerLiteral i: IntegerType)
}

/// The default integer type used by the compiler for signed integer literals.
public alias DefaultSignedIntegerLiteralType = Int

/// The default integer type used by the compiler for unsigned integer literals.
public alias DefaultUnsignedIntegerLiteralType = UInt

/// A type that supports additive arithmetic operations.
public protocol AdditiveArithmetic with Equatable {
    /// The zero value.
    static prop zero: Self { get }

    /// Adds two values and produces their sum.
    def infix +(rhs: Self) -> Self

    /// Adds two values and stores the result in the left-hand-side variable.
    def mutating infix +=(rhs: Self)

    /// Substracts two values and produces their difference.
    def infix -(rhs: Self) -> Self

    /// Subtracts two values and stores the result in the left-hand-side variable.
    def mutating infix -=(rhs: Self)
}

extend AdditiveArithmetic {
    /// \inherit
    default def infix +(rhs: Self) -> Self {
        var lhs = self
        lhs += rhs
        return lhs
    }

    /// \inherit
    default def infix -(rhs: Self) -> Self {
        var lhs = self
        lhs -= rhs
        return lhs
    }
}

extend AdditiveArithmetic where Self is ExpressibleByIntegerLiteral {
    /// \inherit
    default static prop zero: Self {
        return 0
    }
}

public protocol Numeric with AdditiveArithmetic, ExpressibleByIntegerLiteral {
    /// Creates a new instance from the given integer, if it can be represented
    /// exactly.
    init? <T: BinaryInteger>(exactly source: T)

    /// A type that can represent the absolute value of any possible value of the
    /// conforming type.
    associatedType Magnitude: Comparable & Numeric

    /// The magnitude of this value.
    /// For any numeric value `x`, `x.magnitude` is the absolute value of `x`.
    prop magnitude: Magnitude { get }

    /// Multiplies two values and produces their product.
    def infix *(rhs: Self) -> Self

    /// Multiplies two values and stores the result in the left-hand-side variable.
    def mutating infix *=(rhs: Self)

    /// Exponentiates two values.
    def infix **(rhs: UInt) -> Self

    /// Exponentiates two values and stores the result in the left-hand-side variable.
    def mutating infix **=(rhs: UInt)
}

extend Numeric {
    /// \inherit
    default def infix *(rhs: Self) -> Self {
        var lhs = self
        lhs *= rhs
        return lhs
    }

    /// \inherit
    default def infix **(rhs: UInt) -> Self {
        var lhs = self
        lhs **= rhs
        return lhs
    }
}

/// A type that can represent both positive and negative values.
public protocol SignedNumeric with Numeric {
    /// Returns the additive inverse of the specified value.
    def prefix -() -> Self

    /// Replaces this value with its additive inverse.
    def mutating negate()
}

extend SignedNumeric {
    /// \inherit
    default def prefix -() -> Self {
        var copy = self
        copy.negate()

        return copy
    }

    /// \inherit
    default def mutating negate() {
        self = 0 - self
    }
}


/// Returns the absolute value of the given number.
public def abs<T: SignedNumeric>(_ x: T) -> T
    where T.Magnitude == T
{
    return x.magnitude
}

/// Returns the absolute value of the given number.
public def abs<T: SignedNumeric & Comparable>(_ x: T) -> T {
    return if x < (0 as T) then -x else x
}

extend AdditiveArithmetic {
    /// Returns the given number unchanged.
    def prefix +() -> Self {
        return self
    }
}

/// An integer type with a binary representation.
public protocol BinaryInteger with Hashable, Numeric, StringRepresentable,
                                   StringInitializable, Strideable {
    /// Impose additional constraints on the magnitude.
    associatedType Magnitude: BinaryInteger
        where Magnitude.Magnitude == Magnitude

    /// A Boolean value indicating whether this type is a signed integer type.
    static prop isSigned: Bool { get }

    /// Creates an integer from the given floating-point value, if it can be represented exactly.
    init? <T: BinaryFloatingPoint>(exactly source: T)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    init<T: BinaryFloatingPoint>(_ source: T)

    /// Creates a new instance from the given integer.
    init<T: BinaryInteger>(_ source: T)

    /// Creates a new instance from the bit pattern of the given instance by
    /// sign-extending or truncating to fit this type.
    init<T: BinaryInteger>(truncatingIfNeeded source: T)

    /// Creates a new instance with the representable value that's closest to the
    /// given integer.
    init<T: BinaryInteger>(clamping source: T)

    /// A type that represents the words of a binary integer.
    associatedType Words: RandomAccessCollection
        where Words.Element == UInt
        where Words.Index == Int

    /// A collection containing the words of this value's binary
    prop words: Words { get }

    /// The least significant word in this value's binary representation.
    prop _lowWord: UInt { get }

    /// Returns the integer binary logarithm of this value.
    ///
    /// If the value is negative or zero, a runtime error will occur.
    def _binaryLogarithm() -> Int

    /// The number of trailing zeros in this value's binary representation.
    prop trailingZeroBitCount: Int { get }

    /// Returns the quotient of dividing the first value by the second.
    def infix /(rhs: Self) -> Self

    /// Divides the first value by the second and stores the quotient in the
    def mutating infix /=(rhs: Self)

    /// Returns the remainder of dividing the first value by the second.
    def infix %(rhs: Self) -> Self

    /// Divides the first value by the second and stores the remainder in the left-hand side.
    def mutating infix %=(rhs: Self)

    /// Returns the inverse of the bits set in the argument.
    def prefix ~() -> Self

    /// Returns the result of performing a bitwise AND operation on the two given
    /// values.
    def infix &(rhs: Self) -> Self

    /// Stores the result of performing a bitwise AND operation on the two given
    def mutating infix &=(rhs: Self)

    /// Returns the result of performing a bitwise OR operation on the two given
    /// values.
    def infix |(rhs: Self) -> Self

    /// Stores the result of performing a bitwise OR operation on the two given
    def mutating infix |=(rhs: Self)

    /// Returns the result of performing a bitwise XOR operation on the two given
    /// values.
    def infix ^(rhs: Self) -> Self

    /// Stores the result of performing a bitwise XOR operation on the two given
    def mutating infix ^=(rhs: Self)

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right.
    def infix >> <RHS: BinaryInteger>(rhs: RHS) -> Self

    /// Stores the result of shifting a value's binary representation the
    /// specified number of digits to the right in the left-hand-side variable.
    def mutating infix >>= <RHS: BinaryInteger>(rhs: RHS)

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left.
    def infix << <RHS: BinaryInteger>(rhs: RHS) -> Self

    /// Stores the result of shifting a value's binary representation the
    /// specified number of digits to the left in the left-hand-side variable.
    def mutating infix <<= <RHS: BinaryInteger>(rhs: RHS)

    /// Returns the quotient and remainder of this value divided by the given
    /// value.
    def quotientAndRemainder(dividingBy rhs: Self) -> (Self, Self)

    /// Returns `true` if this value is a multiple of `other`, and `false` otherwise.
    def isMultiple(of other: Self) -> Bool

    /// Returns `-1` if this value is negative and `1` if it's positive;
    /// otherwise, `0`.
    prop signum: Self { get }
}

extend BinaryInteger {
    /// Creates a new value equal to zero.
    public init {
        self = 0
    }

    /// \inherit
    default def advanced(by value: Int) -> Self {
        return self + Self(value)
    }

    /// \inherit
    default prop signum: Self {
        if self > (0 as Self) {
            return 1
        }
        if self < (0 as Self) {
            return -1
        }

        return 0
    }

    /// \inherit
    default prop _lowWord: UInt {
        var it = words.getIterator()
        return it.next() ?? 0
    }

    /// \inherit
    default def _binaryLogarithm() -> Int {
        precondition!(self > (0 as Self))
        var (quotient, remainder) =
            (bitWidth &- 1).quotientAndRemainder(dividingBy: UInt.bitWidth)

        remainder = remainder &+ 1
        var word = UInt(truncatingIfNeeded: self >> (bitWidth &- remainder))

        // If, internally, a variable-width binary integer uses digits of greater
        // bit width than that of Magnitude.Words.Element (i.e., UInt), then it is
        // possible that `word` could be zero. Additionally, a signed variable-width
        // binary integer may have a leading word that is zero to store a clear sign
        // bit.
        while word == 0 {
            quotient = quotient &- 1
            remainder = remainder &+ UInt.bitWidth
            word = UInt(truncatingIfNeeded: self >> (bitWidth &- remainder))
        }

        // Note that the order of operations below is important to guarantee that
        // we won't overflow.
        return UInt.bitWidth &* quotient &+
            (UInt.bitWidth &- (word.leadingZeroBitCount &+ 1))
    }

    /// \inherit
    default def infix /(rhs: Self) -> Self {
        var lhs = self
        lhs /= rhs
        return lhs
    }

    /// \inherit
    default def infix %(rhs: Self) -> Self {
        var lhs = self
        lhs %= rhs
        return lhs
    }

    /// \inherit
    default def quotientAndRemainder(dividingBy rhs: Self) -> (Self, Self) {
        return (self / rhs, self % rhs)
    }

    /// \inherit
    default def isMultiple(of other: Self) -> Bool {
        if other == 0 { return self == 0 }
        return self.magnitude % other.magnitude == 0
    }

    /// \inherit
    default def infix &(rhs: Self) -> Self {
        var lhs = self
        lhs &= rhs
        return lhs
    }

    /// \inherit
    default def infix |(rhs: Self) -> Self {
        var lhs = self
        lhs |= rhs
        return lhs
    }

    /// \inherit
    default def infix ^(rhs: Self) -> Self {
        var lhs = self
        lhs ^= rhs
        return lhs
    }

    /// \inherit
    default def infix >> <RHS: BinaryInteger>(rhs: RHS) -> Self {
        var lhs = self
        lhs >>= rhs
        return lhs
    }

    /// \inherit
    default def infix << <RHS: BinaryInteger>(rhs: RHS) -> Self {
        var lhs = self
        lhs <<= rhs
        return lhs
    }
}

private let hexDigits:   [builtin.u8; ?] = "0123456789abcdef"
private let base64igits: [builtin.u8; ?] = "ABCDEFGHIJKLMNOPQRSTUVWYZabcdefghijklmnopqrstuvwxyz0123456789+/"

/// StringRepresentable conformance.
extend BinaryInteger {
    def toString<let Base: UInt>() -> String {
        var i = self
        var s = ""

        static if Self.isSigned {
            if i < 0 {
                s += '-'
                i = -i
            }
        }

        static if Base == 2 {
            s += "0b"
        }
        else static if Base == 8 {
            s += "0c"
        }
        else static if Base == 10 {
            // no prefix for decimal
        }
        else static if Base == 16 {
            s += "0x"
        }
        else static if Base == 64 {
            // no prefix for base64
        }
        else {
            static_assert(false, "Base must be one of 2, 8, 10, 16 or 64!")
        }
    
        var base = Self(Base)
        var neededDigits = 0u
        var _i = i

        loop {
            neededDigits += 1
            _i /= base

            if _i == 0 {
                break
            }
        }

        var power = UInt(neededDigits - 1)
        loop {
            var exp = base ** power
            var fits = i / exp

            static if Base == 64 {
                s += base64digits[fits]
            }
            else {
                s += hexDigits[fits]
            }

            i -= exp * fits
            if power == 0 {
                break
            }

            power -= 1
        }

        return s
    }

    /// \inherit
    default def toString() -> String {
        return toString<10>()
    }
}

/// StringInitializable conformance.
extend BinaryInteger {
    default init? (_ s: String) {
        self.init(0)

        if s.empty {
            return
        }

        var negative = false
        var power = 0
        var i = s.size - 1

        loop {
            if s[i] == '-' {
                if !isSigned {
                    return none
                }

                if i == 0 {
                    negative = true
                    continue
                } else {
                    return none
                }
            }

            var c = s[i]
            if !c.isAscii {
                return none
            }

            var byte = c.ascii
            if byte == '_' {
                // ignore
            } else if (byte < '0') || (byte > '9') {
                return none
            } else {
                self += Self((10 ** power) * (byte - '0'))
                power += 1
            }

            if i == 0 {
                break
            }

            i -= 1
        }

        if negative {
            negate()
        }
    }
}

/// Strideable conformance.
extend BinaryInteger {
    /// Returns a value that is offset the specified distance from this value.
    default def advanced(by n: Int) -> Self {
        if !Self.isSigned {
            return if n < (0 as Int)
                then self - Self(-n)
                else self + Self(n)
        }
        if (self < (0 as Self)) == (n < (0 as Self)) {
            return self + Self(n)
        }

        return if self.magnitude < n.magnitude
            then Self(Int(self) + n)
            else self + Self(n)
    }
}

/// Comparable conformance.
extend BinaryInteger {
    /// \inherit
    default def infix <=>(rhs: Self) -> Int {
        return (self - rhs) as Int
    }
}

/// An integer type that uses a fixed size for every instance.
public protocol FixedWidthInteger with BinaryInteger /* , LosslessStringConvertible*/ {
    /// Impose additional constraints on the magnitude.
    associatedType Magnitude: FixedWidthInteger & UnsignedInteger

    /// Access the bitwidth statically.
    static prop bitWidth: Int { get }

    /// The maximum representable integer in this type.
    static prop max: Self { get }

    /// The minimum representable integer in this type.
    static prop min: Self { get }

    /// Returns the sum of this value and the given value, along with a Boolean
    /// value indicating whether overflow occurred in the operation.
    def addingReportingOverflow(_ rhs: Self) -> (partialValue: Self, overflow: Bool)

    /// Returns the difference obtained by subtracting the given value from this
    /// value, along with a Boolean value indicating whether overflow occurred in
    def subtractingReportingOverflow(_ rhs: Self) -> (partialValue: Self, overflow: Bool)

    /// Returns the product of this value and the given value, along with a
    /// Boolean value indicating whether overflow occurred in the operation.
    def multipliedReportingOverflow(by rhs: Self) -> (partialValue: Self, overflow: Bool)

    /// Returns the quotient obtained by dividing this value by the given value,
    /// along with a Boolean value indicating whether overflow occurred in the
    /// operation.
    def dividedReportingOverflow(by rhs: Self) -> (partialValue: Self, overflow: Bool)

    /// Returns the remainder after dividing this value by the given value, along
    /// with a Boolean value indicating whether overflow occurred during division.
    def remainderReportingOverflow(dividingBy rhs: Self) -> (partialValue: Self, overflow: Bool)

    /// Returns a tuple containing the high and low parts of the result of
    /// multiplying this value by the given value.
    def multipliedFullWidth(by other: Self) -> (high: Self, low: Self.Magnitude)

    /// Returns a tuple containing the quotient and remainder obtained by dividing
    /// the given value by this value.
    def dividingFullWidth(_ dividend: (high: Self, low: Self.Magnitude))
        -> (quotient: Self, remainder: Self)

    init(_truncatingBits bits: UInt)

    /// The number of bits equal to 1 in this value's binary representation.
    prop nonzeroBitCount: Int { get }

    /// The number of leading zeros in this value's binary representation.
    prop leadingZeroBitCount: Int { get }

    /// Creates an integer from its big-endian representation, changing the byte
    init(bigEndian value: Self)

    /// Creates an integer from its little-endian representation, changing the
    init(littleEndian value: Self)

    /// The big-endian representation of this integer.
    prop bigEndian: Self { get }

    /// The little-endian representation of this integer.
    prop littleEndian: Self { get }

    /// A representation of this integer with the byte order swapped.
    prop byteSwapped: Self { get }

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width.
    def infix &>>(rhs: Self) -> Self

    /// Calculates the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    def mutating infix &>>=(rhs: Self)

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width.
    def infix &<<(rhs: Self) -> Self

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    def mutating infix &<<=(rhs: Self)
}

extend FixedWidthInteger {
    /// \inherit
    default def _binaryLogarithm() -> Int {
        precondition!(self > (0 as Self))
        return Self.bitWidth &- (leadingZeroBitCount &+ 1)
    }

    /// \inherit
    default init (littleEndian value: Self) {
        static if reflect.endianness == .little {
            self = value
        } else {
            self = value.byteSwapped
        }
    }

    /// \inherit
    default init (bigEndian value: Self) {
        static if reflect.endianness != .little {
            self = value
        } else {
            self = value.byteSwapped
        }
    }

    /// The little-endian representation of this integer.
    default prop littleEndian: Self {
        static if reflect.endianness == .little {
            return self
        } else {
            return self.byteSwapped
        }
    }

    /// The big-endian representation of this integer.
    default prop bigEndian: Self {
        static if reflect.endianness != .little {
            return self
        } else {
            return self.byteSwapped
        }
    }

    /// \inherit
    default def infix &>>(rhs: Self) -> Self {
        var lhs = self
        lhs &>>= rhs
        return lhs
    }

    /// \inherit
    def infix &>> <RHS: BinaryInteger>(rhs: RHS) -> Self {
        return self &>> Self(truncatingIfNeeded: rhs)
    }

    /// \inherit
    def mutating infix &>>= <RHS: BinaryInteger>(rhs: RHS) -> Self {
        self = self &>> rhs
    }

    /// \inherit
    default def infix &<<(rhs: Self) -> Self {
        var lhs = self
        lhs &<<= rhs
        return lhs
    }

    /// \inherit
    def infix &<< <RHS: BinaryInteger>(rhs: RHS) -> Self {
        return self &<< Self(truncatingIfNeeded: rhs)
    }

    /// \inherit
    def mutating infix &<<= <RHS: BinaryInteger>(rhs: RHS) -> Self {
        self = self &<< rhs
    }
}

extend FixedWidthInteger {
    /// \inherit
    default def prefix ~() -> Self {
        return 0 &- self &- 1
    }

    /// \inherit
    default def infix >> <Other: BinaryInteger>(rhs: Other) -> Self {
        var lhs = self
        _nonMaskingRightShiftGeneric(&lhs, rhs)
        return lhs
    }

    /// \inherit
    default def mutating infix >>= <Other: BinaryInteger>(rhs: Other) {
        _nonMaskingRightShiftGeneric(&self, rhs)
    }

    /// \inherit
    default def mutating infix &>>= (rhs: Self) {
        var rhs = rhs & (bitWidth - 1)
        self >>= rhs
    }

    static def _nonMaskingRightShiftGeneric<Other: BinaryInteger>(
        _ lhs: mut ref Self, _ rhs: Other
    ) {
        var rhs = Int(rhs)
        let shift = if rhs < -Self.bitWidth then -Self.bitWidth
                    else if rhs > Self.bitWidth then Self.bitWidth
                    else rhs

        lhs = _nonMaskingRightShift(lhs, shift)
    }

    static def _nonMaskingRightShift(_ lhs: Self, _ rhs: Int) -> Self {
        let overshiftR = if Self.isSigned then lhs &>> (Self.bitWidth - 1) else 0
        let overshiftL: Self = 0
        if rhs >= 0 {
            if rhs < Self.bitWidth {
                return lhs &>> Self(truncatingIfNeeded: rhs)
            }

            return overshiftR
        }

        if rhs <= -Self.bitWidth {
            return overshiftL
        }

        return lhs &<< -rhs
    }

    /// \inherit
    default def infix << <Other: BinaryInteger>(rhs: Other) -> Self {
        var lhs = self
        _nonMaskingLeftShiftGeneric(&lhs, rhs)
        return lhs
    }

    /// \inherit
    default def mutating infix <<= <Other: BinaryInteger>(rhs: Other) {
        _nonMaskingLeftShiftGeneric(&self, rhs)
    }

    /// \inherit
    default def mutating infix &<<= (rhs: Self) {
        var rhs = rhs & (bitWidth - 1)
        self <<= rhs
    }

    static def _nonMaskingLeftShiftGeneric <Other: BinaryInteger>(
        _ lhs: mut ref Self, _ rhs: Other
    ) {
        var rhs = Int(rhs)
        let shift = if rhs < -Self.bitWidth then -Self.bitWidth
                    else if rhs > Self.bitWidth then Self.bitWidth
                    else rhs

        lhs = _nonMaskingLeftShift(lhs, shift)
    }

    static def _nonMaskingLeftShift(_ lhs: Self, _ rhs: Int) -> Self {
        let overshiftR = if Self.isSigned then lhs &>> (Self.bitWidth - 1) else 0
        var overshiftL: Self = 0
        if rhs >= 0 {
            if rhs < Self.bitWidth {
                return lhs &<< Self(truncatingIfNeeded: rhs)
            }

            return overshiftL
        }

        if rhs <= -Self.bitWidth {
            return overshiftR
        }

        return lhs &>> -rhs
    }
}

extend FixedWidthInteger {
    static def _convert<Source: BinaryFloatingPoint>(
        from source: Source
    ) -> (value: Self?, exact: Bool) {
        if likely(source.isZero) { return (0, true) }
        if likely(!source.isFinite) { return (none, false) }
        if !Self.isSigned && source <= -1 { return (none, false) }

        let exponent = source.exponent
        if likely(Self.bitWidth <= exponent) {
            return (none, false)
        }

        let minBitWidth = source.significandWidth
        let isExact = (minBitWidth <= exponent)
        let bitPattern = source.significandBitPattern
        // `RawSignificand.bitWidth` is not available if `RawSignificand` does not
        // conform to `FixedWidthInteger`; we can compute this value as follows if
        // `source` is finite:
        let bitWidth = minBitWidth &+ bitPattern.trailingZeroBitCount
        let shift = exponent - Source.Exponent(bitWidth)
        // Use `Self.Magnitude` to prevent sign extension if `shift < 0`.
        let shiftedBitPattern = if Self.Magnitude.bitWidth > bitWidth
            then Self.Magnitude(truncatingIfNeeded: bitPattern) << shift
            else Self.Magnitude(truncatingIfNeeded: bitPattern << shift)

        if unlikely(Self.isSigned && Self.bitWidth &- 1 == exponent) {
            return if source < 0 && shiftedBitPattern == 0
                then (Self.min, isExact)
                else (none, false)
        }

        let magnitude = ((1 as Self.Magnitude) << exponent) | shiftedBitPattern
        return (
            if Self.isSigned && source < 0 then 0 &- Self(magnitude) else Self(magnitude),
            isExact)
    }

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero. Any fractional part of the value passed as `source` is removed.
    @inline(always)
    init<T: BinaryFloatingPoint>(_ source: T) {
        let (value, exact) = Self._convert(from: source)
        if !value {
            sys.reportFatalError("value cannot be represented")
        }

        self = value!
    }

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    default init? <T: BinaryFloatingPoint>(exactly source: T) {
        let (value, exact) = Self._convert(from: source)
        if !value || !exact {
            sys.reportFatalError("value cannot be represented exactly")
        }

        self = value!
    }

    /// Creates a new instance with the representable value that's closest to the
    /// given integer.
    default init<Other: BinaryInteger>(clamping source: Other) {
        if unlikely(source < Self.min) {
            self = Self.min
        }
        else if unlikely(source > Self.max) {
            self = Self.max
        }
        else {
            self = Self(truncatingIfNeeded: source)
        }
    }

    /// Creates a new instance from the bit pattern of the given instance by
    /// truncating or sign-extending if needed to fit this type.
    @inline(always)
    default init<T: BinaryInteger>(truncatingIfNeeded source: T) {
        if Self.bitWidth <= Int.bitWidth {
            self = Self(_truncatingBits: source._lowWord)
        }
        else {
            let neg = source < (0 as T)
            var result: Self = if neg then ~0 else 0
            var shift: Self = 0
            let width = Self(_truncatingBits: Self.bitWidth._lowWord)
            for word in source.words {
                if shift >= width { break }

                // Masking shift is OK here because we have already ensured
                // that shift < Self.bitWidth. Not masking results in
                // infinite recursion.
                result ^= Self(_truncatingBits: if neg then ~word else word) &<< shift
                shift += Self(_truncatingBits: Int.bitWidth._lowWord)
            }

            self = result
        }
    }

    static prop _highBitIndex: Self {
        return Self.init(_truncatingBits: UInt(Self.bitWidth.value) &- 1)
    }

    /// Returns the sum of the two given values, wrapping the result in case of
    /// any overflow.
    def infix &+ (rhs: Self) -> Self {
        return self.addingReportingOverflow(rhs).partialValue
    }

    /// Adds two values and stores the result in the left-hand-side variable,
    /// wrapping any overflow.
    def mutating infix &+= (rhs: Self) {
        self = self &+ rhs
    }

    /// Returns the difference of the two given values, wrapping the result in
    /// case of any overflow.
    def infix &- (rhs: Self) -> Self {
        return self.subtractingReportingOverflow(rhs).partialValue
    }

    /// Subtracts the second value from the first and stores the difference in the
    /// left-hand-side variable, wrapping any overflow.
    def mutating infix &-= (rhs: Self) {
        self = self &- rhs
    }

    /// Returns the product of the two given values, wrapping the result in case
    /// of any overflow.
    def infix &* (rhs: Self) -> Self {
        return self.multipliedReportingOverflow(by: rhs).partialValue
    }

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable, wrapping any overflow.
    def mutating infix &*= (rhs: Self) {
        self = self &* rhs
    }
}

/// An integer type that can represent only nonnegative values.
public protocol UnsignedInteger with BinaryInteger { }

extend UnsignedInteger {
    /// \inherit
    default prop magnitude: Magnitude {
        return self
    }

    /// A Boolean value indicating whether this type is a signed integer type.
    default static prop isSigned: Bool {
        return false
    }
}

extend UnsignedInteger where Self is FixedWidthInteger {
    /// Creates a new instance from the given integer.
    @inline(always)
    default init<T: BinaryInteger>(_ source: T) {
        // This check is potentially removable by the optimizer
        if T.isSigned {
            precondition!(source >= (0 as T), "Negative value is not representable")
        }

        // This check is potentially removable by the optimizer
        if source.bitWidth >= Self.bitWidth {
            precondition!(source <= Self.max,
                "Not enough bits to represent the passed value")
        }

        self.init(truncatingIfNeeded: source)
    }

    /// Creates a new instance from the given integer, if it can be represented
    /// exactly.
    @inline(always)
    default init? <T: BinaryInteger>(exactly source: T) {
        // This check is potentially removable by the optimizer
        if T.isSigned && source < (0 as T) {
            return none
        }

        // The width check can be eliminated by the optimizer
        if source.bitWidth >= Self.bitWidth && source > Self.max {
            return none
        }

        self.init(truncatingIfNeeded: source)
    }

    /// The maximum representable integer in this type.
    default static prop max: Self { return ~0 }

    /// The minimum representable integer in this type.
    default static prop min: Self { return 0 }
}

/// An integer type that can represent both positive and negative values.
public protocol SignedInteger with BinaryInteger, SignedNumeric {
}

extend SignedInteger {
    /// A Boolean value indicating whether this type is a signed integer type.
    default static prop isSigned: Bool {
        return true
    }
}

extend SignedInteger where Self is FixedWidthInteger {
    /// Creates a new instance from the given integer.
    @inline(always)
    default init<T: BinaryInteger>(_ source: T) {
        // This check is potentially removable by the optimizer
        if T.isSigned && source.bitWidth > Self.bitWidth {
            precondition!(source >= T(Self.min),
                          "Not enough bits to represent a signed value")
        }

        // This check is potentially removable by the optimizer
        if ((source.bitWidth > Self.bitWidth) ||
             (source.bitWidth == Self.bitWidth && !T.isSigned)) {
            precondition!(source <= T(Self.max),
                          "Not enough bits to represent the passed value")
        }

        self.init(truncatingIfNeeded: source)
    }

    /// Creates a new instance from the given integer, if it can be represented
    /// exactly.
    @inline(always)
    default init? <T: BinaryInteger>(exactly source: T) {
        // This check is potentially removable by the optimizer
        if T.isSigned && source.bitWidth > Self.bitWidth && source < Self.min {
            return none
        }

        // The width check can be eliminated by the optimizer
        if ((source.bitWidth > Self.bitWidth ||
                (source.bitWidth == Self.bitWidth && !T.isSigned)) &&
             source > Self.max) {
            return none
        }

        self.init(truncatingIfNeeded: source)
    }

    /// The maximum representable integer in this type.
    default static prop max: Self { return ~min }

    /// The minimum representable integer in this type.
    default static prop min: Self {
        return (-1 as Self) &<< Self._highBitIndex
    }

    default def isMultiple(of other: Self) -> Bool {
        // Nothing but zero is a multiple of zero.
        if other == 0 { return self == 0 }
        // Special case to avoid overflow on .min / -1 for signed types.
        if other == -1 { return true }
        // Having handled those special cases, this is safe.
        return self % other == 0
    }
}

/// Returns the given integer as the equivalent value in a different integer
/// type.
public def numericCast<T: BinaryInteger, U: BinaryInteger>(_ x: T) -> U {
    return U(x)
}

/// Returns the given numeric value reinterpreted as a different type of the same bitwidth.
internal def _builtinNumericCast<T: ?, U: ?>(_ x: T) -> U {
    return builtin.loadFromPointer(
        builtin.reinterpretCast<U>(builtin.addressOf(x)))
}

/// Define an operator that forwards the operation to the builtin integer value.
fileprivate macro proxy_operator {
    ($(($op:tok, $builtinName:tok)),*) => { $(
        def mutating infix ${$op =}(_ rhs: Self) {
            value = builtin.$builtinName(value, rhs.value)
        }
    )... }
}

fileprivate macro proxy_overflow_operator {
    ($(($op:tok, $builtinName:tok)),*) => { $(
        def mutating infix ${$op =}(_ rhs: Self) {
            let (result, overflow) = builtin.$builtinName(value, rhs.value)
            if unlikely(Bool(overflow)) {
                sys.reportFatalError("unexpected integer overflow")
            }

            value = result
        }
    )... }
}

/// Defines a wrapper for a builtin integer type.
macro integer_type{
    ($Self:tok, $OtherSelf:tok, $BuiltinType:tok) => {
        @_builtin @_semantics("builtin_integer_type")
        public struct $Self with FixedWidthInteger, BuiltinIntegerType {
            /// The builtin integer value.
            internal var value: builtin.$BuiltinType

            /// Default C'tor, initializes to zero.
            init {
                self.value = 0
            }

            /// Creates a new instance with the same memory representation as the given
            /// value.
            init (bitPattern x: $OtherSelf) {
                value = x.value as builtin.$BuiltinType
            }

            /// Internal memberwise C'tor.
            internal init (_ value: builtin.$BuiltinType) {
                self.value = value
            }

            /// \inherit
            associatedType IntegerType = Self

            /// \inherit
            init (integerLiteral value: Self) {
                self = value
            }
        }

        extend $Self {
            /// The number of bits in the current binary representation of this value.
            static prop bitWidth: Int {
                return Int(bitPattern: __traits(bitwidth_of, builtin.$BuiltinType))
            }

            /// \inherit
            public prop leadingZeroBitCount: Int {
                return Int(_builtinNumericCast<builtin.i64>(builtin.${ctlz_ $BuiltinType}(value)))
            }

            /// \inherit
            public prop trailingZeroBitCount: Int {
                return Int(_builtinNumericCast<builtin.i64>(builtin.${cttz_ $BuiltinType}(value)))
            }

            /// \inherit
            public prop nonzeroBitCount: Int {
                return Int(_builtinNumericCast<builtin.i64>(builtin.${ctpop_ $BuiltinType}(value)))
            }

            /// A type that represents the words of this integer.
            public struct IntegerWords with RandomAccessCollection {
                associatedType Element = UInt
                associatedType Index = Int
                associatedType Indices = Range<Int>
                associatedType SubSequence = Slice<Self>

                internal var value: $Self

                init (_ value: $Self) {
                    self.value = value
                }

                prop size: Int {
                    return $Self.bitWidth / 8
                }

                prop startIndex: Int { return 0 }
                prop endIndex: Int { return size }
                prop indices: Indices { return startIndex..endIndex }

                subscript(position: Int) -> UInt {
                    precondition!(position >= 0, "Negative word index")
                    precondition!(position < endIndex, "Word index out of range")
                    let shift = UInt(position.value) &* 64 // FIXME
                    return (value &>> $Self(_truncatingBits: shift))._lowWord
                }
            }

            /// \inherit
            associatedType Words = IntegerWords

            /// \inherit
            prop words: Words {
                return Words(self)
            }

            /// \inherit
            prop _lowWord: UInt {
                return UInt(self)
            }

            /// \inherit
            init(_truncatingBits bits: UInt) {
                self.init(_builtinNumericCast(bits.value))
            }

            /// \inherit
            prop byteSwapped: Self {
                if bitWidth <= 8 {
                    return self
                }

                return Self(builtin.${bswap_ $BuiltinType}(value))
            }

            // Operators without overflow.
            proxy_operator!{
                (&, ${and_ $BuiltinType}),
                (|, ${or_ $BuiltinType}),
                (^, ${xor_ $BuiltinType}),

                (&+, ${add_ $BuiltinType}),
                (&-, ${sub_ $BuiltinType}),
                (&*, ${mul_ $BuiltinType})
            }

            /// \inherit
            def mutating infix **= (_ rhs: UInt) {
                value = ${rt._cdot_intpow_ $BuiltinType}(value, rhs.value)
            }

            /// \inherit
            def dividedReportingOverflow(by rhs: Self) -> (partialValue: Self, overflow: Bool) {
                if unlikely(rhs == 0) {
                    return (rhs, true)
                }
                if unlikely(self == .min && rhs == -1) {
                    return (rhs, true)
                }

                return (self / rhs, false)
            }

            /// \inherit
            def remainderReportingOverflow(dividingBy rhs: Self)
                    -> (partialValue: Self, overflow: Bool) {
                if unlikely(rhs == 0) {
                    return (rhs, true)
                }
                if unlikely(self == .min && rhs == -1) {
                    return (rhs, true)
                }

                return (self % rhs, false)
            }

            /// \inherit
            def mutating infix /= (_ rhs: Self) {
                let (result, overflow) = dividedReportingOverflow(by: rhs)
                if overflow {
                    sys.reportFatalError("overflow encountered during integer division!")
                }

                self = result
            }

            /// \inherit
            def mutating infix %= (_ rhs: Self) {
                let (result, overflow) = remainderReportingOverflow(dividingBy: rhs)
                if overflow {
                    sys.reportFatalError("overflow encountered during integer division!")
                }

                self = result
            }

            /// \inherit
            def multipliedFullWidth(by other: Self) -> (high: Self, low: Self.Magnitude) {
                let lhs_: builtin.u128 = _builtinNumericCast(self.value)
                let rhs_: builtin.u128 = _builtinNumericCast(other.value)

                let res = lhs_ * rhs_
                let low = Magnitude(_builtinNumericCast(res))
                let shifted = res << bitWidth
                let high = Self(_builtinNumericCast(shifted))

                return (high: high, low: low)
            }

            /// \inherit
            def dividingFullWidth(_ dividend: (high: Self, low: Self.Magnitude))
                -> (quotient: Self, remainder: Self) {
                precondition!(false, "Operation not supported")
            }
        }
    }
}

/// Define additional operations for signed integers.
macro signed_integer{
    ($(($Self:tok, $BuiltinType:tok))*) => { $(
        integer_type!{$Self, ${U $Self}, $BuiltinType}

        extend $Self with SignedInteger {
            /// \inherit
            associatedType Magnitude = ${U $Self}

            /// \inherit
            prop magnitude: Magnitude {
                let base = Magnitude(_builtinNumericCast(value))
                return if self < (0 as $Self) then ~base &+ 1 else base
            }

            /// \inherit
            def addingReportingOverflow(_ rhs: Self) -> (partialValue: Self, overflow: Bool) {
                var (result, overflow) = builtin.${sadd_with_overflow_ $BuiltinType}(value, rhs.value)
                return (Self(result), Bool(overflow))
            }

            /// \inherit
            def subtractingReportingOverflow(_ rhs: Self) -> (partialValue: Self, overflow: Bool) {
                var (result, overflow) = builtin.${ssub_with_overflow_ $BuiltinType}(value, rhs.value)
                return (Self(result), Bool(overflow))
            }

            /// \inherit
            def multipliedReportingOverflow(by rhs: Self) -> (partialValue: Self, overflow: Bool) {
                var (result, overflow) = builtin.${smul_with_overflow_ $BuiltinType}(value, rhs.value)
                return (Self(result), Bool(overflow))
            }

            proxy_overflow_operator!{
                (+, ${sadd_with_overflow_ $BuiltinType}),
                (-, ${ssub_with_overflow_ $BuiltinType}),
                (*, ${smul_with_overflow_ $BuiltinType})
            }
        }

        extend $Self with Randomizable {
            /// \inherit
            static def random() -> Self {
                var val = rand.SystemRandomNumberGenerator().nextInt(upperBound: ${U $Self}.max)
                return Self(bitPattern: val)
            }
        }
    )... }
}

/// Define additional operations for unsigned integers.
macro unsigned_integer{
    ($(($Self:tok, $BuiltinType:tok))*) => { $(
        integer_type!{${U $Self}, $Self, $BuiltinType}

        extend ${U $Self} with UnsignedInteger {
            /// \inherit
            associatedType Magnitude = ${U $Self}

            /// \inherit
            prop magnitude: Magnitude {
                return self
            }

            /// \inherit
            def addingReportingOverflow(_ rhs: Self) -> (partialValue: Self, overflow: Bool) {
                var (result, overflow) = builtin.${uadd_with_overflow_ $BuiltinType}(value, rhs.value)
                return (Self(result), Bool(overflow))
            }

            /// \inherit
            def subtractingReportingOverflow(_ rhs: Self) -> (partialValue: Self, overflow: Bool) {
                var (result, overflow) = builtin.${usub_with_overflow_ $BuiltinType}(value, rhs.value)
                return (Self(result), Bool(overflow))
            }

            /// \inherit
            def multipliedReportingOverflow(by rhs: Self) -> (partialValue: Self, overflow: Bool) {
                var (result, overflow) = builtin.${umul_with_overflow_ $BuiltinType}(value, rhs.value)
                return (Self(result), Bool(overflow))
            }

            proxy_overflow_operator!{
                (+, ${uadd_with_overflow_ $BuiltinType}),
                (-, ${usub_with_overflow_ $BuiltinType}),
                (*, ${umul_with_overflow_ $BuiltinType})
            }
        }

        extend ${U $Self} with Randomizable {
            /// \inherit
            static def random() -> Self {
                var val = rand.SystemRandomNumberGenerator().nextInt(upperBound: Self.max)
                return Self(exactly: val)
            }
        }
    )... }
}

signed_integer!{ (Int8, i8) (Int16, i16) (Int32, i32) (Int64, i64) (Int128, i128) }
unsigned_integer!{ (Int8, u8) (Int16, u16) (Int32, u32) (Int64, u64) (Int128, u128) }

extend Int8 with ExpressibleByASCIILiteral {
    init (asciiLiteral value: UInt8) {
        self.init(bitPattern: value)
    }
}

extend UInt8 with ExpressibleByASCIILiteral {
    init (asciiLiteral value: UInt8) {
        self = value
    }
}

/// The default signed integer type.
public alias Int = Int64

/// The default unsigned integer type.
public alias UInt = UInt64

/// An integer that can hold a single byte.
public alias Byte = UInt8
