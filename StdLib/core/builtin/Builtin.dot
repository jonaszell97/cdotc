
@compiletime
module std.builtin

/// Builtin token type.
@_builtin alias TokenType

/// C-like void type.
@_builtin alias CVoid

/// Raw pointer type.
@_builtin alias RawPointer

/// Raw typed pointer type.
@_builtin alias RawPointer<T>

/// Undefined value for a given type.
@_builtin alias undefValue<T>: T

namespace experimental {

macro builtin_int(
    ($($Self:tok),*) => { $(
        /// Builtin integer type.
        @_builtin alias $Self
    )... }
)

builtin_int!(Int8, UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64)

}

/// Returns the size of a type through indexing operations.
public def _sizeOf<T>() -> UInt {
    var ptr: UnsafePtr<T> = __nullptr
    var off = ptr + 1u

    return off as! UInt
}

/// Dereferences the given pointer \param t, intended for UFCS.
public def deref<T>(_ t: UnsafeMutablePtr<T>) -> T {
    return loadFromPointer(t)
}

/// Returns true if the given pointer \param t is null, intended for UFCS.
public def isNull<T>(_ t: UnsafePtr<T>) -> Bool {
    return t == 0 as! UnsafePtr<T>
}

/// Create a copy of the given value, if its type is copyable.
public def copy<T>(_ t: T) -> T

/// Returns the meta type of the given expression.
/// The passed expression will not be evaluated at runtime.
@_builtin public def decltype<T>(of t: borrow T) -> MetaType<T>

/// Allocate \param size bytes on the stack.
public def allocStack(bytes: UInt) -> UnsafeMutableRawPtr

/// Allocate space for \param size values of type T on the stack.
public def allocStack<T>(count: UInt) -> UnsafeMutablePtr<T>

/// Turns a given reference into a mutable pointer.
public def addressOf<T>(_ t: mut ref T) -> UnsafeMutablePtr<T>

/// Turns a given reference into an immutable pointer.
public def addressOf<T>(_ t: ref T) -> UnsafePtr<T>

/// Loads the value pointed at by \param ptr.
public def loadFromPointer<T>(_ ptr: UnsafePtr<T>) -> T

/// Stores \param val to the pointer \param ptr.
public def storeToPointer<T>(_ val: owned T, to ptr: UnsafeMutablePtr<T>)

/// Stores \param val to the pointer \param ptr, which is assumed to be uninitialized.
public def uninitializedStore<T>(_ val: owned T, to ptr: UnsafeMutablePtr<T>) -> Void {
    // retain the stored value if it's a class
    retainIfNecessary(&val)

    // be careful not to trigger a deinitialization of *ptr here
    mem.copy(to: ptr as! UnsafeMutablePtr<Byte>,
             from: builtin.addressOf(&val) as! UnsafePtr<Byte>,
             reflect.sizeOf<T>)

    // Make sure the value isn't cleaned up.
    consume(val)
}

/// Initialize a struct or class in manually allocated memory.
public def constructInPlace<T, ...Args>(to ptr: UnsafeMutablePtr<T>,
                                        _ args: owned Args...) {
    // This is never actually exected, just used to verify that the type is 
    // constructible with the given arguments.
    _ = T(_: args...)
}

/// Move a value instead of copying it.
public def move<T>(_ t: owned T) -> T

/// Consume a value, effectively removing all scheduled cleanups.
public def consume<T>(_ t: owned T)

public def reinterpretCast<DstTy, SrcTy>(_ val: UnsafePtr<SrcTy>) -> UnsafePtr<DstTy>
public def reinterpretCast<DstTy, SrcTy>(_ val: UnsafeMutablePtr<SrcTy>) -> UnsafeMutablePtr<DstTy>

public def unsafeConstCast<T>(_ val: UnsafePtr<T>) -> UnsafeMutablePtr<T>

/// Retain the passed value, i.e. increase its strong refcount by 1.
public def retainValue<T>(_ t: mut ref T) where T is class

/// Release the passed value, i.e. decrease its strong refcount by 1.
public def releaseValue<T>(_ t: mut ref T) where T is class

/// Retain the passed value, but only if it's a class
public def retainIfNecessary<T>(_ t: mut ref T) where T is class { retainValue(&t) }
public def retainIfNecessary<T>(_ t: mut ref T) {}

/// Release the passed value, but only if it's a class
public def releaseIfNecessary<T>(_ t: mut ref T) where T is class { releaseValue(&t) }
public def releaseIfNecessary<T>(_ t: mut ref T) {}

/// Trigger deinitialization of the given value, that means
///  - calling the deinitializer for structs and enums
///  - decreasing the strong refcount for classes
///  - doing nothing for primitive values
public def deinit<T>(_ t: owned T)

public def printCTFEStacktrace() -> Void

public def memcpy(dst: UnsafeMutableRawPtr, src: UnsafeRawPtr,
                  size: UInt, align: UInt = 1) -> Void

public def memset(memory dst: UnsafeMutableRawPtr, value: Byte, size: UInt) -> Void

public def isUnique<T>(_ t: borrow T) -> Bool where T is class {
    return strongRefcount(of: t) == 1
}

public def strongRefcount<T>(of t: borrow T) -> UInt where T is class {
    let refc = t as! UnsafePtr<Refcounted>
    return refc->strongRefcount
}

public def weakRefcount<T>(of t: borrow T) -> UInt where T is class {
    let refc = t as! UnsafePtr<Refcounted>
    return refc->weakRefcount
}

internal def llvm_intrinsic<RetTy, ...Args>(_ name: UnsafePtr<u8>, _ args: Args...) -> RetTy

//===--------------------------------------------------------------------===//
// Math intrinsics
//===--------------------------------------------------------------------===//

public def log10_f64(_ val: f64) -> f64 {
    return llvm_intrinsic("llvm.log10.f64", val)
}

public def log2_f64(_ val: f64) -> f64 {
    return llvm_intrinsic("llvm.log2.f64", val)
}

public def log_f64(_ val: f64) -> f64 {
    return llvm_intrinsic("llvm.log.f64", val)
}

public def ctlz_i64(_ val: i64) -> u64 {
    return llvm_intrinsic("llvm.ctlz.i64", val, false)
}

public def ctlz_u64(_ val: u64) -> u64 {
    return llvm_intrinsic("llvm.ctlz.i64", val, false)
}

public def cttz_i64(_ val: i64) -> u64 {
    return llvm_intrinsic("llvm.cttz.i64", val, false)
}

public def cttz_u64(_ val: u64) -> u64 {
    return llvm_intrinsic("llvm.cttz.i64", val, false)
}

public def floor_f64(_ val: f64) -> f64 {
    return llvm_intrinsic("llvm.floor.f64", val)
}

public def ceil_f64(_ val: f64) -> f64 {
    return llvm_intrinsic("llvm.ceil.f64", val)
}

public def popcnt_i64(_ val: i64) -> i64 {
    return llvm_intrinsic("llvm.ctpop.i64", val)
}

public def popcnt<T>(_ val: T) -> T where IsIntegral<T> {
    return popcnt_i64(val as i64) as T
}

//===--------------------------------------------------------------------===//
// Atomic intrinsics
//===--------------------------------------------------------------------===//

internal def atomic_load<T>(_ addr: UnsafePtr<T>, _ memoryOrder: i32) -> T
internal def atomic_store<T>(_ value: owned T,
                             _ addr: UnsafeMutablePtr<T>,
                             _ memoryOrder: i32) -> Void

/// Expands to an instruction that atomically checks whether a specified value 
/// is in a memory location, and, if it is, stores a new value.
/// @return the value that was loaded.
internal def atomic_cmpxchg<T>(_ ptr: UnsafeMutablePtr<T>, _ cmp: T, _ newVal: T,
                               _ successOrdering: i32,
                               _ failureOrdering: i32) -> T

/// This enumeration lists the possible modifications atomicrmw can make.  In
/// the descriptions, 'p' is the pointer to the instruction's memory location,
/// 'old' is the initial value of *p, and 'v' is the other value passed to the
/// instruction.  These instructions always return 'old'.
internal enum AtomicRMWBinOp {
    /// *p = v
    case Xchg = 0,
    /// *p = old + v
    Add,
    /// *p = old - v
    Sub,
    /// *p = old & v
    And,
    /// *p = ~(old & v)
    Nand,
    /// *p = old | v
    Or,
    /// *p = old ^ v
    Xor,
    /// *p = old >signed v ? old : v
    Max,
    /// *p = old <signed v ? old : v
    Min,
    /// *p = old >unsigned v ? old : v
    UMax,
    /// *p = old <unsigned v ? old : v
    UMin
}

/// Expands to an instruction that atomically reads a memory location,
/// combines it with another value, and then stores the result back.
/// @return the old value.
internal def atomic_rmw<T>(_ op: AtomicRMWBinOp,
                           _ ptr: UnsafePtr<T>,
                           _ val: T,
                           _ ordering: i32) -> T

//===--------------------------------------------------------------------===//
// Coroutine intrinsics
//===--------------------------------------------------------------------===//

/// Resume the coroutine referenced by this handle.
internal def coro_resume(_ hdl: UnsafeRawPtr) -> builtin.CVoid {
   return llvm_intrinsic("llvm.coro.resume", hdl) 
}

/// Destroy the coroutine referenced by this handle.
internal def coro_destroy(_ hdl: UnsafeRawPtr) -> builtin.CVoid {
   return llvm_intrinsic("llvm.coro.destroy", hdl) 
}

/// Returns true if the given corutine has run to completion.
internal def coro_done(_ hdl: UnsafeRawPtr) -> i1 {
   return llvm_intrinsic("llvm.coro.done", hdl) 
}

/// Get a pointer to the promise of this coroutine.
internal def coro_promise<T>(_ hdl: UnsafeRawPtr) -> UnsafeMutablePtr<T> {
   return (llvm_intrinsic<UnsafeMutableRawPtr>("llvm.coro.promise", hdl, reflect.alignOf<T>, false) 
            as! UnsafeMutablePtr<T>)
}
