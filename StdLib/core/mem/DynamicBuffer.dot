
// module std.mem

// using std.math

// public struct DynamicBuffer<T> {
//     private var _data:     UnsafeMutablePtr<T> = 0 as! UnsafeMutablePtr<T>
//     private var _size:     UInt                = 0u
//     private var _capacity: UInt                = 0u

//     public alias DefaultCapacity = math.closestPowerOfTwo(of: SmallThreshold)
//     alias ElementSize     = reflect.sizeOf<T>

//     // 1 byte is reserved to store the 'Small' flag and the small size
//     alias SmallThreshold = (3u * reflect.pointerSize - 1 * reflect.sizeOf<Byte>) / ElementSize
//     alias SmallFlag      = 1u << 63                   // MSB of a 64 bit word
//     alias SmallShift     = 63u - 7
//     alias SmallSizeMask  = 0b0111_1111u << SmallShift // low 7 bits of the highest byte in a 64 bit word

//     private init (_ data: UnsafePtr<T>, _ size: u64, _ cap: u64) {
//         if size < SmallThreshold {
//             initSmall(data, size)
//         }
//         else {
//             initLarge(data, size, cap)
//         }
//     }

//     private init (_ BeginPtr: UnsafeMutablePtr<T>,
//                   _ EndPtr: UnsafeMutablePtr<T>,
//                   _ CapPtr: UnsafeMutablePtr<T>) {
//         self._data     = BeginPtr
//         self._size     = EndPtr - BeginPtr
//         self._capacity = CapPtr - BeginPtr
//     }

//     init (_ value: T, repeat: u64) {
//         self.init(withInitialCapacity: repeat)

//         for let i in 0u..repeat {
//             begin[i] = value
//         }

//         size = repeat
//     }

//     init (_ range: Range<T>) {
//         self.init()
//         for let val in range {
//             push(val)
//         }
//     }

//     init (_ range: InclusiveRange<T>) {
//         self.init()
//         for let val in range {
//             push(val)
//         }
//     }

//     init (withInitialCapacity initialCapacity: u64) {
//         if initialCapacity < SmallThreshold {
//             setSmallSize(0)
//         }
//         else {
//             reserve(initialCapacity)
//         }
//     }

//     init {
//         setSmallSize(0)
//     }

//     deinit {
//         for let i in 0u..size {
//             unsafe { builtin.deinit(self.begin[i]) }
//         }

//         // debug!("freeing $_data in ${reflect.function} (obj ${builtin.addressOf(self)})")
//         if !isSmall {
//             mem.deallocate(self._data)
//         }
//     }

//     @inline(always)
//     private static def allocate(_ size: UInt) -> UnsafeMutablePtr<T> {
//         return mem.allocate<T>(size)
//     }

//     @inline(always)
//     private def reallocate(_ size: UInt) -> UnsafeMutablePtr<T> {
//         return mem.reallocate(pointer: _data, newAmount: size)
//     }

//     private def mutating initLarge(_ chars: UnsafePtr<T>, _ size: UInt) {
//         initLarge(chars, size, math.closestPowerOfTwo(of: size))
//     }

//     private def mutating initLarge(_ data: UnsafePtr<T>, _ size: UInt, _ cap: UInt) {
//         self._data    = allocate(cap)
//         self._size    = size
//         self.capacity = cap

//         mem.copy(to: self._data, from: data, size)
//     }

//     private def mutating initSmall(_ data: UnsafePtr<T>, _ size: UInt) {
//         setSmallSize(size)
//         mem.copy(to: self.begin, from: data, size)
//     }

//     private def mutating grow() {
//         if isSmall {
//             reserve(DefaultCapacity)
//         }
//         else {
//             reserve(_capacity << 1u)
//         }
//     }

//     def mutating reserve(_ size: u64) {
//         if size <= capacity {
//             return
//         }

//         let currentSize = self.size
//         if isSmall {
//             var alloc = allocate(size)
//             mem.copy(to: alloc, from: begin, currentSize)

//             self._data = alloc
//         }
//         else {
//             self._data = reallocate(size)
//         }

//         self._size     = currentSize
//         self._capacity = size
//     }

//     def mutating emplace< ...Ts>(_ ts: owned Ts...) {
//         push(T(ts...))
//     }

//     /// No-Op method to make variable template happy.
//     private def mutating push() {}

//     /// Push the element to the end of the buffer, growing if necessary.
//     public def mutating push(_ t: owned T) {
//         if size >= capacity {
//             grow()
//         }

//         builtin.uninitializedStore(&t, to: begin + size)
//         size = size + 1
//     }

//     /// Push the elements to the end of the buffer, growing if necessary.
//     public def mutating push< ...Vs>(_ t: owned T, u: T, vs: owned Vs...) {
//         push(u)
//         push(u)
//         append(vs...)
//     }

//     /// Push the elements to the end of the buffer, growing if necessary.
//     public def mutating append(_ ptr: UnsafePtr<T>, _ size: UInt) {
//         for let i in 0u..size {
//             push(ptr[i].copy())
//         }
//     }

//     def mutating infix += (t: T) {
//         push(t)
//     }

//     def mutating infix += (arr: [T]) where T is Copyable {
//         for let el in arr {
//             push(el.copy())
//         }
//     }

//     def mutating pop(_ amount: UInt = 1) {
//         assert!(size >= amount, "popping more values than exist")

//         var threshold = size - amount
//         while size > threshold {
//             size = size - 1
//             unsafe { builtin.deinit(begin[size]) }
//         }
//     }

//     def mutating popVal() -> T {
//         let val = back()
//         pop()

//         return val
//     }

//     def mutating popFront(_ amount: UInt = 1) {
//         assert!(size >= amount, "popping more values than exist")

//         for let i in 0u..=amount {
//             unsafe { builtin.deinit(begin[i]) }
//         }

//         mem.move(to: self.begin, from: self.begin + amount, size - amount)
//         size = size - amount
//     }

//     def mutating insertAtPosition(_ pos: UInt, _ t: owned T) {
//         assert!(pos <= size, "insert position must be <= array size!")

//         // special case, insert at end
//         if pos == size {
//             push(t)
//             return
//         }

//         // grow if necessary
//         if size >= capacity {
//             grow()
//         }

//         // move following elements
//         mem.move(to: begin + pos + 1u,
//                  from: begin + pos,
//                  size - pos)

//         // insert new element
//         builtin.uninitializedStore(&t, to: begin + pos)
//         size = size + 1
//     }

//     def mutating pushFront(_ t: owned T) {
//         insertAtPosition(0, t)
//     }

//     prop size: u64 {
//         get {
//             if isSmall {
//                 return (_capacity & SmallSizeMask) >> SmallShift
//             }

//             return _size
//         }
//         set {
//             if isSmall {
//                 setSmallSize(newVal)
//                 return
//             }

//             _size = newVal
//         }
//     }

//     prop capacity: u64 {
//         get {
//             if isSmall {
//                 return SmallThreshold
//             }

//             return _capacity & ~(SmallFlag | SmallSizeMask)
//         }
//         set {
//             // setting capacity clears the Small flag
//             _capacity = newVal
//         }
//     }

//     prop begin: UnsafeMutablePtr<T> {
//         if isSmall {
//             return builtin.addressOf(_data) as! UnsafeMutablePtr<T>
//         }

//         return _data
//     }

//     private prop end: UnsafeMutablePtr<T> {
//         return begin + size
//     }

//     private prop isSmall: i1 {
//         return (_capacity & SmallFlag) != 0
//     }

//     private def mutating setSmallSize(_ size: u64) {
//         _capacity &= ~SmallSizeMask
//         _capacity |= (size << SmallShift) | SmallFlag
//     }

//     prop front: T {
//         get {
//             assert!(!empty, "called 'front' on empty buffer")
//             return builtin.loadFromPointer(begin)
//         }
//         set {
//             assert!(!empty, "called 'front' on empty buffer")
//             builtin.storeToPointer(begin, to: newVal)
//         }
//     }

//     prop back: T {
//         get {
//             assert!(!empty, "called 'back' on empty buffer")
//             return builtin.loadFromPointer(end - 1)
//         }
//         set {
//             assert!(!empty, "called 'back' on empty buffer")
//             builtin.storeToPointer(end - 1, to: newVal)
//         }
//     }

//     def mutating set(_ idx: UInt, _ t: owned T) {
//         self[idx] = &t
//     }

//     subscript (_ idx: UInt) -> T {
//         get {
//             assert!(idx < size, "index out of bounds (given index: $idx, size: $size)")
//             return begin[idx]
//         }
//         set {
//             assert!(idx < size, "index out of bounds (given index: $idx, size: $size)")
//             begin[idx] = newVal
//         }
//     }

//     def mutating clear() {
//         for let i in 0u..size {
//             unsafe { builtin.deinit(self.begin[i]) }
//             size = size - 1
//         }
//     }

//     prop empty: Bool {
//         return size == 0
//     }

//     prop unsafe_data: UnsafeMutablePtr<T> {
//         return begin
//     }
// }

// extend DynamicBuffer with Iterable {
//     struct Iterator with IteratorProtocol {
//         let arr: UnsafePtr<DynamicBuffer>
//         var idx: u64 = 0

//         associatedType Element = T

//         def mutating next() -> T? {
//             if  idx >= arr->size {
//                 return none
//             }

//             return .Some(builtin.loadFromPointer(arr)[idx++])
//         }
//     }

//     associatedType Element = T
//     associatedType It = Iterator

//     def getIterator() -> It {
//         return Iterator(arr: builtin.addressOf(self))
//     }
// }

// extend DynamicBuffer with StringRepresentable {
//     def join(Separator: String) -> String {
//         var s = "["

//         var i = 0u
//         for let el in self {
//             if i++ != 0 {
//                 s += Separator
//             }

//             s += String(el)
//         }

//         s += "]"
//         return s
//     }

//     def toString() -> String {
//         return join<", ">()
//     }
// }

// extend DynamicBuffer with Equatable /* where T is Equatable */ {
//     def infix ==(rhs: Self) -> Bool {
//         if size != rhs.size {
//             return false
//         }

//         for var i = 0u; i < size; ++i {
//             if self[i] != rhs[i] {
//                 return false
//             }
//         }

//         return true
//     }

//     def containsOnly(_ t: T) -> Bool {
//         for let el in self {
//             if el != t {
//                 return false
//             }
//         }

//         return true
//     }
// }

// extend DynamicBuffer with Comparable /* where T is Comparable */ {
//     def infix <=>(rhs: DynamicBuffer) -> Int {
//         if size < rhs.size {
//             return -1
//         }
//         if size > rhs.size {
//             return 1
//         }

//         for let i in 0u..size {
//             var cmp = self[i] <=> rhs[i]
//             if cmp < 0 {
//                 return -1
//             }
//             if cmp > 0 {
//                 return 1
//             }
//         }

//         return 0
//     }
// }

// extend DynamicBuffer with Copyable /* where T is Copyable */ {
//     def copy() -> DynamicBuffer {
//         var buf = DynamicBuffer(withInitialCapacity: size)
//         for let i in 0u..size {
//             buf.begin[i] = self[i].copy()
//         }

//         buf.size = size
//         return buf
//     }

//     def mutating fillToCapacity(_ t: T) {
//         var ptr = begin
//         for let i in size..capacity {
//             ptr[i] = t.copy()
//         }

//         size = capacity
//     }

//     def mutating resize(to: UInt, fillWith t: T) {
//         var cmp = size <=> to
//         if cmp == 0 {
//             return
//         }
//         if cmp > 0 {
//             // run destructors
//             while size > to {
//                 unsafe { builtin.deinit(begin[size - 1]) }
//                 size = size - 1
//             }

//             return
//         }

//         reserve(to)
//         for let i in size..to {
//             begin[i] = t.copy()
//         }

//         size = to
//     }
// }

// alias ByteBuffer = DynamicBuffer<Byte>

// /*
// public struct DynamicBuffer<T> {
//     var BeginPtr: UnsafeMutablePtr<T>
//     var EndPtr: UnsafeMutablePtr<T>
//     var CapPtr: UnsafeMutablePtr<T>

//     alias DefaultCapacity = 8u
//     alias ElementSize     = reflect.sizeOf<T>

//     private init (data: UnsafePtr<T>, size: u64, cap: u64) {
//         self.BeginPtr = allocate(cap)
//         self.EndPtr = self.BeginPtr + size
//         self.CapPtr = self.BeginPtr + cap

//         libc.memcpy(self.BeginPtr as! UnsafeMutableRawPtr,
//                     data as! UnsafeMutableRawPtr, size * ElementSize)
//     }

//     private init (BeginPtr: UnsafeMutablePtr<T>,
//                   EndPtr: UnsafeMutablePtr<T>,
//                   CapPtr: UnsafeMutablePtr<T>) {
//         self.BeginPtr = BeginPtr
//         self.EndPtr   = EndPtr
//         self.CapPtr   = CapPtr
//     }

//     init (value: T, repeat: u64) {
//         self.BeginPtr = allocate(repeat)
//         self.EndPtr = self.BeginPtr + repeat
//         self.CapPtr = self.EndPtr

//         var ptr = self.BeginPtr
//         for var i = 0u; i < repeat; ++i {
//             *ptr = value
//             ++ptr
//         }
//     }

//     init (range: Range<T>) {
//         self.init()
//         for let val in range {
//             push(val)
//         }
//     }

//     init (range: InclusiveRange<T>) {
//         self.init()
//         for let val in range {
//             push(val)
//         }
//     }

//     init (initialCapacity: u64) {
//         self.BeginPtr = 0 as! UnsafeMutablePtr<T>
//         self.EndPtr = 0 as! UnsafeMutablePtr<T>
//         self.CapPtr = 0 as! UnsafeMutablePtr<T>

//         reserve(initialCapacity)
//     }

//     init {
//         self.BeginPtr = 0 as! UnsafeMutablePtr<T>
//         self.EndPtr = 0 as! UnsafeMutablePtr<T>
//         self.CapPtr = 0 as! UnsafeMutablePtr<T>

//         reserve(DefaultCapacity)
//     }

//     deinit {
//         for var ptr = self.BeginPtr; ptr != self.EndPtr; ++ptr {
//             builtin.deinit(builtin.loadFromPointer(ptr))
//         }

//         // debug!("freeing $BeginPtr in ${reflect.function} (obj ${builtin.addressOf(self)})")
//         _cdot_Free(BeginPtr as! UnsafeMutableRawPtr)
//     }

//     @inline(always)
//     private static def allocate(size: UInt) -> UnsafeMutablePtr<T> {
//         return mem.allocate<T>(size)
//     }

//     @inline(always)
//     private def reallocate(size: UInt) -> UnsafeMutablePtr<T> {
//         return mem.reallocate(BeginPtr, size)
//     }

//     private def mutating grow() {
//         reserve(capacity << 1u)
//     }

//     def mutating reserve(size: u64) {
//         if size <= capacity {
//             return
//         }

//         let currentSize = self.size

//         self.BeginPtr = reallocate(size)
//         self.EndPtr   = self.BeginPtr + currentSize
//         self.CapPtr   = self.BeginPtr + size
//     }

//     def mutating emplace[...Ts](ts: Ts...) {
//         push(T(ts...))
//     }

//     def mutating push(t: owned T) {
//         if EndPtr >= CapPtr {
//             grow()
//         }

//         EndPtr[0] = t
//         EndPtr = EndPtr + 1u
//     }

//     def mutating infix += (t: T) {
//         push(t)
//     }

//     def mutating infix += (arr: <T>) {
//         for var i = 0u; i < arr.size; ++i {
//             push(arr[i])
//         }
//     }

//     def mutating pop(amount: UInt = 1) {
//         assert!(size >= amount, "popping more values than exist")
//         EndPtr = EndPtr - amount
//     }

//     def mutating popVal() -> T {
//         let val = back()
//         pop()

//         return val
//     }

//     def mutating popFront(amount: UInt = 1) {
//         assert!(size >= amount, "popping more values than exist")
//         libc.memmove(self.BeginPtr as! UnsafeMutableRawPtr,
//                      (self.BeginPtr + amount) as! UnsafeMutableRawPtr,
//                      (size - amount) * ElementSize)

//         EndPtr = EndPtr - amount
//     }

//     def mutating insertAtPosition(pos: UInt, t: owned T) {
//         assert!(pos <= size, "insert position must be <= array size!")

//         // special case, insert at end
//         if pos == size {
//             push(t)
//             return
//         }

//         // grow if necessary
//         if EndPtr >= CapPtr {
//             grow()
//         }

//         // move following elements
//         mem.move(BeginPtr + pos + 1u,
//                  BeginPtr + pos,
//                  size - pos)

//         // insert new element
//         BeginPtr[pos] = t
//         ++EndPtr
//     }

//     def mutating pushFront(t: owned T) {
//         insertAtPosition(0, t)
//     }

//     prop front: T {
//         get {
//             assert!(!empty, "called 'front' on empty collection")
//             return BeginPtr[0]
//         }
//         set {
//             assert!(!empty, "called 'front' on empty collection")
//             BeginPtr[0] = newVal
//         }
//     }

//     prop back: T {
//         get {
//             assert!(!empty, "called 'back' on empty collection")
//             return BeginPtr[size - 1]
//         }
//         set {
//             assert!(!empty, "called 'back' on empty collection")
//             BeginPtr[size - 1] = newVal
//         }
//     }

//     def mutating set(idx: UInt, t: owned T) {
//         assert!(idx < size, "index out of bounds (given index: $idx, size: $size)")
//         BeginPtr[idx] = t
//     }

//     subscript (idx: UInt) -> T {
//         get {
//             assert!(idx < size, "index out of bounds (given index: $idx, size: $size)")
//             return BeginPtr[idx]
//         }
//         set {
//             assert!(idx < size, "index out of bounds (given index: $idx, size: $size)")
//             BeginPtr[idx] = newVal
//         }
//     }

//     def mutating clear() {
//         reserve(0)
//     }

//     prop size: UInt {
//         get {
//             return EndPtr - BeginPtr
//         }
//         set {
//             EndPtr = BeginPtr + newVal
//         }
//     }

//     prop capacity: UInt {
//         return CapPtr - BeginPtr
//     }

//     prop empty: Bool {
//         return BeginPtr == EndPtr
//     }

//     prop unsafeBeginPtr: UnsafeMutablePtr<T> {
//         return BeginPtr
//     }

//     private prop begin: UnsafeMutablePtr<T> {
//         return BeginPtr
//     }

//     private prop end: UnsafeMutablePtr<T> {
//         return EndPtr
//     }
// }
// */