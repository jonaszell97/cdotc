
import builtin
import libc

/// Allocate `size` bytes, aligned to a boundary of `alignTo` bytes.
public def allocate(_ size: Int, alignTo alignment: Int = 1) -> UnsafeMutableRawPtr {
    return UnsafeMutableRawPtr(rawPointer: rt._cdot_Malloc(builtin.signcast(size.value)))
}

/// Allocate enough memory for `amount` instances of type `T`, aligned to a 
/// boundary of `alignTo` bytes.
public def allocate<T>(_ amount: Int = 1,
                       alignTo alignment: Int = reflect.alignOf<T>) -> UnsafeMutablePtr<T> {
    return UnsafeMutablePtr<T>(rawPointer: rt._cdot_Malloc(
        builtin.signcast((reflect.sizeOf<T> * amount).value)))
}

@inline(hint)
public def reallocate(_ ptr: UnsafeRawPtr, toSize newAmount: Int) -> UnsafeMutableRawPtr {
    return UnsafeMutableRawPtr(rawPointer:
        rt._cdot_Realloc(ptr.rawPointer, builtin.signcast(newAmount.value)))
}

@inline(hint)
public def reallocate<T>(_ ptr: UnsafeMutablePtr<T>, toSize newAmount: Int) -> UnsafeMutablePtr<T> {
    return UnsafeMutablePtr<T>(rawPointer: rt._cdot_Realloc(
        ptr.rawPointer, builtin.signcast((reflect.sizeOf<T> * newAmount).value)))
}

@inline(hint)
public def deallocate(_ ptr: UnsafeMutableRawPtr) {
    rt._cdot_Free(ptr.rawPointer)
}

@inline(hint)
public def deallocate<T>(_ ptr: UnsafeMutablePtr<T>) {
    rt._cdot_Free(ptr.rawPointer)
}

@inline(hint)
public def new<T, ...Args>(_ args: owned Args...) -> UnsafeMutablePtr<T> {
    var mem = allocate<T>()
    builtin.constructInPlace(at: mem, args...)

    return mem
}

@inline(hint)
public def delete<T>(_ ptr: UnsafeMutablePtr<T>) {
    builtin.deinit(*ptr)
    deallocate(ptr)
}

public def swap<T>(_ t: mut ref T, _ u: mut ref T) {
    var tmp = t
    t = u
    u = tmp
}

public def replace<T>(_ mem: mut ref T, with: T) {
    replace(builtin.addressOf(&mem), with)
}

public def replace<T>(_ mem: UnsafeMutablePtr<T>, with: T)
    where reflect.IsTriviallyCopyable<T>
{
    builtin.storeToPointer(with, to: mem.rawPointer)
}

public def replace<T>(_ mem: UnsafeMutablePtr<T>, with: T) {
    _ = libc.string.memcpy(mem.rawPointer,
                           builtin.addressOf(with).rawPointer,
                           builtin.signcast(reflect.sizeOf<T>.value))
}

public def reverse<T>(_ ptr: UnsafeMutableBufferPtr<T>, _ size: Int) {
    for i in 0..(size / 2) {
        var tmp = ptr[size - i - 1].copy()
        ptr[size - i - 1] = ptr[i].copy()
        ptr[i] = tmp
    }
}

public def move(to dst: UnsafeMutableRawPtr, 
                from src: UnsafeRawPtr,
                _ n: Int) {
    _ = libc.string.memmove(dst.rawPointer, src.rawPointer, builtin.signcast(n.value))
}

public def move<T>(to dst: UnsafeMutableBufferPtr<T>,
                   from src: UnsafeBufferPtr<T>,
                   _ n: Int = 1) {
    _ = libc.string.memmove(dst.rawPointer, src.rawPointer,
                           builtin.signcast((n * reflect.sizeOf<T>).value))
}

public def copy(to dst: UnsafeMutableRawPtr,
                from src: UnsafeRawPtr,
                _ n: Int) {
    _ = libc.string.memcpy(dst.rawPointer, src.rawPointer, builtin.signcast(n.value))
}

public def copy<T>(to dst: UnsafeMutableBufferPtr<T>,
                   from src: UnsafeBufferPtr<T>,
                   _ n: Int = 1) {
    static if reflect.IsTriviallyCopyable<T> {
        _ = libc.string.memcpy(dst.rawPointer, src.rawPointer,
                               builtin.signcast((n * reflect.sizeOf<T>).value))
    }
    else {
        for i in 0..n {
            builtin.uninitializedStore(src[i].copy(), to: dst + i)
        }
    }
}

public def cmp(_ lhs: UnsafeRawPtr, _ rhs: UnsafeRawPtr, _ n: Int) -> Int {
    return Int(libc.string.memcmp(lhs.rawPointer, rhs.rawPointer, builtin.signcast(n.value)))
}

public def cmp<T>(_ lhs: UnsafeBufferPtr<T>, _ rhs: UnsafeBufferPtr<T>, _ n: Int = 1) -> Int {
    return Int(libc.string.memcmp(lhs.rawPointer, rhs.rawPointer,
                                  builtin.signcast((n * reflect.sizeOf<T>).value)))
}
