
module std.collection

struct SmallVector<T, let N: u64> {
    private alias InlineSize = reflect.sizeOf<T> * N
    private var InlineStorage: [u8; InlineSize]

    private var BeginPtr: UnsafeMutablePtr<T>
    private var EndPtr:   UnsafeMutablePtr<T>
    private var CapPtr:   UnsafeMutablePtr<T>

    init {
        self.InlineStorage = [u8; InlineSize]()
        self.BeginPtr = InlineStorage as! UnsafeMutablePtr<u8> as! UnsafeMutablePtr<T>
        self.EndPtr   = self.BeginPtr
        self.CapPtr   = self.BeginPtr + N
    }

    deinit {
        for var ptr = self.BeginPtr; ptr != self.EndPtr; ++ptr {
            builtin.deinit(builtin.loadFromPointer(ptr))
        }

        if !isSmall {
            _cdot_Free(BeginPtr as! UnsafeMutableRawPtr)
        }
    }

    prop size: UInt {
        return EndPtr - BeginPtr
    }

    prop capacity: UInt {
        return CapPtr - BeginPtr
    }

    prop empty: Bool {
        return size == 0
    }

    private prop isSmall: Bool {
        return capacity == N
    }

    private def mutating grow() {
        resize(to: capacity << 1u)
    }

    private def mutating resize(to toSize: UInt) {
        if capacity >= toSize {
            return
        }

        assert!(toSize % 2 == 0, "size must be a power of two!")

        var alloc = _cdot_Malloc(toSize * reflect.sizeOf<T>)
        libc.memcpy(alloc, self.BeginPtr as! UnsafeMutableRawPtr,
                    size * reflect.sizeOf<T>)

        if !isSmall {
            _cdot_Free(self.BeginPtr as! UnsafeMutableRawPtr)
        }

        var oldSize = size

        self.BeginPtr = alloc as! UnsafeMutablePtr<T>
        self.EndPtr   = self.BeginPtr + oldSize
        self.CapPtr   = self.BeginPtr + toSize
    }

    prop front: T {
        assert!(!empty, "calling front on empty vector!")
        return builtin.loadFromPointer(self.BeginPtr)
    }

    prop back: T {
        assert!(!empty, "calling front on empty vector!")
        return builtin.loadFromPointer(self.EndPtr - 1)
    }

    def mutating push(t: owned T) {
        if size + 1 >= capacity {
            grow()
        }

        builtin.storeToPointer(t, to: self.EndPtr)
        self.EndPtr += 1u
    }

    def mutating pop() -> T {
        assert!(!empty, "can't pop from empty vector!")

        var t = builtin.loadFromPointer(self.EndPtr - 1)
        self.EndPtr -= 1u

        return t
    }

    subscript (idx: UInt) -> T {
        get {
            assert!(size > idx, "vector index out of bounds")
            return BeginPtr[idx]
        }
        set {
            assert!(size > idx, "vector index out of bounds")
            BeginPtr[idx] = newVal
        }
    }
}


extend SmallVector with Iterable {
    struct SmallVectorIterator with IteratorProtocol {
        let vec: UnsafePtr<SmallVector<T, N>>
        var idx: u64 = 0

        associatedType Element = T

        init (_ vec: borrow SmallVector) {
            self.vec = builtin.addressOf(vec)
        }

        def mutating next() -> T? {
            if  idx >= builtin.loadFromPointer(vec).size {
                return none
            }

            return .Some(builtin.loadFromPointer(vec)[idx++])
        }
    }

    associatedType Element = T
    associatedType It = SmallVectorIterator

    def getIterator() -> It {
        return SmallVectorIterator(self)
    }
}

extend SmallVector with StringRepresentable {
    def join(Separator: String) -> String {
        var s = "["

        var i = 0u
        for let el in self {
            if i++ != 0 {
                s += Separator
            }

            s += String(el)
        }

        s += "]"
        return s
    }

    def toString() -> String {
        return join(Separator: ", ")
    }
}

extend SmallVector with Equatable where T is Equatable {
    def infix ==(rhs: Self) -> Bool {
        if size != rhs.size {
            return false
        }

        for var i = 0u; i < size; ++i {
            if self[i] != rhs[i] {
                return false
            }
        }

        return true
    }

    def containsOnly(t: T) -> Bool {
        for let el in self {
            if el != t {
                return false
            }
        }

        return true
    }
}

alias SmallString<let N: UInt> = SmallVector<Char, N>
