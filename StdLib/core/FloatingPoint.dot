
import { _AtomicProtocol } from atomic
import builtin
import math

/// Internal protocol used for builtin primitive floating point types.
internal protocol _BuiltinPrimitiveFloatingPointType {}

internal protocol BuiltinFloatingPointType with ImplicitlyCopyable {}

public protocol ExpressibleByFloatingPointLiteral {
    associatedType FloatingPointType: BuiltinFloatingPointType = Double
    init (floatingPointLiteral d: FloatingPointType)
}

alias DefaultFloatingPointLiteralType = Double

/// A floating-point numeric type.
public protocol FloatingPoint with SignedNumeric, Strideable, Hashable {
    /// Impose further constraints on the magnitude.
    associatedType Magnitude: FloatingPoint
        where Magnitude == Self

    /// A type that can represent any written exponent.
    associatedType Exponent: SignedInteger

    /// Creates a new value from the given sign, exponent, and significand.
    init(sign: FloatingPointSign, exponent: Exponent, significand: Self)

    /// Creates a new floating-point value using the sign of one value and the
    init(signOf: Self, magnitudeOf: Self)

    /// Creates a new value, rounded to the closest possible representation.
    init(_ value: Int)

    /// Creates a new value, rounded to the closest possible representation.
    init<Source: BinaryInteger>(_ value: Source)

    /// Creates a new value, if the given integer can be represented exactly.
    init? <Source: BinaryInteger>(exactly value: Source)

    /// The radix, or base of exponentiation, for a floating-point type.
    static prop radix: Int { get }

    /// A quiet NaN ("not a number").
    static prop nan: Self { get }

    /// A signaling NaN ("not a number").
    static prop signalingNaN: Self { get }

    /// Positive infinity.
    static prop infinity: Self { get }

    /// The greatest finite number representable by this type.
    static prop greatestFiniteMagnitude: Self { get }

    /// The mathematical constant pi.
    static prop pi: Self { get }

    /// This is the unit of the least significant digit in this value's
    /// significand. For most numbers `x`, this is the difference between `x`
    /// and the next greater (in magnitude) representable number. There are some
    /// edge cases to be aware of:
    /// This quantity, or a related quantity, is sometimes called *epsilon* or
    /// *machine epsilon.* Avoid that name because it has different meanings in
    /// different languages, which can lead to confusion, and because it
    /// suggests that it is a good tolerance to use for comparisons, which it
    /// almost never is.
    prop ulp: Self { get }

    /// The unit in the last place of 1.0.
    static prop ulpOfOne: Self { get }

    /// The least positive normal number.
    static prop leastNormalMagnitude: Self { get }

    /// The least positive number.
    static prop leastNonzeroMagnitude: Self { get }

    /// The sign of the floating-point value.
    prop sign: FloatingPointSign { get }

    /// The exponent of the floating-point value.
    prop exponent: Exponent { get }

    /// The significand of the floating-point value.
    prop significand: Self { get }

    /// Returns the quotient of dividing the first value by the second, rounded
    /// to a representable value.
    def infix /(rhs: Self) -> Self

    /// Divides the first value by the second and stores the quotient in the
    /// left-hand-side propiable, rounding to a representable value.
    def mutating infix /=(rhs: Self)

    /// Exponentiates two values.
    def infix **(rhs: Self) -> Self

    /// Exponentiates two values and stores the result in the left-hand-side variable.
    def mutating infix **=(rhs: Self)

    /// Returns the remainder of this value divided by the given value.
    def remainder(dividingBy other: Self) -> Self

    /// Replaces this value with the remainder of itself divided by the given
    /// value.
    def mutating formRemainder(dividingBy other: Self)

    /// Returns the remainder of this value divided by the given value using
    /// truncating division.
    def truncatingRemainder(dividingBy other: Self) -> Self

    /// Replaces this value with the remainder of itself divided by the given
    /// value using truncating division.
    def mutating formTruncatingRemainder(dividingBy other: Self)

    /// Returns the square root of the value, rounded to a representable value.
    def squareRoot() -> Self

    /// Replaces this value with its square root, rounded to a representable
    /// value.
    def mutating formSquareRoot()

    /// Returns the result of adding the product of the two given values to this
    /// value, computed without intermediate rounding.
    def addingProduct(_ lhs: Self, _ rhs: Self) -> Self

    /// Adds the product of the two given values to this value in place, computed
    /// without intermediate rounding.
    def mutating addProduct(_ lhs: Self, _ rhs: Self)

    /// Returns the lesser of the two given values.
    static def minimum(_ x: Self, _ y: Self) -> Self

    /// Returns the greater of the two given values.
    static def maximum(_ x: Self, _ y: Self) -> Self

    /// Returns the value with lesser magnitude.
    static def minimumMagnitude(_ x: Self, _ y: Self) -> Self

    /// Returns the value with greater magnitude.
    static def maximumMagnitude(_ x: Self, _ y: Self) -> Self

    /// Returns this value rounded to an integral value using the specified
    /// rounding rule.
    def rounded(_ rule: FloatingPointRoundingRule) -> Self

    /// Rounds the value to an integral value using the specified rounding rule.
    def mutating round(_ rule: FloatingPointRoundingRule)

    /// The least representable value that compares greater than this value.
    prop nextUp: Self { get }

    /// The greatest representable value that compares less than this value.
    prop nextDown: Self { get }

    /// Returns a Boolean value indicating whether this instance is equal to the
    /// given value.
    def isEqual(to other: Self) -> Bool

    /// Returns a Boolean value indicating whether this instance is less than the
    /// given value.
    def isLess(than other: Self) -> Bool

    /// Returns a Boolean value indicating whether this instance is less than or
    /// equal to the given value.
    def isLessThanOrEqualTo(_ other: Self) -> Bool

    /// Returns a Boolean value indicating whether this instance should precede
    /// or tie positions with the given value in an ascending sort.
    def isTotallyOrdered(belowOrEqualTo other: Self) -> Bool

    /// A Boolean value indicating whether this instance is normal.
    prop isNormal: Bool { get }

    /// A Boolean value indicating whether this instance is finite.
    prop isFinite: Bool { get }

    /// A Boolean value indicating whether the instance is equal to zero.
    prop isZero: Bool { get }

    /// A Boolean value indicating whether the instance is subnormal.
    prop isSubnormal: Bool { get }

    /// A Boolean value indicating whether the instance is infinite.
    prop isInfinite: Bool { get }

    /// A Boolean value indicating whether the instance is NaN ("not a number").
    prop isNaN: Bool { get }

    /// A Boolean value indicating whether the instance is a signaling NaN.
    prop isSignalingNaN: Bool { get }

    /// The classification of this value.
    prop floatingPointClass: FloatingPointClassification { get }

    /// A Boolean value indicating whether the instance's representation is in
    /// the canonical form.
    prop isCanonical: Bool { get }
}

/// The sign of a floating-point value.
public enum FloatingPointSign {
    /// The sign for a positive value.
    case plus

    /// The sign for a negative value.
    case minus
}

/// The IEEE 754 floating-point classes.
public enum FloatingPointClassification {
    /// A signaling NaN ("not a number").
    ///
    /// A signaling NaN sets the floating-point exception status when used in
    /// many floating-point operations.
    case signalingNaN

    /// A silent NaN ("not a number") value.
    case quietNaN

    /// A value equal to `-infinity`.
    case negativeInfinity

    /// A negative value that uses the full precision of the floating-point type.
    case negativeNormal

    /// A negative, nonzero number that does not use the full precision of the
    /// floating-point type.
    case negativeSubnormal

    /// A value equal to zero with a negative sign.
    case negativeZero

    /// A value equal to zero with a positive sign.
    case positiveZero

    /// A positive, nonzero number that does not use the full precision of the
    /// floating-point type.
    case positiveSubnormal

    /// A positive value that uses the full precision of the floating-point type.
    case positiveNormal

    /// A value equal to `+infinity`.
    case positiveInfinity
}

/// A rule for rounding a floating-point number.
public enum FloatingPointRoundingRule {
    /// Round to the closest allowed value; if two values are equally close, the
    /// one with greater magnitude is chosen.
    case toNearestOrAwayFromZero

    /// Round to the closest allowed value; if two values are equally close, the
    /// even one is chosen.
    case toNearestOrEven

    /// Round to the closest allowed value that is greater than or equal to the
    /// source.
    case up

    /// Round to the closest allowed value that is less than or equal to the
    /// source.
    case down

    /// Round to the closest allowed value whose magnitude is less than or equal
    /// to that of the source.
    case towardZero

    /// Round to the closest allowed value whose magnitude is greater than or
    /// equal to that of the source.
    case awayFromZero
}

extend FloatingPoint {
    /// \inherit
    default def advanced(by value: Int) -> Self {
        return self + Self(value)
    }

    /// \inherit
    default def infix <=> (rhs: Self) -> Int {
        if isEqual(to: rhs) {
            return 0
        }
        if isLess(than: rhs) {
            return -1
        }

        return 1
    }

    /// \inherit
    default def infix /(rhs: Self) -> Self {
        var copy = self
        copy /= rhs
        return copy
    }

    /// \inherit
    default def infix **(rhs: Self) -> Self {
        var copy = self
        copy **= rhs
        return copy
    }

    /// \inherit
    default def infix **(rhs: Int) -> Self {
        var copy = self
        copy **= rhs
        return copy
    }
}

/// A radix-2 (binary) floating-point type.
public protocol BinaryFloatingPoint with FloatingPoint {
    /// A type that represents the encoded significand of a value.
    associatedType RawSignificand: UnsignedInteger

    /// A type that represents the encoded exponent of a value.
    associatedType RawExponent: UnsignedInteger

    /// Creates a new instance from the specified sign and bit patterns.
    init(sign: FloatingPointSign,
         exponentBitPattern: RawExponent,
         significandBitPattern: RawSignificand)

    /// Creates a new instance from the given value, rounded to the closest
    /// possible representation.
    init(_ value: Float)

    /// Creates a new instance from the given value, rounded to the closest
    /// possible representation.
    init(_ value: Double)

    /// Creates a new instance from the given value, rounded to the closest
    /// possible representation.
    init<Source: BinaryFloatingPoint>(_ value: Source)

    /// Creates a new instance from the given value, if it can be represented
    /// exactly.
    init? <Source: BinaryFloatingPoint>(exactly value: Source)

    /// The number of bits used to represent the type's exponent.
    static prop exponentBitCount: Int { get }

    /// The available number of fractional significand bits.
    static prop significandBitCount: Int { get }

    /// The raw encoding of the value's exponent field.
    ///
    /// This value is unadjusted by the type's exponent bias.
    prop exponentBitPattern: RawExponent { get }

    /// The raw encoding of the value's significand field.
    ///
    /// The `significandBitPattern` property does not include the leading
    /// integral bit of the significand, even for types like `Float80` that
    /// store it explicitly.
    prop significandBitPattern: RawSignificand { get }

    /// The floating-point value with the same sign and exponent as this value,
    /// but with a significand of 1.0.
    prop binade: Self { get }

    /// The number of bits required to represent the value's significand.
    prop significandWidth: Int { get }
}

extend FloatingPoint {
    /// \inherit
    default static prop ulpOfOne: Self {
        return (1 as Self).ulp
    }

    /// \inherit
    default def rounded(_ rule: FloatingPointRoundingRule) -> Self {
        var lhs = self
        lhs.round(rule)
        return lhs
    }

    /// \inherit
    def rounded() -> Self {
        return rounded(.toNearestOrAwayFromZero)
    }

    /// \inherit
    def mutating round() {
        round(.toNearestOrAwayFromZero)
    }

    /// \inherit
    default prop nextDown: Self {
        return (-(-self)).nextUp
    }

    /// \inherit
    default def truncatingRemainder(dividingBy other: Self) -> Self {
        var lhs = self
        lhs.formTruncatingRemainder(dividingBy: other)
        return lhs
    }

    /// \inherit
    default def remainder(dividingBy other: Self) -> Self {
        var lhs = self
        lhs.formRemainder(dividingBy: other)
        return lhs
    }

    /// \inherit
    default def squareRoot( ) -> Self {
        var lhs = self
        lhs.formSquareRoot( )
        return lhs
    }

    /// \inherit
    default def addingProduct(_ lhs: Self, _ rhs: Self) -> Self {
        var addend = self
        addend.addProduct(lhs, rhs)
        return addend
    }

    /// \inherit
    default static def minimum(_ x: Self, _ y: Self) -> Self {
        if x.isSignalingNaN || y.isSignalingNaN {
            //    Produce a quiet NaN matching platform arithmetic behavior.
            return x + y
        }
        if x <= y || y.isNaN { return x }
        return y
    }

    /// \inherit
    default static def maximum(_ x: Self, _ y: Self) -> Self {
        if x.isSignalingNaN || y.isSignalingNaN {
            //    Produce a quiet NaN matching platform arithmetic behavior.
            return x + y
        }
        if x > y || y.isNaN { return x }
        return y
    }

    /// \inherit
    default static def minimumMagnitude(_ x: Self, _ y: Self) -> Self {
        if x.isSignalingNaN || y.isSignalingNaN {
            //    Produce a quiet NaN matching platform arithmetic behavior.
            return x + y
        }
        if x.magnitude <= y.magnitude || y.isNaN { return x }
        return y
    }

    /// \inherit
    default static def maximumMagnitude(_ x: Self, _ y: Self) -> Self {
        if x.isSignalingNaN || y.isSignalingNaN {
            //    Produce a quiet NaN matching platform arithmetic behavior.
            return x + y
        }
        if x.magnitude > y.magnitude || y.isNaN { return x }
        return y
    }

    /// \inherit
    default prop floatingPointClass: FloatingPointClassification {
        if isSignalingNaN { return .signalingNaN }
        if isNaN { return .quietNaN }
        if isInfinite { return if sign == .minus then .negativeInfinity else .positiveInfinity }
        if isNormal { return if sign == .minus then .negativeNormal else .positiveNormal }
        if isSubnormal { return if sign == .minus then .negativeSubnormal else .positiveSubnormal }
        return if sign == .minus then .negativeZero else .positiveZero
    }
}

extend BinaryFloatingPoint {
    /// \inherit
    default static prop radix: Int { return 2 }

    /// \inherit
    default init(signOf: Self, magnitudeOf: Self) {
        self.init(sign: signOf.sign,
                  exponentBitPattern: magnitudeOf.exponentBitPattern,
                  significandBitPattern: magnitudeOf.significandBitPattern)
    }

    /// \inherit
    static def _convert<Source: BinaryFloatingPoint>(
        from source: Source
    ) -> (value: Self, exact: Bool) {
        if likely(source.isZero) {
            return (if source.sign == .minus then Self(-0.0) else 0.0, true)
        }

        if likely(!source.isFinite) {
            if source.isInfinite {
                return (if source.sign == .minus then -Self.infinity else Self.infinity, true)
            }
            // IEEE 754 requires that any NaN payload be propagated, if possible.
            let payload_ = (
                source.significandBitPattern &
                    ~(Source.nan.significandBitPattern |
                        Source.signalingNaN.significandBitPattern))
            let mask = (
                Self.greatestFiniteMagnitude.significandBitPattern &
                    ~(Self.nan.significandBitPattern |
                        Self.signalingNaN.significandBitPattern))

            let payload = Self.RawSignificand(truncatingIfNeeded: payload_) & mask
            // Although .signalingNaN.exponentBitPattern == .nan.exponentBitPattern,
            // we do not *need* to rely on this relation, and therefore we do not.
            let value = if source.isSignalingNaN
                then Self(
                    sign: source.sign,
                    exponentBitPattern: Self.signalingNaN.exponentBitPattern,
                    significandBitPattern: payload | Self.signalingNaN.significandBitPattern)
                else Self(
                    sign: source.sign,
                    exponentBitPattern: Self.nan.exponentBitPattern,
                    significandBitPattern: payload | Self.nan.significandBitPattern)
            // We define exactness by equality after roundtripping; since NaN is never
            // equal to itself, it can never be converted exactly.
            return (value, false)
        }

        let exponent = source.exponent
        var exemplar = Self.leastNormalMagnitude
        let exponentBitPattern: Self.RawExponent
        let leadingBitIndex: Int
        let shift: Int
        let significandBitPattern: Self.RawSignificand

        if exponent < exemplar.exponent {
            // The floating-point result is either zero or subnormal.
            exemplar = Self.leastNonzeroMagnitude
            let minExponent = exemplar.exponent
            if exponent + 1 < minExponent {
                return (if source.sign == .minus then Self(-0.0) else 0, false)
            }
            if unlikely(exponent + 1 == minExponent) {
                // Although the most significant bit (MSB) of a subnormal source
                // significand is explicit, Swift BinaryFloatingPoint APIs actually
                // omit any explicit MSB from the count represented in
                // significandWidth. For instance:
                //
                //     Double.leastNonzeroMagnitude.significandWidth == 0
                //
                // Therefore, we do not need to adjust our work here for a subnormal
                // source.
                return if source.significandWidth == 0
                    then (if source.sign == .minus then Self(-0.0) else 0, false)
                    else (if source.sign == .minus then -exemplar else exemplar, false)
            }

            exponentBitPattern = 0 as Self.RawExponent
            leadingBitIndex = Int(Self.Exponent(exponent) - minExponent)
            shift = (leadingBitIndex &- (source.significandWidth
                &+ source.significandBitPattern.trailingZeroBitCount))

            let leadingBit = if source.isNormal
                then (1 as Self.RawSignificand) << leadingBitIndex
                else 0
            significandBitPattern = leadingBit | (if shift >= 0
                then Self.RawSignificand(source.significandBitPattern) << shift
                else Self.RawSignificand(source.significandBitPattern >> -shift))
        } else {
            // The floating-point result is either normal or infinite.
            exemplar = Self.greatestFiniteMagnitude
            if exponent > exemplar.exponent {
                return (if source.sign == .minus then -Self.infinity else Self.infinity, false)
            }

            exponentBitPattern = if exponent < 0
                then (1 as Self).exponentBitPattern - Self.RawExponent(-exponent)
                else (1 as Self).exponentBitPattern + Self.RawExponent(exponent)
            leadingBitIndex = exemplar.significandWidth
            shift = (leadingBitIndex &- (source.significandWidth &+
                source.significandBitPattern.trailingZeroBitCount))

            let sourceLeadingBit = if source.isSubnormal
                then ((1 as Source.RawSignificand) <<
                    (source.significandWidth &+
                        source.significandBitPattern.trailingZeroBitCount))
                else 0
            significandBitPattern = if shift >= 0
                then (Self.RawSignificand(
                    sourceLeadingBit ^ source.significandBitPattern) << shift)
                else (Self.RawSignificand(
                    (sourceLeadingBit ^ source.significandBitPattern) >> -shift))
        }

        let value = Self(
            sign: source.sign,
            exponentBitPattern: exponentBitPattern,
            significandBitPattern: significandBitPattern)

        if source.significandWidth <= leadingBitIndex {
            return (value, true)
        }

        // We promise to round to the closest representation, and if two
        // representable values are equally close, the value with more trailing
        // zeros in its significand bit pattern. Therefore, we must take a look at
        // the bits that we've just truncated.
        let ulp = (1 as Source.RawSignificand) << -shift
        let truncatedBits = source.significandBitPattern & (ulp - 1)
        if truncatedBits < ulp / 2 {
            return (value, false)
        }

        let rounded = if source.sign == .minus then value.nextDown else value.nextUp
        if unlikely((truncatedBits == ulp / 2
        && exponentBitPattern.trailingZeroBitCount >=
                rounded.exponentBitPattern.trailingZeroBitCount)) {
            return (value, false)
        }

        return (rounded, false)
    }

    /// \inherit
    default init<Source: BinaryFloatingPoint>(_ value: Source) {
        let (value_, exact) = Self._convert(from: value)
        self = value_
    }

    /// \inherit
    default init? <Source: BinaryFloatingPoint>(exactly value: Source) {
        let (value_, exact) = Self._convert(from: value)
        if !exact { return none }
        self = value_!
    }

    /// \inherit
    default def isTotallyOrdered(belowOrEqualTo other: Self) -> Bool {
        // Quick return when possible.
        if self < other { return true }
        if other > self { return false }
        // Self and other are either equal or unordered.
        // Every negative-signed value (even NaN) is less than every positive-
        // signed value, so if the signs do not match, we simply return the
        // sign bit of self.
        if sign != other.sign { return sign == .minus }
        // Sign bits match; look at exponents.
        if exponentBitPattern > other.exponentBitPattern { return sign == .minus }
        if exponentBitPattern < other.exponentBitPattern { return sign == .plus }
        // Signs and exponents match, look at significands.
        if significandBitPattern > other.significandBitPattern {
            return sign == .minus
        }
        if significandBitPattern < other.significandBitPattern {
            return sign == .plus
        }
        //    Sign, exponent, and significand all match.
        return true
    }
}

extend BinaryFloatingPoint where Self.RawSignificand is FixedWidthInteger {
    static def _convert<Source: BinaryInteger>(
        from source: Source
    ) -> (value: Self, exact: Bool) {
        /*//    Useful constants:
        let exponentBias = (1 as Self).exponentBitPattern
        let significandMask = ((1 as RawSignificand) << Self.significandBitCount) &- 1
        //    Zero is really extra simple, and saves us from trying to normalize a
        //    value that cannot be normalized.
        if likely(source == 0) { return (0, true) }
        //    We now have a non-zero value; convert it to a strictly positive value
        //    by taking the magnitude.
        let magnitude = source.magnitude
        var exponent = magnitude._binaryLogarithm()
        //    If the exponent would be larger than the largest representable
        //    exponent, the result is just an infinity of the appropriate sign.
        if exponent > Self.greatestFiniteMagnitude.exponent {
            return (if Source.isSigned && source < 0 then -Self.infinity else Self.infinity, false)
        }
        //    If exponent <= significandBitCount, we don't need to round it to
        //    construct the significand; we just need to left-shift it into place;
        //    the result is always exact as we've accounted for exponent-too-large
        //    already and no rounding can occur.
        if exponent <= Self.significandBitCount {
            let shift = Self.significandBitCount &- exponent
            let significand = RawSignificand(magnitude) &<< shift
            let value = Self(
                sign: if Source.isSigned && source < 0 then .minus else .plus,
                exponentBitPattern: exponentBias + RawExponent(exponent),
                significandBitPattern: significand
            )
            return (value, true)
        }
        //    exponent > significandBitCount, so we need to do a rounding right
        //    shift, and adjust exponent if needed
        let shift = exponent &- Self.significandBitCount
        let halfway = (1 as Source.Magnitude) << (shift - 1)
        let mask = 2 * halfway - 1
        let fraction = magnitude & mask
        var significand = RawSignificand(truncatingIfNeeded: magnitude >> shift) & significandMask
        if fraction > halfway || (fraction == halfway && significand & 1 == 1) {
            var carry = false
            (significand, carry) = significand.addingReportingOverflow(1)
            if carry || significand > significandMask {
                exponent += 1
                if exponent > Self.greatestFiniteMagnitude.exponent {
                    return (if Source.isSigned && source < 0 then -Self.infinity else Self.infinity, false)
                }
            }
        }
        return (Self(
            sign: if Source.isSigned && source < 0 then .minus else .plus,
            exponentBitPattern: exponentBias + RawExponent(exponent),
            significandBitPattern: significand
        ), fraction == 0)*/
        unimplemented!()
    }

    /// \inherit
    default init<Source: BinaryInteger>(_ value: Source) {
        let (value_, exact) = Self._convert(from: value)
        self = value_
    }
    
    /// \inherit
    default init? <Source: BinaryInteger>(exactly value: Source) {
        let (value_, exact) = Self._convert(from: value)
        if !exact { return none }
        self = value_
    }
}

extend BinaryFloatingPoint with StringRepresentable {
    def toString(precision: Int, padWithZero: Bool = true) -> String {
        var fp = self
        var s = ""

        if fp < 0.0 {
            s += '-'
            fp = -fp
        }

        var i = Int(fp * ((10.0 as Self) ** precision))
        var neededDigits = 0
        var _i = i

        loop {
            neededDigits += 1
            _i /= 10

            if _i == 0 {
                break
            }
        }

        var power = neededDigits - 1
        loop {
            if power == precision - 1 {
                s += '.'
            }

            var exp = 10 ** power
            var fits = i / exp

            s += Character(ascii: UInt8(fits) + '0')
            i -= exp * fits

            if power == 0 || (i <= 0 && !padWithZero) {
                break
            }

            power -= 1
        }

        return s
    }

    default def toString() -> String {
        return toString(precision: 2)
    }
}

macro constants {
    (32) => {
        /// \inherit
        init (_ val: Float) {
            self = val
        }

        /// \inherit
        init (_ val: Double) {
            self = Self(builtin.fptrunc_f64_f32(val.value))
        }

        /// \inherit
        init (_ val: Int) {
            self = Self(builtin.itofp_i64_f32(val.value))
        }

        /// \inherit
        static prop infinity: Self {
            return Self(bitPattern: 0b0_11111111_00000000000000000000000)
        }

        /// \inherit
        static prop nan: Self {
            return Self(bitPattern: 0b0_11111111_10000000000000000000000)
        }

        /// \inherit
        static prop greatestFiniteMagnitude: Self {
            return 0x1.fffffep127
        }

        /// \inherit
        static prop pi: Self {
            return 0x1.921fb4p1
        }

        /// \inherit
        static prop leastNormalMagnitude: Self {
            return 0x1p-126
        }

        /// \inherit
        static prop leastNonzeroMagnitude: Self {
            return 0x1p-149
        }

        /// \inherit
        static prop ulpOfOne: Self {
            return 0x1p-23
        }
    },
    (64) => {
        /// \inherit
        init (_ val: Float) {
            self = Self(builtin.fpext_f32_f64(val.value))
        }

        /// \inherit
        init (_ val: Double) {
            self = val
        }

        /// \inherit
        init (_ val: Int) {
            self = Self(builtin.itofp_i64_f64(val.value))
        }

        /// \inherit
        static prop infinity: Self {
            return Self(
                bitPattern: 0b0_11111111111_0000000000000000000000000000000000000000000000000000)
        }

        /// \inherit
        static prop nan: Self {
            return Self(
                bitPattern: 0b0_11111111111_1000000000000000000000000000000000000000000000000000)
        }

        /// \inherit
        static prop greatestFiniteMagnitude: Self {
            return 0x1.fffffffffffffp1023
        }

        /// \inherit
        static prop pi: Self {
            return 0x1.921fb54442d18p1
        }

        /// \inherit
        static prop leastNormalMagnitude: Self {
            return 0x1p-1022
        }

        /// \inherit
        static prop leastNonzeroMagnitude: Self {
            return 0x1p-1074
        }

        /// \inherit
        static prop ulpOfOne: Self {
            return 0x1p-52
        }
    }
}

fileprivate macro proxy_operator {
    ($(($op:tok, $builtinName:tok)),*) => { $(
        def mutating infix ${$op =}(_ rhs: Self) {
            value = builtin.$builtinName(value, rhs.value)
        }
    )... }
}

/// Defines a wrapper for a builtin floating point type.
macro fp_type {
    ($Self:tok, $Bits:tok, $BuiltinType:tok, $ExponentBitCount:tok,
     $SignificandBitCount:tok, $SignificandSize:tok) => {
        @_builtin @_semantics("builtin_fp_type")
        public struct $Self with BuiltinFloatingPointType {
            /// The builtin integer value.
            internal var value: builtin.$BuiltinType

            /// Default C'tor, initializes to zero.
            init {
                self = 0.0
            }

            /// Internal memberwise C'tor.
            internal init (_ value: builtin.$BuiltinType) {
                self.value = value
            }
        }

        extend $Self with _AtomicProtocol {
            /// \inherit
            alias _AtomicType = builtin.$BuiltinType

            /// \inherit
            prop _atomicValue: _AtomicType { return value }

            /// \inherit
            init (_atomicValue value: _AtomicType) {
                self.init(value)
            }
        }

        extend $Self with BinaryFloatingPoint {
            /// \inherit
            alias Magnitude = Self

            /// \inherit
            alias Exponent = Int

            /// \inherit
            alias RawExponent = UInt

            /// \inherit
            alias RawSignificand = ${UInt $SignificandSize};

            /// Unsigned integer type with the same number of bits.
            internal alias BitPatternType = ${UInt $Bits};

            /// \inherit
            static prop exponentBitCount: Int {
                return $ExponentBitCount
            } 

            /// \inherit
            static prop significandBitCount: Int {
                return $SignificandBitCount
            }

            //  Implementation details.
            internal static prop _infinityExponent: UInt {
                return UInt(1) &<< UInt(exponentBitCount) - UInt(1)
            }

            internal static prop _exponentBias: UInt {
                return _infinityExponent &>> UInt(1)
            }

            internal static prop _significandMask: RawSignificand {
                return RawSignificand(1) &<< RawSignificand(significandBitCount) - RawSignificand(1)
            }

            internal static prop _quietNaNMask: RawSignificand {
                return RawSignificand(1) &<< (RawSignificand(significandBitCount) - RawSignificand(1))
            }

            /// \inherit
            prop bitPattern: BitPatternType {
                return BitPatternType(_builtinNumericCast(value))
            }

            /// \inherit
            init (bitPattern: BitPatternType) {
                self.value = _builtinNumericCast(bitPattern.value)
            }

            /// \inherit
            prop sign: FloatingPointSign {
                let shift = significandBitCount + Self.exponentBitCount
                if bitPattern &>> shift == 0 {
                    return .plus
                }

                return .minus
            }

            /// \inherit
            prop exponentBitPattern: UInt {
                return (UInt(bitPattern &>> BitPatternType(significandBitCount))
                    & _infinityExponent)
            }

            /// \inherit
            prop significandBitPattern: RawSignificand {
                return RawSignificand(bitPattern) & _significandMask
            }

            /// \inherit
            init (sign: FloatingPointSign,
                  exponentBitPattern: UInt,
                  significandBitPattern: RawSignificand) {
                let signShift = significandBitCount + exponentBitCount
                let sign = BitPatternType(if sign == .minus then 1 else 0)
                let exponent = BitPatternType(
                    exponentBitPattern & _infinityExponent)
                let significand = BitPatternType(
                    significandBitPattern & ${Self}._significandMask)

                self.init(bitPattern: (sign &<< BitPatternType(signShift) |
                    exponent &<< BitPatternType(${Self}.significandBitCount) |
                    significand))
            }

            /// \inherit
            prop isCanonical: Bool {
                return true
            }

            constants!{ $Bits }

            /// \inherit
            static prop signalingNaN: Self {
                return Self(nan: 0, signaling: true)
            }

            /// \inherit
            prop ulp: Self {
                if likely(!isFinite) {
                    return .nan
                }

                if likely(isNormal) {
                    let bitPattern_ = bitPattern & ${Self}.infinity.bitPattern
                    return Self(bitPattern: bitPattern_) * 0x1p - $SignificandBitCount
                }

                // On arm, flush subnormal values to 0.
                return Self.leastNormalMagnitude * 0x1p - $SignificandBitCount
            }

            prop exponent: Int {
                if !isFinite { return .max }
                if isZero { return .min }

                let provisional = Int(exponentBitPattern) - Int(_exponentBias)
                if isNormal { return provisional }

                let shift = significandBitCount - significandBitPattern._binaryLogarithm()
                return provisional + 1 - shift
            }

            prop significand: Self {
                if isNaN { return self }
                if isNormal {
                    return Self(sign: .plus,
                                exponentBitPattern: _exponentBias,
                                significandBitPattern: significandBitPattern)
                }

                if isSubnormal {
                    let shift = significandBitCount - significandBitPattern._binaryLogarithm()
                    return Self(sign: .plus,
                                exponentBitPattern: ${Self}._exponentBias,
                                significandBitPattern: significandBitPattern &<< shift)
                }

                // zero or infinity.
                return Self(sign: .plus,
                            exponentBitPattern: exponentBitPattern,
                            significandBitPattern: 0)
            }

            public init(sign: FloatingPointSign, exponent: Int, significand: Self) {
                var result = significand
                if sign == .minus {
                    result = -result
                }

                if significand.isFinite && !significand.isZero {
                    var clamped = exponent
                    let leastNormalExponent = 1 - Int(_exponentBias)
                    let greatestFiniteExponent = Int(_exponentBias)
                    if clamped < leastNormalExponent {
                        clamped = math.max(clamped, 3 * leastNormalExponent)
                        while clamped < leastNormalExponent {
                            result  *= leastNormalMagnitude
                            clamped -= leastNormalExponent
                        }
                    } else if clamped > greatestFiniteExponent {
                        clamped = math.min(clamped, 3 * greatestFiniteExponent)
                        let step = Self(sign: .plus,
                                        exponentBitPattern: _infinityExponent - 1,
                                        significandBitPattern: 0)

                        while clamped > greatestFiniteExponent {
                            result  *= step
                            clamped -= greatestFiniteExponent
                        }
                    }

                    let scale = Self(sign: .plus,
                                     exponentBitPattern: UInt(Int(_exponentBias) + clamped),
                                     significandBitPattern: 0)

                    result = result * scale
                }

                self = result
            }

            init (nan payload: RawSignificand, signaling: Bool) {
                // We use significandBitCount - 2 bits for NaN payload.
                precondition!(payload < (_quietNaNMask &>> 1),
                              "NaN payload is not encodable.")

                var significand = payload
                significand |= _quietNaNMask &>> (if signaling then 1 else 0)
                self.init(sign: .plus,
                          exponentBitPattern: _infinityExponent,
                          significandBitPattern: significand)
            }

            /// \inherit
            prop nextUp: Self {
                if isNaN { /* Silence signaling NaNs. */ return self + 0 }
                if sign == .minus {
                    if significandBitPattern == 0 {
                        if exponentBitPattern == 0 {
                            return leastNonzeroMagnitude
                        }

                        return Self(sign: .minus,
                                    exponentBitPattern: exponentBitPattern - 1,
                                    significandBitPattern: ${Self}._significandMask)
                    }
                    return Self(sign: .minus,
                                exponentBitPattern: exponentBitPattern,
                                significandBitPattern: significandBitPattern - 1)
                }

                if isInfinite { return self }
                if significandBitPattern == _significandMask {
                    return Self(sign: .plus,
                                exponentBitPattern: exponentBitPattern + 1,
                                significandBitPattern: 0)
                }

                return Self(sign: .plus,
                            exponentBitPattern: exponentBitPattern,
                            significandBitPattern: significandBitPattern + 1)
            }

            /// \inherit
            def mutating round(_ rule: FloatingPointRoundingRule) {
                match rule {
                case .toNearestOrAwayFromZero:
                    value = builtin.${round_ $BuiltinType}(value)
                case .toNearestOrEven:
                    value = builtin.${rint_ $BuiltinType}(value)
                case .towardZero:
                    value = builtin.${trunc_ $BuiltinType}(value)
                case .awayFromZero:
                    if sign == .minus {
                        value = builtin.${floor_ $BuiltinType}(value)
                    }
                    else {
                        value = builtin.${ceil_ $BuiltinType}(value)
                    }
                case .up:
                    value = builtin.${ceil_ $BuiltinType}(value)
                case .down:
                    value = builtin.${floor_ $BuiltinType}(value)
                }
            }

            /// \inherit
            def mutating negate() {
                value = builtin.${fneg_ $BuiltinType}(value)
            }

            // Define arithmetic operators.
            proxy_operator!{
                (+, ${fadd_ $BuiltinType}),
                (-, ${fsub_ $BuiltinType}),
                (*, ${fmul_ $BuiltinType}),
                (/, ${fdiv_ $BuiltinType}),
                (**, ${pow_ $BuiltinType})
            }

            /// \inherit
            def mutating infix **=(rhs: Int) {
                value = builtin.${powi_ $BuiltinType}(value, builtin.trunc_i64_i32(rhs.value))
            }

            /// \inherit
            def prefix -() -> Self {
                var copy = self
                copy.negate()
                return copy
            }

            /// \inherit
            def mutating formRemainder(dividingBy other: Self) {
                value = builtin.${frem_ $BuiltinType}(value, other.value)
            }

            /// \inherit
            def mutating formTruncatingRemainder(dividingBy other: Self) {
                value = builtin.${frem_ $BuiltinType}(value, other.value)
            }

            /// \inherit
            def mutating formSquareRoot() {
                value = builtin.${sqrt_ $BuiltinType}(value)
            }

            /// \inherit
            def mutating addProduct(_ lhs: Self, _ rhs: Self) {
                value = builtin.${fma_ $BuiltinType}(lhs.value, rhs.value, value)
            }

            /// \inherit
            def isEqual(to other: Self) -> Bool {
                return Bool(builtin.${fcmp_oeq_ $BuiltinType}(value, other.value))
            }

            /// \inherit
            def isLess(than other: Self) -> Bool {
                return Bool(builtin.${fcmp_olt_ $BuiltinType}(value, other.value))
            }

            /// \inherit
            def isLessThanOrEqualTo(_ other: Self) -> Bool {
                return Bool(builtin.${fcmp_olt_ $BuiltinType}(value, other.value))
            }

            /// \inherit
            prop isNormal: Bool {
                return exponentBitPattern > 0 && isFinite
            }

            /// \inherit
            prop isFinite: Bool {
                return exponentBitPattern < _infinityExponent
            }

            /// \inherit
            prop isZero: Bool {
                return exponentBitPattern == 0 && significandBitPattern == 0
            }

            /// \inherit
            prop isSubnormal: Bool {
                return exponentBitPattern == 0 && significandBitPattern != 0
            }

            /// \inherit
            prop isInfinite: Bool {
                return !isFinite && significandBitPattern == 0
            }

            /// \inherit
            prop isNaN: Bool {
                return !isFinite && significandBitPattern != 0
            }

            /// \inherit
            prop isSignalingNaN: Bool {
                return isNaN && (significandBitPattern & _quietNaNMask) == 0
            }

            /// \inherit
            prop binade: Self {
                if likely(!isFinite) {
                    return .nan
                }

                if exponentBitPattern != 0 {
                    return Self(sign: sign, exponentBitPattern: exponentBitPattern,
                                significandBitPattern: 0)
                }

                if significandBitPattern == 0 { return self }

                // For subnormals, we isolate the leading significand bit.
                let index = significandBitPattern._binaryLogarithm()
                return Self(sign: sign, exponentBitPattern: 0,
                            significandBitPattern: RawSignificand(1 &<< index))
            }

            /// \inherit
            prop significandWidth: Int {
                let trailingZeroBits = significandBitPattern.trailingZeroBitCount
                if isNormal {
                    if significandBitPattern == 0 { return 0 }
                    return significandBitCount &- trailingZeroBits
                }
                if isSubnormal {
                    let leadingZeroBits = significandBitPattern.leadingZeroBitCount
                    return RawSignificand.bitWidth &- (trailingZeroBits &+ leadingZeroBits &+ 1)
                }
                return -1
            }
        }

        extend $Self with ExpressibleByFloatingPointLiteral {
            /// \inherit
            alias FloatingPointType = Self

            /// \inherit
            init (floatingPointLiteral value: Self) {
                self = value
            }
        }

        extend $Self with ExpressibleByIntegerLiteral {
            /// \inherit
            alias IntegerType = Int64

            /// \inherit
            init (integerLiteral value: Int64) {
                self.value = value.value as builtin.$BuiltinType
            }
        }

        extend $Self {
            /// \inherit
            prop magnitude: Self {
                return Self(builtin.${fabs_ $BuiltinType}(value))
            }

            /// \inherit
            init <Source: FixedWidthInteger>(_ value: Source) {
                // FIXME wordBits
                if Source.bitWidth <= 64 {
                    if Source.isSigned {
                        let asInt = Int(truncatingIfNeeded: value)
                        self.value = builtin.${itofp_i64_f $Bits}(asInt.value)
                    } else {
                        let asUInt = UInt(truncatingIfNeeded: value)
                        self.value = builtin.${itofp_u64_f $Bits}(asUInt.value)
                    }
                } else {
                    let (value_, exact) = Self._convert(from: value)
                    self = value_
                }
            }
        }
    }
}

// Define Float and Double types.
fp_type!{ Float, 32, f32, 8, 23, 32 }
fp_type!{ Double, 64, f64, 11, 52, 64 }
