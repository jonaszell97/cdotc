
module std.rt

public struct ValueWitnessTable {
    /// Function that copies an existential value.
    let copy: @thin (UnsafeRawPtr, UnsafeMutableRawPtr) -> Void

    /// Function that deinitializes an existential value.
    let deinit: @thin (UnsafeMutableRawPtr) -> Void
}

public struct ProtocolConformance {
    /// Pointer to the protocol type-info object.
    var typeInfo: UnsafePtr<TypeInfo>

    /// Pointer to the vtable for this protocol.
    var vtable: UnsafePtr<UnsafeRawPtr>

    /// Implicit conversion to bool.
    @implicit def infix as() -> Bool {
        return typeInfo != __nullptr
    }
}

public struct TypeInfo {
    /// Pointer to the base class type-info object, or `null` if there is none.
    let baseClass: UnsafePtr<TypeInfo>

    /// Pointer to the vtable in case of a class or protocol.
    let vtable: UnsafePtr<UnsafeRawPtr>

    /// NUL-terminated cstring containing the type name.
    let name: UnsafePtr<Byte>

    /// Pointer to the value witness table of this type.
    let valueWitnessTable: UnsafePtr<ValueWitnessTable>

    /// null-terminated array of protocol conformance objects.
    let conformances: UnsafePtr<ProtocolConformance>

    /// The size of a value of this type, in bytes.
    let size: UInt

    /// The alignment of a value of this type, in bytes.
    let alignment: UInt

    /// The stride of a value of this type, in bytes.
    let stride: UInt

    /// \return the vtable for a particular protocol.
    def getConformance(_ proto: UnsafePtr<TypeInfo>) -> UnsafePtr<ProtocolConformance> {
        if !conformances {
            sys.reportFatalError("type does not conform to protocol!")
        }

        var i = 0
        var conf = &conformances[i++]

        while conf {
            if conf.typeInfo == proto {
                return builtin.addressOf(conf)
            }

            conf = &conformances[i++]
        }

        sys.reportFatalError("type does not conform to protocol!")
    }
}

struct ClassHeader {
    /// Strong reference count of this class.
    var strongRefcount: u64

    /// Weak reference count of this class.
    var weakRefcount: u64

    /// Pointer to the type-info object.
    let typeInfo: UnsafePtr<TypeInfo>
}

/// \return pointer to the type-info object of a class.
@extern(C) public def _cdot_GetTypeInfo(_ ptr: UnsafePtr<ClassHeader>) -> UnsafePtr<TypeInfo> {
    return ptr->typeInfo
}

/// Compare two type-info objects for compatibility.
/// \return `true` iff they're compatible.
@extern(C) public def _cdot_TypeInfoCmp(_ lhs: UnsafePtr<TypeInfo>,
                                        _ rhs: UnsafePtr<TypeInfo>) -> Bool {
    var curr = lhs
    while curr {
        if curr == rhs {
            return true
        }

        curr = curr->baseClass
    }

    if !lhs->conformances {
        return false
    }

    var i = 0u
    curr = lhs->conformances[i++]

    while curr {
        if curr->typeInfo == rhs {
            return true
        }

        curr = lhs->conformances[i++]
    }

    return false
}

struct AnyOption {
    var discriminator: Int8
    var objectRef: UnsafePtr<ClassHeader>
}

/// Perform a dynamic downcast from a base class to a child.
/// \return `none` if the cast failed, `.Some(value)` otherwise.
@extern(C) public def _cdot_DynamicDownCast(_ object: UnsafePtr<ClassHeader>,
                                            _ rhs: UnsafePtr<TypeInfo>) -> AnyOption {
    var curr = object->typeInfo
    while curr {
        if curr == rhs {
            return AnyOption(discriminator: 1, objectRef: object)
        }

        curr = curr->baseClass
    }

    return AnyOption(discriminator: 0, objectRef: __nullptr)
}

struct ExistentialContainer {
    /// Pointer to the heap allocated memory where the value resides.
    var value: UnsafeMutableRawPtr

    /// Pointer to the type-info object of the wrapped value.
    var typeInfo: UnsafePtr<TypeInfo>

    /// Pointer to the currently active protocol conformance.
    var conformance: UnsafePtr<ProtocolConformance>
}

/// Initialize an existential container for a protocol value.
/// This function takes ownership of \param value without making a copy.
@extern(C)
public def _cdot_InitializeExistential(_ value: UnsafeRawPtr,
                                       _ valueTypeInfo: UnsafePtr<TypeInfo>, 
                                       _ protocolTypeInfo: UnsafePtr<TypeInfo>,
                                       _ result: mut ref ExistentialContainer) {
    // Heap-allocate space for the existential value.
    var alloc = mem.allocate(valueTypeInfo->stride, valueTypeInfo->alignment)

    // Do a shallow copy of the value.
    mem.copy(to: alloc, from: value, valueTypeInfo->size)

    // Get the protocol conformance.
    var conformance = valueTypeInfo->getConformance(protocolTypeInfo)

    // Initialize the existential container.
    result = ExistentialContainer(value: alloc, typeInfo: valueTypeInfo, conformance)
}

/// Deinitialize an existential container for a protocol value.
@extern(C)
public def _cdot_DeinitializeExistential(_ container: mut ref ExistentialContainer) {
    // Call the deinitializer of the existential value.
    container.typeInfo->deinit(container.value)

    // Free the memory allocated for the value.
    mem.deallocate(container.value)
}

/// Copy an existential container for a protocol value.
@extern(C)
public def _cdot_CopyExistential(_ container: mut ref ExistentialContainer,
                                 _ result: mut ref ExistentialContainer) {
    // Heap-allocate space for the existential value.
    var alloc = mem.allocate(container.typeInfo->stride,
                             container.typeInfo->alignment)

    // Call the witness copy function to create a copy of the value.
    container.typeInfo->valueWitnessTable->copy(value, alloc)

    // Initialize the existential container with the copied value.
    result = ExistentialContainer(value: alloc,
                                  typeInfo: container.typeInfo,
                                  conformance: container.conformance)
}
