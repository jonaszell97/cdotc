
using atomic.Atomic

internal protocol RC {
    prop strongRefcount: UInt { get set }
    prop weakRefcount: UInt { get set }
}

extend RC {
    @inline(always)
    def mutating strongRetain() {
        strongRefcount = strongRefcount + 1
    }

    @inline(always)
    def mutating strongRelease() {
        strongRefcount = strongRefcount - 1
    }

    @inline(always)
    def mutating weakRetain() {
        weakRefcount = weakRefcount + 1
    }

    @inline(always)
    def mutating weakRelease() {
        weakRefcount = weakRefcount - 1
    }
}

struct Refcounted with RC {
    var _strongRefcount: UInt
    var _weakRefcount: UInt
    let typeInfo: UnsafePtr<TypeInfo>

    prop strongRefcount: UInt {
        get { return _strongRefcount }
        set { _strongRefcount = newVal }
    }

    prop weakRefcount: UInt {
        get { return _weakRefcount }
        set { _weakRefcount = newVal }
    }
}

alias debugPrintEnabled = false
macro debugPrint(
    ($($args:expr),*) => {
        static if debugPrintEnabled {
            _ = libc.stdio.printf($($args,)...)
        }
    }
)

@inline(always) @extern(C)
public def _cdot_Retain(_ target: UnsafeMutablePtr<Refcounted>) {
    assert!(target->strongRefcount != 0, "[1;35mretaining freed object $target![0m\n")

    target.withReference { $0.strongRetain() }

    debugPrint!("object %p of type %s after retain: %llu\n",
                target, target->typeInfo->name, target->strongRefcount)
}

@inline(always) @extern(C)
public def _cdot_WeakRetain(_ target: UnsafeMutablePtr<Refcounted>) {
    assert!(target->strongRefcount != 0, "[1;35mretaining freed object $target![0m\n")

    target.withReference { $0.weakRetain() }
    debugPrint!("object %p of type %s after weak retain: %llu\n",
                target, target->typeInfo->name, target->weakRefcount)
}

@inline(always) @extern(C)
public def _cdot_Release(_ target: owned UnsafeMutablePtr<Refcounted>) {
    if !target {
        return
    }

    assert!(target->strongRefcount != 0, "[1;35mtrying to release object $target with refcount of 0![0m\n")

    target.withReference { $0.strongRelease() }
    
    debugPrint!("object %p of type %s after release: %llu\n",
               target, target->typeInfo->name, target->strongRefcount)

    if target->strongRefcount == 0 {
        target->typeInfo->deinit(UnsafeMutableRawPtr(target))

        if target->weakRefcount == 0 {
            target.deallocate()
        }
    }
}

@inline(always) @extern(C)
public def _cdot_WeakRelease(_ target: owned UnsafeMutablePtr<Refcounted>) {
    if !target {
        return
    }

    assert!(target->strongRefcount != 0, "[1;35mtrying to release object $target with refcount of 0![0m\n")

    target.withReference { $0.weakRelease() }

    debugPrint!("object %p of type %s after weak release: %llu\n",
               target, target->typeInfo->name, target->weakRefcount)

    if target->weakRefcount == 0u {
        target.deallocate()
    }
}

struct AtomicRefcounted with RC {
    var _strongRefcount: Atomic<UInt>
    var _weakRefcount: Atomic<UInt>
    let typeInfo: UnsafePtr<TypeInfo>

    prop strongRefcount: UInt {
        get { return _strongRefcount.load() }
        set { _strongRefcount.store(newVal) }
    }

    prop weakRefcount: UInt {
        get { return _weakRefcount.load() }
        set { _weakRefcount.store(newVal) }
    }
}

@_builtin @extern(C) @inline(always)
public def _cdot_AtomicRetain(_ target: UnsafeMutablePtr<AtomicRefcounted>) {
    assert!(target->strongRefcount != 0u, "[1;35mretaining freed object $target![0m\n")

    target.withReference { $0.strongRetain() }
    debugPrint!("object %p of type %s after retain: %llu\n",
                target, target->typeInfo->name, target->strongRefcount.load())
}

@inline(always) @extern(C)
public def _cdot_AtomicWeakRetain(_ target: UnsafeMutablePtr<AtomicRefcounted>) {
    assert!(target->strongRefcount != 0u, "[1;35mretaining freed object $target![0m\n")

    target.withReference { $0.weakRetain() }
    debugPrint!("object %p of type %s after weak retain: %llu\n",
                target, target->typeInfo->name, target->weakRefcount.load())
}

@_builtin @extern(C) @inline(always)
public def _cdot_AtomicRelease(_ target: owned UnsafeMutablePtr<AtomicRefcounted>) {
    if !target {
        return
    }

    assert!(target->strongRefcount != 0u,
            "[1;35mtrying to release object $target with refcount of 0![0m\n")
    
    target.withReference { $0.strongRelease() }
    
    debugPrint!("object %p of type %s after release: %llu\n",
                target, target->typeInfo->name, target->strongRefcount.load())

    if target->strongRefcount == 0u {
        target->typeInfo->deinit(UnsafeMutableRawPtr(target))

        if target->weakRefcount == 0u {
            target.deallocate()
        }
    }
}

@inline(always) @extern(C)
public def _cdot_AtomicWeakRelease(_ target: owned UnsafeMutablePtr<AtomicRefcounted>) {
    if !target {
        return
    }

    assert!(target->strongRefcount != 0u,
            "[1;35mtrying to release object $target with refcount of 0![0m\n")
    
    target.withReference { $0.weakRelease() }
    
    debugPrint!("object %p of type %s after weak release: %llu\n",
                target, target->typeInfo->name, target->weakRefcount.load())

    if target->weakRefcount == 0u {
        target.deallocate()
    }
}

struct Box with RC {
    var _strongRefcount: UInt
    var _weakRefcount: UInt
    var deinitializer: @thin (UnsafeMutableRawPtr) -> Void
    var data: UnsafeMutableRawPtr

    prop strongRefcount: UInt {
        get { return _strongRefcount }
        set { _strongRefcount = newVal }
    }

    prop weakRefcount: UInt {
        get { return _weakRefcount }
        set { _weakRefcount = newVal }
    }
}

@extern(C)
public def _cdot_RetainBox(_ box: UnsafeMutablePtr<Box>) {
    box.withReference { $0.strongRetain() }
    debugPrint!("box %p after retain: %llu\n", box, box->strongRefcount)
}

@extern(C)
public def _cdot_ReleaseBox(_ box: UnsafeMutablePtr<Box>) {
    if !box {
        return
    }

    box.withReference { $0.strongRelease() }
    debugPrint!("box %p after release: %llu\n", box, box->strongRefcount)

    if box->strongRefcount == 0 {
        debugPrint!("freeing box\n")
        if (box->deinitializer as! builtin.RawPointer) != (0 as! builtin.RawPointer) {
            box->deinitializer(box->data)
        }

        box.deallocate()
    }
}

struct AtomicBox with RC {
    var _strongRefcount: Atomic<UInt>
    var _weakRefcount: Atomic<UInt>
    var deinitializer: @thin (UnsafeMutableRawPtr) -> Void
    var data: Byte

    prop strongRefcount: UInt {
        get { return _strongRefcount.load() }
        set { _strongRefcount.store(newVal) }
    }

    prop weakRefcount: UInt {
        get { return _weakRefcount.load() }
        set { _weakRefcount.store(newVal) }
    }
}

@extern(C)
public def _cdot_AtomicRetainBox(_ box: UnsafeMutablePtr<AtomicBox>) {
    box.withReference { $0.strongRetain() }
    debugPrint!("box %p after retain: %llu\n", box, box->strongRefcount.load())
}

@extern(C)
public def _cdot_AtomicReleaseBox(_ box: UnsafeMutablePtr<AtomicBox>) {
    if !box {
        return
    }

    box.withReference { $0.strongRelease() }
    debugPrint!("box %p after release: %llu\n", box, box->strongRefcount.load())

    if box->strongRefcount == 0 {
        debugPrint!("freeing box\n")
        if (box->deinitializer as! builtin.RawPointer) != (0 as! builtin.RawPointer) {
            var dataPtr: UnsafeMutableRawPtr
            box.withReference {
                dataPtr = UnsafeMutableRawPtr(rawPointer: builtin.addressOf(&$0.data))
            }

            box->deinitializer(dataPtr)
        }
        
        box.deallocate()
    }
}

struct Lambda with RC {
    let fn: UnsafeMutableRawPtr
    var _strongRefcount: UInt
    var captures: UnsafeMutablePtr<Box>

    prop strongRefcount: UInt {
        get { return _strongRefcount }
        set { _strongRefcount = newVal }
    }

    prop weakRefcount: UInt {
        get { unimplemented!() }
        set { unimplemented!() }
    }
}

@extern(C)
public def _cdot_RetainLambda(_ lambda: UnsafeMutablePtr<Lambda>) {
    lambda.withReference { $0.strongRetain() }
    debugPrint!("lambda %p after retain: %llu\n", lambda, lambda->strongRefcount)
}

@extern(C)
public def _cdot_ReleaseLambda(_ lambda: UnsafeMutablePtr<Lambda>) {
    if !lambda {
        return
    }

    lambda.withReference { $0.strongRelease() }
    debugPrint!("lambda %p after release: %llu\n", lambda, lambda->strongRefcount)

    if lambda->strongRefcount == 0 {
        _cdot_CleanupLambda(lambda)
    }
}

@extern(C)
public def _cdot_CleanupLambda(_ lambda: UnsafeMutablePtr<Lambda>) {
    debugPrint!("freeing lambda\n")

    if lambda->captures {
        var i = 0
        var ptr: UnsafeMutablePtr<UnsafeMutablePtr<Box>>
        lambda.withReference {
            ptr = UnsafeMutablePtr<UnsafeMutablePtr<Box>>(
                rawPointer: builtin.addressOf(&$0.captures))
        }

        loop {
            var capt = *ptr
            if !capt {
                break
            }

            _cdot_ReleaseBox(capt)
            ptr += 1
        }
    }

    lambda.deallocate()
}

struct AtomicLambda with RC {
    let fn: UnsafeMutableRawPtr
    var _strongRefcount: Atomic<UInt>
    var captures: UnsafeMutablePtr<AtomicBox>

    prop strongRefcount: UInt {
        get { return _strongRefcount.load() }
        set { _strongRefcount.store(newVal) }
    }

    prop weakRefcount: UInt {
        get { unimplemented!() }
        set { unimplemented!() }
    }
}

@extern(C)
public def _cdot_AtomicRetainLambda(_ lambda: UnsafeMutablePtr<AtomicLambda>) {
    lambda.withReference { $0.strongRetain() }
    debugPrint!("lambda %p after retain: %llu\n", lambda, lambda->strongRefcount.load())
}

@extern(C)
public def _cdot_AtomicReleaseLambda(_ lambda: UnsafeMutablePtr<AtomicLambda>) {
    if !lambda {
        return
    }

    lambda.withReference { $0.strongRelease() }
    debugPrint!("lambda %p after release: %llu\n", lambda, lambda->strongRefcount.load())

    if lambda->strongRefcount == 0u {
        _cdot_AtomicCleanupLambda(lambda)
    }
}

@extern(C)
public def _cdot_AtomicCleanupLambda(_ lambda: UnsafeMutablePtr<AtomicLambda>) {
    debugPrint!("freeing lambda\n")

    if lambda->captures {
        var i = 0
        var ptr: UnsafeMutablePtr<UnsafeMutablePtr<AtomicBox>>
        lambda.withReference {
            ptr = UnsafeMutablePtr<UnsafeMutablePtr<AtomicBox>>(
                rawPointer: builtin.addressOf(&$0.captures))
        }

        loop {
            var capt = *ptr
            if !capt {
                break
            }

            _cdot_AtomicReleaseBox(capt)
            ptr += 1
        }
    }

    lambda.deallocate()
}
