
module std._private

/*

using Builtin.Primitive.*
using Extern.C.{ malloc, printf }
using cdot.{ TypeInfo, Protocol }

namespace {
    @_opaque
    struct _Unwind_Context {}

    typedef @rawPtr() (_Unwind_Reason_Code, _Unwind_Exception*) -> void as CleanupFn
    typedef @rawPtr() (uint8*) -> String as DescFn

    struct _Unwind_Exception {
        var exception_class: uint64
        var exception_cleanup: CleanupFn
        let private_1: uint64
        let private_2: uint64

        var error: uint8*
        var typeInfo: TypeInfo*
        var descFn: DescFn
    }

    enum HeaderValueFormat(uint8) with StringRepresentable {
        case DW_EH_PE_omit = 0xff,
          DW_EH_PE_uleb128 = 0x01,
          DW_EH_PE_udata2 = 0x02,
          DW_EH_PE_udata4 = 0x03,
          DW_EH_PE_udata8 = 0x04,
          DW_EH_PE_sleb128 = 0x09,
          DW_EH_PE_sdata2 = 0x0A,
          DW_EH_PE_sdata4 = 0x0B,
          DW_EH_PE_sdata8 = 0x0C
    }

    enum HeaderApplication(uint8) {
        case DW_EH_PE_absptr = 0x00,
          DW_EH_PE_pcrel = 0x10,
          DW_EH_PE_textrel = 0x20,
          DW_EH_PE_datarel = 0x30,
          DW_EH_PE_funcrel = 0x40,
          DW_EH_PE_aligned = 0x50,
          DW_EH_PE_indirect = 0x80
    }

    typedef uint64 as _Unwind_Ptr
    typedef int64  as _sleb128_t
    typedef uint64 as _uleb128_t

    def readEncodedValueWithBase(encoding: HeaderValueFormat,
                                base: _Unwind_Ptr,
                                data: uint8*) -> (_Unwind_Ptr, uint8*) {
        union DataTy {
            var u2: uint16
            var s2: int16
            var u4: uint32
            var s4: int32
            var u8: uint64
            var s8: int64
        }

        var result: _Unwind_Ptr = 0
        var p = data
        
        if encoding == HeaderApplication.DW_EH_PE_aligned {
            var a = p as! _Unwind_Ptr
            a = (a + sizeof<uint8* >() & -(sizeof<uint8* >() as! word) as uint64)
            result = *(a as! uint64*)
            p = (a + sizeof<uint8* >()) as! uint8*

            return (result, p)
        }

        let u = p as! DataTy*
        match (encoding & 0x0f) as HeaderValueFormat {
            case .DW_EH_PE_uleb128:
                let uleb = System.decodeULEB128(p)
                result = uleb.0 as uint64
                p += uleb.1
            case .DW_EH_PE_sleb128:
                let sleb = System.decodeSLEB128(p)
                result = sleb.0 as uint64
                p += sleb.1
            case .DW_EH_PE_udata2:
                result = u->u2
                p += 2
            case .DW_EH_PE_sdata2:
                result = u->s2 as! _Unwind_Ptr
                p += 2
            case .DW_EH_PE_udata4:
                result = u->u4
                p += 4
            case .DW_EH_PE_sdata4:
                result = u->s4 as! _Unwind_Ptr
                p += 4
            case .DW_EH_PE_udata8:
                result = u->u8
                p += 8
            case .DW_EH_PE_sdata8:
                result = u->s8 as! _Unwind_Ptr
                p += 8
            default:
                print("Unsupported encoding " + (encoding as String))
                System.exit(1)
        }

        if result != 0 {
            result += ((encoding & 0x70) == HeaderApplication.DW_EH_PE_pcrel ? data as! uint64 : base)
            if (encoding & HeaderApplication.DW_EH_PE_indirect) > 0 {
                result = *(result as! uint64*)
            }
        }

        return (result, p)
    }

    def readEncodedValue(ctx: _Unwind_Context*,
                        encoding: HeaderValueFormat,
                        data: uint8*) -> (_Unwind_Ptr, uint8*) {
        return readEncodedValueWithBase(encoding, baseOfEncodedValue(encoding, ctx), data)
    }

    def baseOfEncodedValue(encoding: HeaderValueFormat, ctx: _Unwind_Context*) -> _Unwind_Ptr {
        if encoding == .DW_EH_PE_omit {
            return 0
        }
        
        match (encoding & 0x70) as HeaderApplication {
            case .DW_EH_PE_absptr:
            case .DW_EH_PE_pcrel:
            case .DW_EH_PE_aligned:
                return 0
            case .DW_EH_PE_textrel:
                return _Unwind_GetTextRelBase(ctx)
            case .DW_EH_PE_datarel:
                return _Unwind_GetDataRelBase(ctx)
            case .DW_EH_PE_funcrel:
                return _Unwind_GetRegionStart(ctx)
            default:
                System.unreachable()
        }
    }

    def sizeOfEncodedValue(encoding: HeaderValueFormat) -> uint32 {
        if encoding == .DW_EH_PE_omit {
            return 0
        }

        match (encoding & 0x07) as HeaderValueFormat {
            case .DW_EH_PE_udata2:
                return 2
            case .DW_EH_PE_udata4:
                return 4
            case .DW_EH_PE_udata8:
                return 8
            default:
                return sizeof<uint8* >() as! uint32
        }
    }

    struct LSDA with StringRepresentable {
        struct CallSite with StringRepresentable {
            var start: _Unwind_Ptr = 0
            var len: _Unwind_Ptr   = 0
            var lp: _Unwind_Ptr    = 0
            var act: uint32        = 0

            def hasLandingPad() -> Bool {
                return lp != 0
            }

            def hasAction() -> Bool {
                return act != 0
            }
        }

        struct Action with StringRepresentable {
            var typeFilter: _sleb128_t = 0
            var next: _sleb128_t = 0

            def hasNext() -> Bool {
                return next != 0
            }
        }

        init (lsda: uint8**, ctx: _Unwind_Context*) {
            var startPtr = *lsda
            let startEncoding = *(startPtr++) as HeaderValueFormat
            
            Start = _Unwind_GetRegionStart(ctx)
            match startEncoding {
                case .DW_EH_PE_omit:
                    LPStart = Start
                default:
                    printf("unsupported encoding\n")
                    System.exit(1)
            }
            
            TTypeBase = 0
            TTypeEncoding = *(startPtr++) as HeaderValueFormat
            match TTypeEncoding {
                case .DW_EH_PE_omit:
                    TType = __nullptr<uint8>()
                default:
                    let sleb = System.decodeSLEB128(startPtr)
                    startPtr += sleb.1
                    TType = startPtr + sleb.0
            }
            
            // call site encoding, length and action table follow
            CallSiteEncoding = *(startPtr++) as HeaderValueFormat
            
            // get call site table length and skip that number of bytes
            // the action table follows
            let sleb = System.decodeULEB128(startPtr)
            startPtr += sleb.1

            CallSiteTable = startPtr
            ActionTable = startPtr + sleb.0
        }

        let Start: _Unwind_Ptr
        let LPStart: _Unwind_Ptr
        var TTypeBase: _Unwind_Ptr

        var TType: uint8*
        var TTypeEncoding: HeaderValueFormat

        var CallSiteTable: uint8*
        var CallSiteEncoding: HeaderValueFormat

        var ActionTable: uint8*

        def getNextCallSite (var ptr: ref uint8*) -> CallSite {
            var cs = CallSite()
            var next = readEncodedValue(__nullptr<_Unwind_Context>(), CallSiteEncoding, ptr)
            ptr = next.1
            cs.start = next.0

            next = readEncodedValue(__nullptr<_Unwind_Context>(), CallSiteEncoding, ptr)
            ptr = next.1
            cs.len = next.0

            next = readEncodedValue(__nullptr<_Unwind_Context>(), CallSiteEncoding, ptr)
            ptr = next.1
            cs.lp = next.0

            let uleb = System.decodeULEB128(ptr)
            ptr += uleb.1
            cs.act = uleb.0 as uint32

            return cs
        }

        def getNextAction (var ptr: ref uint8*) -> Action {
            var act = Action()
            var next = System.decodeSLEB128(ptr)
            act.typeFilter = next.0 as _sleb128_t
            ptr += next.1
            
            // offset is self-relative, so don't advance the pointer
            next = System.decodeSLEB128(ptr)
            act.next = next.0 as _sleb128_t

            return act
        }

        def getTypeInfoForAction (var act: ref Action) -> TypeInfo* {
            let i = act.typeFilter * (sizeOfEncodedValue(TTypeEncoding) as! int64)
            let ptr = readEncodedValueWithBase(TTypeEncoding, TTypeBase, TType - i)

            return ptr.0 as! TypeInfo*
        }
    }

    enum _Unwind_Reason_Code(int32) with StringRepresentable {
        case _URC_NO_REASON = 0,
            _URC_FOREIGN_EXCEPTION_CAUGHT = 1,
            _URC_FATAL_PHASE2_ERROR = 2,
            _URC_FATAL_PHASE1_ERROR = 3,
            _URC_NORMAL_STOP = 4,
            _URC_END_OF_STACK = 5,
            _URC_HANDLER_FOUND = 6,
            _URC_INSTALL_CONTEXT = 7,
            _URC_CONTINUE_UNWIND = 8
    }
    
    enum _Unwind_Action(int32) {
        case _UA_SEARCH_PHASE = 1,
            _UA_CLEANUP_PHASE = 2,
            _UA_HANDLER_FRAME = 4,
            _UA_FORCE_UNWIND = 8,
            _UA_END_OF_STACK = 16
    }

    declare C {
        def _Unwind_RaiseException(_Unwind_Exception*) -> _Unwind_Reason_Code
        def _Unwind_Resume(_Unwind_Exception*) -> void

        def _Unwind_GetGR(_Unwind_Context*, int32) -> _Unwind_Ptr
        def _Unwind_SetGR(_Unwind_Context*, int32, _Unwind_Ptr) -> void

        def _Unwind_GetIP(_Unwind_Context*) -> _Unwind_Ptr
        def _Unwind_SetIP(_Unwind_Context*, _Unwind_Ptr) -> void

        def _Unwind_GetLanguageSpecificData(_Unwind_Context*) -> _Unwind_Ptr
        def _Unwind_GetRegionStart(_Unwind_Context*) -> _Unwind_Ptr

        def _Unwind_GetTextRelBase(_Unwind_Context*) -> _Unwind_Ptr
        def _Unwind_GetDataRelBase(_Unwind_Context*) -> _Unwind_Ptr
    }

    def canHandle(thrown: TypeInfo*, lpad: TypeInfo*) -> Bool {
        // null indicates a catch-all landing pad
        if __builtin_isnull(lpad) {
            return true
        }

        if thrown->typeID == lpad->typeID {
            return true
        }

        for var i: uint64 = 0; i < thrown->_numConformedToProtocols; ++i {
            if lpad->typeID == thrown->_conformedToProtocols[i]->typeID {
                return true
            }
        }

        if !__builtin_isnull(thrown->_parentTypeInfo) {
            if canHandle(thrown->_parentTypeInfo, lpad) {
                return true
            }
        }

        return false
    }

    def prepareLandingPad(exc: _Unwind_Exception*,
                         ctx: _Unwind_Context*,
                         idx: _Unwind_Ptr,
                         lpAddr: _Unwind_Ptr) -> _Unwind_Reason_Code {
        let r0: int32 = #{__builtin_eh_data_regno_0}
        let r1: int32 = #{__builtin_eh_data_regno_1}

        _Unwind_SetGR(ctx, r0, exc as! _Unwind_Ptr)
        _Unwind_SetGR(ctx, r1, idx)
        _Unwind_SetIP(ctx, lpAddr)

        return ._URC_INSTALL_CONTEXT
    }

    #let exc_class = "0x00" + _NumFormat('t', 16) + _NumFormat('o', 16) + _NumFormat('D', 16) + _NumFormat('C', 16) + _NumFormat('V', 16) + _NumFormat('C', 16) + _NumFormat('D', 16)

    def malloc <T> () -> T* {
        return Extern.C.malloc(sizeof<T>()) as! T*
    }

    @extern(C)
    def __cdot_allocate_exception(size: int64,
                                  exc: uint8*,
                                  typeInfo: TypeInfo*,
                                  descFn: DescFn) -> _Unwind_Exception* {
        let alloc = malloc<_Unwind_Exception>()
        
        alloc->exception_class = _ParseInt(exc_class, 16)
        alloc->exception_cleanup = __nullptr
        alloc->typeInfo = typeInfo
        alloc->descFn = descFn
        alloc->error = exc
        
        return alloc
    }

    def __dump_exc(exc: _Unwind_Exception*) {
        var s = "uncaught exception of type ${exc->typeInfo->name}"
        if !__builtin_isnull(exc->descFn) {
            s += ": ${exc->descFn(exc->error)}"
        }
        
        println(s)
        System.exit(1)
    }

    @extern(C)
    def __cdot_throw(exc: uint8*) {
        _Unwind_RaiseException(exc as! _Unwind_Exception*)

        // if _Unwind_RaiseException returns, the exception wasn't caught
        __dump_exc(exc as! _Unwind_Exception*)
    }

    @extern(C)
    def __cdot_rethrow(exc: _Unwind_Exception*) {
        _Unwind_RaiseException(exc)
        __dump_exc(exc)
    }

    @extern(C)
    def __cdot_begin_catch(exc: _Unwind_Exception*) -> uint8* {
        return exc->error
    }

    @extern(C)
    def __cdot_end_catch(exc: _Unwind_Exception*) {
        free(exc as! int8*)
    }

    @extern(C)
    def __cdot_personality(version: int32,
                          actions: _Unwind_Action,
                          excClass: uint64,
                          exceptionObj: _Unwind_Exception*,
                          context: _Unwind_Context*) -> _Unwind_Reason_Code {
        enum FoundKind {
            case FoundCleanup,
              FoundHandler,
              FoundNothing
        }

        var found: FoundKind = .FoundNothing

        let ip = _Unwind_GetIP(context) - 1
        var landingPad: _Unwind_Ptr = 0
        var actionPtr = __nullptr<uint8>()
        var switchVal: _Unwind_Ptr = 0

        let thrownTypeInfo = exceptionObj->typeInfo

        let lsdaPtr = _Unwind_GetLanguageSpecificData(context)

        var lsda = LSDA(&lsdaPtr as! uint8**, context)
        lsda.TTypeBase = baseOfEncodedValue(lsda.TTypeEncoding, context)

        let isSearch = (actions & ._UA_SEARCH_PHASE) > 0
        let isCleanup = (actions & ._UA_CLEANUP_PHASE) > 0

        var p = lsda.CallSiteTable
        while p < lsda.ActionTable {
            var cs = lsda.getNextCallSite(p)
            let begin = lsda.Start + cs.start
            let end = begin + cs.len

            if ip < begin {
                p = lsda.ActionTable
            } else if ip < end {
                if cs.hasLandingPad() {
                    landingPad = lsda.LPStart + cs.lp
                }
                if cs.hasAction() {
                    actionPtr = lsda.ActionTable + cs.act - 1
                }
            }
        }

        if landingPad == 0 {
            // nothing found
        } else if __builtin_isnull(actionPtr) {
            // found only a cleanup
            found = .FoundCleanup
        } else {
            var foundHandler = false
            var foundCleanup = false
            var act = LSDA.Action()
            
            // loop over all actions and look for a match
            loop {
                act = lsda.getNextAction(actionPtr)
                if act.typeFilter == 0 {
                    // 0 filter means cleanup
                    foundCleanup = true
                } else if act.typeFilter > 0 {
                    // positive values are handlers
                    let handlerTypeInfo = lsda.getTypeInfoForAction(act)
                    if canHandle(thrownTypeInfo, handlerTypeInfo) {
                        foundHandler = true
                        break
                    }
                } else {
                    // exception specifications
                    System.unreachable()
                }

                // 0 means no more actions
                if act.next == 0 {
                    break
                }
                
                actionPtr += act.next
            }

            if foundHandler {
                switchVal = act.typeFilter as _Unwind_Ptr
                found = .FoundHandler
            } else if foundCleanup {
                found = .FoundCleanup
            }
        }

        if isSearch {
            if found == .FoundHandler {
                return ._URC_HANDLER_FOUND
            } 

            return ._URC_CONTINUE_UNWIND
        }

        if found != .FoundHandler {
            return ._URC_CONTINUE_UNWIND
        }

        prepareLandingPad(exceptionObj, context, switchVal, landingPad)
        
        return ._URC_INSTALL_CONTEXT
    }
}

*/