
@compiletime
module std.prelude

alias IsUnsigned<T> = __traits(is_unsigned, T)
alias IsSigned<T>   = !__traits(is_unsigned, T)
alias IsIntegral<I> = __traits(is_integer, I)

// namespace experimental {

// macro proxy_operator{
//     ($($op:tok)*) => { $(
//         /// @inherit
//         @inline(always)
//         def infix $op(rhs: Self) -> Self {
//             return Self(value + rhs.value)
//         }

//         /// @inherit
//         @inline(always)
//         def mutating infix ${$op=}(rhs: Self) {
//             value ${$op=} rhs.value
//         }
//     )... }
// }

// macro integer_type{
//     ($($Self:tok)*) => { $(
//         public struct $Self {
//             /// The builtin integer value.
//             internal var value: builtin.experimental.$Self

//             /// Empty C'tor. Initializes to zero.
//             init {
//                 self.value = 0
//             }

//             /// Memberwise C'tor.
//             @implicit init (value: builtin.experimental.$Self) {
//                 self.value = value
//             }

//             /// C'tor. Initialize from a String.
//             init? (str: String) {
//                 var value = intFromString<builtin.experimental.$Self>(str)
//                 if !value {
//                     return none
//                 }

//                 self.value = value!
//             }

//             /// Implicit conversion to the underlying value.
//             @implicit def infix as () -> builtin.experimental.$Self {
//                 return value
//             }

//             /// Largest representable value of this type.
//             alias max = limits.max<builtin.experimental.$Self>

//             /// Smallest representable value of this type.
//             alias min = limits.min<builtin.experimental.$Self>

//             /// Number of bits in this type.
//             alias bitwidth = limits.bitwidth<builtin.experimental.$Self>
//         }

//         extend $Self {
//             /// @inherit
//             @inline(always)
//             def prefix ~() -> Self {
//                 return Self(~self.value)
//             }
//         }

//         extend $Self {
//             proxy_operator!{ + - * / % << >> ** & | ^ }
//         }

//         extend $Self with Comparable {
//             /// @inherit
//             @inline(always)
//             def infix <=>(rhs: Self) -> prelude.Int {
//                 return value <=> rhs.value
//             }
//         }

//         // extend $Self with Randomizable {
//         //     static def random() -> Self {
//         //         let nextInt = Twister.nextInt()
//         //         static if $Self is decltype(nextInt) {
//         //             return nextInt
//         //         }
//         //         else {
//         //             alias RAND_MA = 1u << 31
//         //             return ((nextInt as prelude.UInt) / (RAND_MA / (max as prelude.UInt) + 1)) as Self
//         //         }
//         //     }
//         // }

//         extend $Self with Hashable {
//             /// @inherit
//             def hashValue() -> prelude.UInt {
//                 return self.value as prelude.UInt
//             }
//         }

//         extend $Self with Copyable, ImplicitlyCopyable {}
//     )... }
// }

// macro signed_integer{
//     ($($Self:tok)*) => { $(
//         extend $Self {
//             /// @return @code{1} if this integer is positive, @code{-1} if it is negative,
//             ///         @code{0} otherwise.
//             // prop signum: Int {
//             //     return if self < 0 then -1 else (self != 0 as Int)
//             // }

//             /// @inherit
//             @inline(always)
//             def prefix -() -> Self {
//                 return Self(-self.value)
//             }
//         }

//         // extend $Self with Sequence {
//         //     /// @inherit
//         //     def advanced(by: prelude.Int) -> Self {
//         //         return ((self as prelude.Int) + by) as Self
//         //     }
//         // }

//         extend $Self with StringRepresentable {
//             /// @inherit
//             def toString() -> String {
//                 return prelude.toString(value as builtin.experimental.Int64)
//             }
//         }
//     )... }
// }

// macro unsigned_integer{
//     ($($Self:tok)*) => { $(
//         // extend $Self with Sequence {
//         //     /// @inherit
//         //     def advanced(by: prelude.Int) -> Self {
//         //         return ((self as prelude.Int) + by) as Self
//         //     }
//         // }

//         extend $Self with StringRepresentable {
//             /// @inherit
//             def toString() -> String {
//                 return prelude.toString(value as builtin.experimental.UInt64)
//             }
//         }
//     )... }
// }

// macro integer_extensions{
//     ($(($Self:tok ($($Smaller:tok)*) ($($Larger:tok)*)))*) => { $(
//         extend $Self {
//             $(
//                 $Smaller
//             )...
//             $(
//                 $Larger
//             )...
//         }
//     )... }
// }

// integer_type!{ Int8 UInt8 Int16 UInt16 Int32 UInt32 Int64 UInt64 Int128 UInt128 }
// signed_integer!{ Int8 Int16 Int32 Int64 Int128 }
// unsigned_integer!{ UInt8 UInt16 UInt32 UInt64 UInt128 }

// public alias Int = Int64
// public alias UInt = UInt64

// macro implicit_init{
//     ($($Other:tok)*) => { $(
//         /// C'tor. Initialize from a smaller integer type.
//         @implicit init (val: $Other) {
//             self.value = val.value
//         }
//     )... }
// }

// macro explicit_init{
//     ($($Other:tok)*) => { $(
//         /// C'tor. Initialize from a smaller integer type of a different sign
//         init (val: $Other) {
//             self.value = val.value as! builtin.decltype(self.value)
//         }
//     )... }
// }

// macro implicit_conv{
//     ($($Other:tok)*) => { $(
//         /// @return the value extended to a larger integer type.
//         @implicit def infix as () -> $Other {
//             return $Other(self.value)
//         }
//     )... }
// }

// macro explicit_conv{
//     ($($Other:tok)*) => { $(
//         /// @return the value truncated to a larger integer type.
//         def infix as () -> $Other {
//             return $Other(self.value as builtin.experimental.$Other)
//         }
//     )... }
// }

// extend Int8 {
//     explicit_init!{ UInt8 Int16 UInt16 Int32 UInt32 Int64 UInt64 Int128 UInt128 }
//     implicit_conv!{ Int16 Int32 Int64 Int128 }
//     explicit_conv!{ UInt16 UInt32 UInt64 UInt128 }
// }

// extend UInt8 {
//     explicit_init!{ Int8 Int16 UInt16 Int32 UInt32 Int64 UInt64 Int128 UInt128 }
//     implicit_conv!{ UInt16 UInt32 UInt64 UInt128 }
//     explicit_conv!{ Int16 Int32 Int64 Int128 }
// }

// extend Int16 {
//     implicit_init!{ Int8 }
//     explicit_init!{ UInt8 UInt16 Int32 UInt32 Int64 UInt64 Int128 UInt128 }
//     implicit_conv!{ Int32 Int64 Int128 }
//     explicit_conv!{ Int8 UInt8 UInt16 UInt32 UInt64 UInt128 }
// }

// extend UInt16 {
//     implicit_init!{ UInt8 }
//     explicit_init!{ Int8 Int16 Int32 UInt32 Int64 UInt64 Int128 UInt128 }
//     implicit_conv!{ UInt32 UInt64 UInt128 }
//     explicit_conv!{ Int8 UInt8 Int16 Int32 Int64 Int128 }
// }

// extend Int32 {
//     implicit_init!{ Int8 Int16 }
//     explicit_init!{ UInt8 UInt16 UInt32 Int64 UInt64 Int128 UInt128 }
//     implicit_conv!{ Int64 Int128 }
//     explicit_conv!{ Int8 UInt8 Int16 UInt16 UInt32 UInt64 UInt128 }
// }

// extend UInt32 {
//     implicit_init!{ UInt8 UInt16 }
//     explicit_init!{ Int8 Int16 Int32 Int64 UInt64 Int128 UInt128 }
//     implicit_conv!{ UInt64 UInt128 }
//     explicit_conv!{ Int8 UInt8 Int16 Int32 Int64 Int128 }
// }

// extend Int64 {
//     implicit_init!{ Int8 Int16 Int32 }
//     explicit_init!{ UInt8 UInt16 UInt32 UInt64 Int128 UInt128 }
//     implicit_conv!{ Int128 }
//     explicit_conv!{ Int8 UInt8 Int16 UInt16 Int32 UInt32 UInt64 UInt128 }
// }

// extend UInt64 {
//     implicit_init!{ UInt8 UInt16 UInt32 }
//     explicit_init!{ Int8 Int16 Int32 Int64 Int128 UInt128 }
//     implicit_conv!{ UInt128 }
//     explicit_conv!{ Int8 UInt8 Int16 UInt16 Int32 UInt32 Int64 Int128 }
// }

// extend UInt32 {
//     def mutating changeEndianness() {
//         self |= (value & 0x000000FF) << 24
//         self |= (value & 0x0000FF00) << 8
//         self |= (value & 0x00FF0000) >> 8
//         self |= (value & 0xFF000000) >> 24
//     }
// }

// }

@inline(always)
public def advanced<I>(_ val: I, by: UInt) -> I where IsIntegral<I> {
    return val + (by as I)
}

@inline(always)
public def advanced<I>(_ val: I, by: Int) -> I where IsIntegral<I> {
    return val + (by as I)
}

private let hexDigits:   [u8; ?] = "0123456789abcdef"
private let base64igits: [u8; ?] = "ABCDEFGHIJKLMNOPQRSTUVWYZabcdefghijklmnopqrstuvwxyz0123456789+/"

public def toString<let Base = 10, I>(_ i: I) -> String where IsIntegral<I> {
    var i = i
    var s = ""

    alias Signed = !IsUnsigned<I>
    static if Signed {
        if i < 0 {
            s += '-'
            i = -i
        }
    }

    static if Base == 2 {
        s += "0b"
    }
    else static if Base == 8 {
        s += "0c"
    }
    else static if Base == 10 {
        // no prefix for decimal
    }
    else static if Base == 16 {
        s += "0x"
    }
    else static if Base == 64 {
        // no prefix for base64
    }
    else {
        static_assert(false, "Base must be one of 2, 8, 10, 16 or 64!")
    }
    
    var neededDigits = 0u
    var _i = i as I // FIME ImplicitlyCopyable

    loop {
        ++neededDigits
        _i /= (Base as I)

        if _i == 0 {
            break
        }
    }

    var power = (neededDigits - 1) as I
    loop {
        var exp = (Base as I) ** power
        var fits = i / exp

        static if Base == 64 {
            s += base64igits[fits]
        }
        else {
            s += hexDigits[fits]
        }

        i -= exp * fits
        if power == 0 {
            break
        }

        --power
    }

    return s
}

public def toString<T>(_ ptr: UnsafePtr<T>) -> String {
    return toString<16>(ptr as! UInt)
}

public def toString(_ ptr: UnsafePtr<Byte>, _ len: Int) -> String {
    return String(staticString: ptr, size: len)
}

public def printBinary<I>(_ val: I) where IsIntegral<I> {
    var val = val
    libc.printf("0b")
    for var i = reflect.sizeOf<I> * 8 - 1; true; --i {
        if (((i + 1) % 8) == 0) && (i != 63) {
            libc.printf("_")
        }

        libc.printf("%d", (val & (1u << i)) != 0)
        if i == 0 {
            break
        }
    }

    libc.printf("\n")
}

public def intFromString<I>(_ s: String) -> I? where IsIntegral<I> {
    var val = 0 as I
    if s.empty {
        return .Some(val)
    }

    alias Signed = !IsUnsigned<I>
    static if Signed {
        var negative = false
    }

    var power = 0u
    var i = s.size - 1

    loop {
        static if Signed {
            if s[i] == '-' {
                if i == 0 {
                    negative = true
                    break
                } else {
                    return none
                }
            }
        }

        if s[i] == '_' {
           // ignore
        } else if (s[i] < '0') || (s[i] > '9') {
            return none
        } else {
            val += ((10u ** power) * (s[i].ascii - '0') as u64) as I
            ++power
        }

        if i == 0 {
            break
        }

        --i
    }

    static if Signed {
        if negative {
            val = -val
        }
    }

    return .Some(val)
}

internal let Twister = rand.MersenneTwister()

public def random<I>(_ meta: MetaType<I>) -> I where IsIntegral<I> {
    let nextInt = Twister.nextInt()
    static if I is decltype(nextInt) {
        return nextInt
    }
    else {
        alias RAND_MA = 1u << 31
        alias N        = limits.max<I>

        return ((nextInt as UInt) / (RAND_MA / (N as UInt) + 1)) as I
    }
}

@inline(always)
public def copy<I>(_ i: I) -> I where IsIntegral<I> {
    return i
}
