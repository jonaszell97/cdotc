
module std.prelude

postfix !

public enum Option<T> {
    /// `none` represents the absence of a value.
    case None

    /// The `Some` case represents the presence of a value.
    case Some(T)

    /// C'tor. Initialize with an existing value.
    @implicit init (some value: T) {
        self = .Some(value)
    }

    /// C'tor. Initialize to none.
    init {
        self = none
    }

    /// \return the contained value. Traps if this Option does not contain a value.
    public def unwrap() -> T {
        match self {
        case .Some(let t):
            return builtin.copy(t)
        case .None:
            sys.reportFatalError("unwrapping a none value!")
        }
    }

    /// \return the contained value. Reports \param msg as a fatal error 
    ///         if this Option does not contain a value.
    public def unwrap(orReport msg: String) -> T {
        match self {
        case .Some(let t):
            return builtin.copy(t)
        case .None:
            sys.reportFatalError(msg)
        }
    }

    /// \return `true` iff this Option contains a value, and it equals \param t.
    public def holds(_ t: T) -> Bool {
        match self {
        case .Some(t):
            return true
        default:
            return false
        }
    }

    /// \return the value contained in this Option, or \param defaultVal if it is `none`.
    public def infix ?? (/*@autoclosure*/defaultVal: T) -> T {
        match self {
        case .Some(let t): 
            return t
        case .None:
            return defaultVal
        }
    }

    /// \see unwrap(_:)
    public def postfix !() -> T {
        return self.unwrap()
    }

    /// \return `true` iff this Option is `none`.
    public def prefix !() -> Bool {
        match self {
        case .Some(let t): 
            return false
        case .None:
            return true
        }
    }

    public def hasValue() -> Bool {
        if case .Some(let value) = self {
            return true
        }

        return false
    }
}

extend Option with StringRepresentable where T is StringRepresentable {
    def toString() -> String {
        match self {
        case .Some(let val):
            return ".Some($val)"
        case .None:
            return ".None"
        }
    }
}

extend Option with Equatable where T is Equatable {}
